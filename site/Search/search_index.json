{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230 Hrbust_ACM\u2018s Wiki\uff01 \u00b6 Let\u2019s Go !!! \u00b6 \u7f16\u5199\u4eba\u5458 \u00b6 \u7ec4\u7ec7\u7f16\u5199\uff1a \u5510\u8fdc\u65b0 \u5185\u5bb9\u5ba1\u6838\uff1a \u5218\u660e\u8f89 \u5185\u5bb9\u7f16\u64b0\uff1a \u8ba1 16-1 \u5218\u660e\u8f89\uff0c\u8ba1 18-9 \u80e1\u5c0f\u6587\uff0c\u8ba1 18-8 \u97a0\u6c38\u5168 \uff0c\u8ba1 18-5 \u738b\u4e1c\u741b \u8ba1 18-8 \u6768\u777f\uff0c\u8ba1 18-7 \u725b\u4ed4\u8d85 \uff0c\u7f51\u7edc 18-2 \u5434\u56fd\u5e86\uff0c\u7f51\u7edc 18-3 \u8463\u6587\u777f \u8ba1 18-5 \u738b\u4f73\u59ae\uff0c \u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd\uff0c\u7f51\u7edc 18-3 \u51af\u7d2b\u541b\uff0c\u8ba1 18-8 \u8499\u665f\u7ef4 Wiki\u7ef4\u62a4\uff1a \u9c81\u660e\u7ff0 \u66f4\u65b0\u65e5\u5fd7 \u00b6 \u5f53\u524d\u7248\u672c\u7f16\u53f7 - 20200515","title":"Getting Started"},{"location":"#hrbust_acms-wiki","text":"","title":"\u6b22\u8fce\u6765\u5230 Hrbust_ACM\u2018s Wiki\uff01"},{"location":"#lets-go","text":"","title":"Let\u2019s Go !!!"},{"location":"#_1","text":"\u7ec4\u7ec7\u7f16\u5199\uff1a \u5510\u8fdc\u65b0 \u5185\u5bb9\u5ba1\u6838\uff1a \u5218\u660e\u8f89 \u5185\u5bb9\u7f16\u64b0\uff1a \u8ba1 16-1 \u5218\u660e\u8f89\uff0c\u8ba1 18-9 \u80e1\u5c0f\u6587\uff0c\u8ba1 18-8 \u97a0\u6c38\u5168 \uff0c\u8ba1 18-5 \u738b\u4e1c\u741b \u8ba1 18-8 \u6768\u777f\uff0c\u8ba1 18-7 \u725b\u4ed4\u8d85 \uff0c\u7f51\u7edc 18-2 \u5434\u56fd\u5e86\uff0c\u7f51\u7edc 18-3 \u8463\u6587\u777f \u8ba1 18-5 \u738b\u4f73\u59ae\uff0c \u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd\uff0c\u7f51\u7edc 18-3 \u51af\u7d2b\u541b\uff0c\u8ba1 18-8 \u8499\u665f\u7ef4 Wiki\u7ef4\u62a4\uff1a \u9c81\u660e\u7ff0","title":"\u7f16\u5199\u4eba\u5458"},{"location":"#_2","text":"\u5f53\u524d\u7248\u672c\u7f16\u53f7 - 20200515","title":"\u66f4\u65b0\u65e5\u5fd7"},{"location":"faq/","text":"\u4f9d\u8d56\u73af\u5883 \u00b6 \u535a\u5ba2\u6846\u67b6\u57fa\u4e8epython\uff0c \u4f7f\u7528pip\u5b89\u88c5\u76f8\u5173\u5b89\u88c5\u5305 1 2 3 4 Python 3.0 - 3.7 . x # mkdocs\u8fd8\u672a\u652f\u6301Python 3.8.0 mkdocs >= 1 # \u535a\u5ba2\u6846\u67b6 mkdocs - material # mkdocs\u4e3b\u9898 pymdown - extensions # markdown\u6269\u5c55 \u535a\u5ba2\u7ed3\u6784 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 -.git : - # git\u914d\u7f6e\u6587\u4ef6\u5939\uff0c\u52ff\u52a8 -docs : - _static - Base - Data_Structure - ... # docs\u6587\u4ef6\u5939\u5b58\u653emarkdown\u6587\u4ef6\uff0c\u65e2\u535a\u5ba2\u5185\u5bb9 -site : - xxxx.html - ... # - mkdocs build\u547d\u4ee4\u540e\u751f\u6210\u7684\u9759\u6001\u6587\u4ef6\uff0c\u7531html\u7ec4\u6210\u3002 - CNAME # DNS\u57df\u540d\u914d\u7f6e\u6587\u4ef6\uff0c\u82e5\u4e22\u5931\u4f1a\u9020\u6210\u57df\u540d\u65e0\u6cd5\u89e3\u6790 - mkdocs.yml # mkdocs\u914d\u7f6e\u6587\u4ef6\uff0c\u6587\u7ae0\u76ee\u5f55 - README.md # GitHub\u4ed3\u5e93\u4ecb\u7ecd\u6587\u4ef6 Git\u547d\u4ee4\u7b80\u4ecb \u00b6 \u9700\u8981\u5b89\u88c5git\u73af\u5883\uff0c \u4e0b\u8f7dGit \u6709\u547d\u4ee4\u884c\u548cGUI\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff0c\u63a8\u8350\u4e24\u79cd\u7ed3\u5408\u4f7f\u7528 \u4e0b\u8f7dGitHub Desktop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 start a working area ( see also: git help tutorial ) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change ( see also: git help everyday ) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state ( see also: git help revisions ) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate ( see also: git help workflows ) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects \u5e38\u7528\u7684\u547d\u4ee4\u53ea\u6709\u51e0\u6761\u719f\u6089\u5373\u53ef\uff0c\u6211\u4eec\u4e00\u822c\u5728GUI\u4e2d\u64cd\u4f5c git clone url git add -A git commit -m \u201c\u672c\u6b21\u63d0\u4ea4\u7684\u8bf4\u660e\u201d git push MkDocs\u547d\u4ee4 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 MkDocs - Project documentation with Markdown . Options : -V , - -version Show the version and exit . -q , - -quiet Silence warnings -v , - -verbose Enable verbose output -h , - -help Show this message and exit . Commands : build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development server \u5e38\u7528\u64cd\u4f5c\u6d41\u7a0b\uff0c\u5728\u4efb\u4e00\u7ec8\u7aef\u4e0b \u8fdb\u5165wiki\u7684\u6839\u76ee\u5f55\u4f7f\u7528mkdocs serve \u542f\u52a8\u672c\u5730\u670d\u52a1\uff0c\u6b64\u65f6\u53ef\u4ee5\u5728 127.0.0.1:8000 \u4f7f\u7528\u6d4f\u89c8\u5668\u8bbf\u95ee \u672c\u5730\u6587\u4ef6\u4fee\u6539\u540e\uff0c\u65e0\u9700\u91cd\u542f\u670d\u52a1\uff0c\u4fdd\u5b58\u540e\u6d4f\u89c8\u5668\u81ea\u52a8\u5237\u65b0 \u4fee\u6539\u5b8c\u6210\u540e\u4f7f\u7528 mkdocs build \u751f\u6210\u9759\u6001\u6587\u4ef6 /site \u6587\u4ef6\u5939 \u65e0\u9700\u4f7f\u7528gh-deploy\u548cnew\u547d\u4ee4 \u53c2\u4e0e\u7f16\u5199 \u00b6 > \u6211\u662f\u840c\u65b0 \u00b6 \u53c2\u4e0eWiki\u7684\u7f16\u5199 \u9700\u8981 \u4e00\u4e2a GitHub \u8d26\u53f7\uff0c \u4e0d\u9700\u8981 \u9ad8\u8d85\u7684 GitHub \u6280\u5de7\u3002 \u7ef4\u4fee\u4e2d\u3002\u3002\u3002 > \u6211\u662f\u5927\u4f6c \u00b6 \u88ab\u8feb\u6210\u4e3a\u5927\u4f6c\uff0c\u63d0\u4ea4\u4f60\u5b9d\u8d35\u7684\u7b2c\u4e00\u6b21 PR\uff08Pull Requests\uff09 \u5427 PR\u4e94\u6b65\u8d70\u6d41\u7a0b fork\u672c\u9879\u76ee\u5230\u81ea\u5df1\u7684\u4ed3\u5e93 \u6210\u529f\u540e\uff1a\uff08\u6ce8\u610f\u8fd9\u91cc\u5df2\u7ecf\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\u4e86\uff0c\u7528\u6237\u540drelifes\uff0c\u5e76\u4e14\u56fe\u6807\u53d8\u6210\u4e86\u53c9\u5b50\uff09 clone\u5230\u672c\u5730\u8fdb\u884c\u4fee\u6539\uff0c\u7531\u4e8e\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\uff0c\u6240\u4ee5\u60f3\u600e\u4e48\u6539\u90fd\u884c \u8fd9\u91cc\u67094\u79cd\u65b9\u5f0f\u514b\u9686\u4e0b\u6765 git clone https://github.com/username/wiki.git git clone git@github.com:username/wiki.git \u4f7f\u7528Destop\u5ba2\u6237\u7aef\u514b\u9686 \u76f4\u63a5\u4e0b\u8f7d\u9879\u76ee\u7684\u6e90\u7801\u538b\u7f29\u5305","title":"\u5982\u4f55\u4f7f\u7528"},{"location":"faq/#_1","text":"\u535a\u5ba2\u6846\u67b6\u57fa\u4e8epython\uff0c \u4f7f\u7528pip\u5b89\u88c5\u76f8\u5173\u5b89\u88c5\u5305 1 2 3 4 Python 3.0 - 3.7 . x # mkdocs\u8fd8\u672a\u652f\u6301Python 3.8.0 mkdocs >= 1 # \u535a\u5ba2\u6846\u67b6 mkdocs - material # mkdocs\u4e3b\u9898 pymdown - extensions # markdown\u6269\u5c55","title":"\u4f9d\u8d56\u73af\u5883"},{"location":"faq/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 -.git : - # git\u914d\u7f6e\u6587\u4ef6\u5939\uff0c\u52ff\u52a8 -docs : - _static - Base - Data_Structure - ... # docs\u6587\u4ef6\u5939\u5b58\u653emarkdown\u6587\u4ef6\uff0c\u65e2\u535a\u5ba2\u5185\u5bb9 -site : - xxxx.html - ... # - mkdocs build\u547d\u4ee4\u540e\u751f\u6210\u7684\u9759\u6001\u6587\u4ef6\uff0c\u7531html\u7ec4\u6210\u3002 - CNAME # DNS\u57df\u540d\u914d\u7f6e\u6587\u4ef6\uff0c\u82e5\u4e22\u5931\u4f1a\u9020\u6210\u57df\u540d\u65e0\u6cd5\u89e3\u6790 - mkdocs.yml # mkdocs\u914d\u7f6e\u6587\u4ef6\uff0c\u6587\u7ae0\u76ee\u5f55 - README.md # GitHub\u4ed3\u5e93\u4ecb\u7ecd\u6587\u4ef6","title":"\u535a\u5ba2\u7ed3\u6784"},{"location":"faq/#git","text":"\u9700\u8981\u5b89\u88c5git\u73af\u5883\uff0c \u4e0b\u8f7dGit \u6709\u547d\u4ee4\u884c\u548cGUI\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff0c\u63a8\u8350\u4e24\u79cd\u7ed3\u5408\u4f7f\u7528 \u4e0b\u8f7dGitHub Desktop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 start a working area ( see also: git help tutorial ) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change ( see also: git help everyday ) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state ( see also: git help revisions ) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate ( see also: git help workflows ) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects \u5e38\u7528\u7684\u547d\u4ee4\u53ea\u6709\u51e0\u6761\u719f\u6089\u5373\u53ef\uff0c\u6211\u4eec\u4e00\u822c\u5728GUI\u4e2d\u64cd\u4f5c git clone url git add -A git commit -m \u201c\u672c\u6b21\u63d0\u4ea4\u7684\u8bf4\u660e\u201d git push","title":"Git\u547d\u4ee4\u7b80\u4ecb"},{"location":"faq/#mkdocs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 MkDocs - Project documentation with Markdown . Options : -V , - -version Show the version and exit . -q , - -quiet Silence warnings -v , - -verbose Enable verbose output -h , - -help Show this message and exit . Commands : build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development server \u5e38\u7528\u64cd\u4f5c\u6d41\u7a0b\uff0c\u5728\u4efb\u4e00\u7ec8\u7aef\u4e0b \u8fdb\u5165wiki\u7684\u6839\u76ee\u5f55\u4f7f\u7528mkdocs serve \u542f\u52a8\u672c\u5730\u670d\u52a1\uff0c\u6b64\u65f6\u53ef\u4ee5\u5728 127.0.0.1:8000 \u4f7f\u7528\u6d4f\u89c8\u5668\u8bbf\u95ee \u672c\u5730\u6587\u4ef6\u4fee\u6539\u540e\uff0c\u65e0\u9700\u91cd\u542f\u670d\u52a1\uff0c\u4fdd\u5b58\u540e\u6d4f\u89c8\u5668\u81ea\u52a8\u5237\u65b0 \u4fee\u6539\u5b8c\u6210\u540e\u4f7f\u7528 mkdocs build \u751f\u6210\u9759\u6001\u6587\u4ef6 /site \u6587\u4ef6\u5939 \u65e0\u9700\u4f7f\u7528gh-deploy\u548cnew\u547d\u4ee4","title":"MkDocs\u547d\u4ee4"},{"location":"faq/#_3","text":"","title":"\u53c2\u4e0e\u7f16\u5199"},{"location":"faq/#_4","text":"\u53c2\u4e0eWiki\u7684\u7f16\u5199 \u9700\u8981 \u4e00\u4e2a GitHub \u8d26\u53f7\uff0c \u4e0d\u9700\u8981 \u9ad8\u8d85\u7684 GitHub \u6280\u5de7\u3002 \u7ef4\u4fee\u4e2d\u3002\u3002\u3002","title":"&gt; \u6211\u662f\u840c\u65b0"},{"location":"faq/#_5","text":"\u88ab\u8feb\u6210\u4e3a\u5927\u4f6c\uff0c\u63d0\u4ea4\u4f60\u5b9d\u8d35\u7684\u7b2c\u4e00\u6b21 PR\uff08Pull Requests\uff09 \u5427 PR\u4e94\u6b65\u8d70\u6d41\u7a0b fork\u672c\u9879\u76ee\u5230\u81ea\u5df1\u7684\u4ed3\u5e93 \u6210\u529f\u540e\uff1a\uff08\u6ce8\u610f\u8fd9\u91cc\u5df2\u7ecf\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\u4e86\uff0c\u7528\u6237\u540drelifes\uff0c\u5e76\u4e14\u56fe\u6807\u53d8\u6210\u4e86\u53c9\u5b50\uff09 clone\u5230\u672c\u5730\u8fdb\u884c\u4fee\u6539\uff0c\u7531\u4e8e\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\uff0c\u6240\u4ee5\u60f3\u600e\u4e48\u6539\u90fd\u884c \u8fd9\u91cc\u67094\u79cd\u65b9\u5f0f\u514b\u9686\u4e0b\u6765 git clone https://github.com/username/wiki.git git clone git@github.com:username/wiki.git \u4f7f\u7528Destop\u5ba2\u6237\u7aef\u514b\u9686 \u76f4\u63a5\u4e0b\u8f7d\u9879\u76ee\u7684\u6e90\u7801\u538b\u7f29\u5305","title":"&gt; \u6211\u662f\u5927\u4f6c"},{"location":"home/","text":"\u4e00\uff1a\u5173\u4e8e\u672c\u7ad9 \u00b6 Info \u535a\u5ba2\u6846\u67b6 : MkDocs \u4e3b\u9898 : Material for MkDocs \u7f16\u5199\u6587\u672c \uff1amarkdown \u4e8c\uff1a\u7f16\u5199\u8bf4\u660e \u00b6 \u63a8\u8350\u4f7f\u7528 Typora \u6765\u7f16\u5199markdown\u6587\u4ef6 \u535a\u5ba2\u67b6\u6784\u652f\u6301 LaTeX \u6570\u5b66\u516c\u5f0f\u548cmarkdown\u6269\u5c55 \u4f8b\u5982\u4f60\u6240\u89c1\u5230\u7684 f_{i,j,k} f_{i,j,k} , f(i,j,k) f(i,j,k) \u652f\u6301\u4ee3\u7801\u9ad8\u4eae\u4e0e\u590d\u5236 C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <bits/stdc++.h> using namespace std ; int main () { vector < int > v ; for ( int i = 1 ; i <= 10 ; i ++ ) v . push_back ( i ); for ( auto x : v ) cout << x << \" \" ; printf ( \"Hello World \\n \" ); return 0 ; } python 1 2 3 4 5 6 def blogs_with_type ( request , blog_type_pk ): context = {} blog_type = get_object_or_404 ( BlogType , pk = blog_type_pk ) context [ 'blogs' ] = Blog . objects . filter ( blog_type = blog_type ) context [ 'blog_type' ] = blog_type return render ( request , 'blogs_with_type.html' , context ) \u4e09\uff1a\u7f16\u8f91\u4fee\u6539 \u00b6 \u719f\u6089GitHub\u7684\u540c\u5b66\u53ef\u4ee5\u76f4\u63a5\u63d0\u4ea4PR \u4e0d\u719f\u6089\u7684\u5c06\u5199\u597d\u7684\u6587\u6863\u53d1\u5230 QQ: 1486176948\uff0c \u63a8\u8350\u63d0\u4ea4markdown\u6587\u6863\u3002","title":"Wiki\u4ecb\u7ecd"},{"location":"home/#_1","text":"Info \u535a\u5ba2\u6846\u67b6 : MkDocs \u4e3b\u9898 : Material for MkDocs \u7f16\u5199\u6587\u672c \uff1amarkdown","title":"\u4e00\uff1a\u5173\u4e8e\u672c\u7ad9"},{"location":"home/#_2","text":"\u63a8\u8350\u4f7f\u7528 Typora \u6765\u7f16\u5199markdown\u6587\u4ef6 \u535a\u5ba2\u67b6\u6784\u652f\u6301 LaTeX \u6570\u5b66\u516c\u5f0f\u548cmarkdown\u6269\u5c55 \u4f8b\u5982\u4f60\u6240\u89c1\u5230\u7684 f_{i,j,k} f_{i,j,k} , f(i,j,k) f(i,j,k) \u652f\u6301\u4ee3\u7801\u9ad8\u4eae\u4e0e\u590d\u5236 C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <bits/stdc++.h> using namespace std ; int main () { vector < int > v ; for ( int i = 1 ; i <= 10 ; i ++ ) v . push_back ( i ); for ( auto x : v ) cout << x << \" \" ; printf ( \"Hello World \\n \" ); return 0 ; } python 1 2 3 4 5 6 def blogs_with_type ( request , blog_type_pk ): context = {} blog_type = get_object_or_404 ( BlogType , pk = blog_type_pk ) context [ 'blogs' ] = Blog . objects . filter ( blog_type = blog_type ) context [ 'blog_type' ] = blog_type return render ( request , 'blogs_with_type.html' , context )","title":"\u4e8c\uff1a\u7f16\u5199\u8bf4\u660e"},{"location":"home/#_3","text":"\u719f\u6089GitHub\u7684\u540c\u5b66\u53ef\u4ee5\u76f4\u63a5\u63d0\u4ea4PR \u4e0d\u719f\u6089\u7684\u5c06\u5199\u597d\u7684\u6587\u6863\u53d1\u5230 QQ: 1486176948\uff0c \u63a8\u8350\u63d0\u4ea4markdown\u6587\u6863\u3002","title":"\u4e09\uff1a\u7f16\u8f91\u4fee\u6539"},{"location":"markdown-model/","text":"","title":"Markdown model"},{"location":"2019/BZOJ/BZOJ%201069/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 Lydsy 1069 [SCOI2007]\u6700\u5927\u571f\u5730\u9762\u79ef 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u67d0\u5757\u5e73\u9762\u571f\u5730\u4e0a\u6709N\u4e2a\u70b9\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u5176\u4e2d\u7684\u4efb\u610f\u56db\u4e2a\u70b9\uff0c\u5c06\u8fd9\u7247\u571f\u5730\u56f4\u8d77\u6765\uff0c\u5f53\u7136\uff0c\u4f60\u5e0c\u671b\u8fd9\u56db\u4e2a\u70b9\u56f4\u6210\u7684\u591a\u8fb9\u5f62\u9762\u79ef\u6700\u5927\u3002(N<=2000) 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u51f8\u5305\u3001\u65cb\u8f6c\u5361\u58f3\u7b97\u6cd5 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u5728\u70b9\u96c6\u4e2d\u9009\u62e9\u56db\u4e2a\u70b9\u4f7f\u5f97\u5b83\u4eec\u56f4\u6210\u7684\u9762\u79ef\u6700\u5927\u3002\u901a\u8fc7\u76f4\u89c2\u611f\u53d7\u548c\u51f8\u5305\u7684\u5b9a\u4e49\u53ef\u4ee5\u77e5\u9053\u8fd9\u56db\u4e2a\u70b9\u4e00\u5b9a\u8981\u5728\u70b9\u96c6\u7684\u51f8\u5305\u4e0a\u9009\u53d6\u3002\u9996\u5148\u5bf9\u70b9\u96c6\u6c42\u51f8\u5305\uff0c\u7136\u540e\u5728\u51f8\u5305\u4e0a\u679a\u4e3e\u4e24\u4e2a\u70b9\u4f5c\u4e3a\u5f85\u5bfb\u627e\u7684\u56db\u8fb9\u5f62\u7684\u5bf9\u89d2\u7ebf\uff0c\u7136\u540e\u4f7f\u7528\u65cb\u8f6c\u5361\u58f3\u6c42\u9762\u79ef\u7684\u601d\u60f3\u5bfb\u627e\u4f7f\u5f97\u5bf9\u89d2\u7ebf\u4e24\u4fa7\u7684\u4e24\u4e2a\u4e09\u89d2\u5f62\u9762\u79ef\u6700\u5927\u7684\u4e09\u89d2\u5f62\u9876\u70b9\u3002\u7ef4\u62a4\u603b\u9762\u79ef\u7684\u6700\u5927\u503c\u5373\u53ef\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u4f7f\u7528\u65cb\u8f6c\u5361\u58f3\u7b97\u6cd5\u65f6\u679a\u4e3e\u7684\u5bf9\u89d2\u7ebf\u7684\u4e24\u4e2a\u7aef\u70b9\u5e94\u5f53\u81f3\u5c11\u95f4\u9694\u4e00\u4e2a\u70b9\u4ee5\u5bb9\u7eb3\u4e09\u89d2\u5f62\u7684\u9876\u70b9\u3002\u4e09\u89d2\u5f62\u9876\u70b9\u5728\u65cb\u8f6c\u65f6\u4e0d\u5e94\u8d8a\u8fc7\u4e09\u89d2\u5f62\u7684\u5e95\u8fb9\u3002\u7531\u4e8e\u672c\u9898\u4e2d\u95f4\u8fc7\u7a0b\u5168\u90e8\u662fdouble\u7c7b\u578b\uff0c\u6240\u4ee5\u8981\u6ce8\u610f\u7cbe\u5ea6\u4fdd\u8bc1\u3002\u9700\u8981\u4f7f\u7528eps\u6765\u5224\u65ad\u4efb\u610f\u6570\u4e0e0\u7684\u5173\u7cfb\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 https://www.lydsy.com/JudgeOnline/problem.php?id=1069 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include <iostream> #include <cstdlib> #include <cstdio> #include <cmath> #include <cstring> #include <algorithm> #define maxn 2005 #define eps 1e-4 using namespace std ; int n , top ; double ans = 0 ; struct point { double x , y ; point () {} point ( double a , double b ) { x = a ; y = b ; } point ( point a , point b ) { x = b . x - a . x ; y = b . y - a . y ; } } p [ maxn ], s [ maxn ]; double sign ( double a ) { if ( fabs ( a ) <= eps ) return 0 ; else return a > 0 ? 1 : - 1 ; } double cross ( point a , point b ) { double s = ( a . x * b . y - a . y * b . x ); return s ; } double dis ( point a , point b ) { return ( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y ); } point operator - ( point a , point b ) { return ( point ) { a . x - b . x , a . y - b . y }; } double operator * ( point a , point b ) { return a . x * b . y - a . y * b . x ; } bool cmp ( point a , point b ) { double x = cross ( point ( p [ 1 ], a ), point ( p [ 1 ], b )); if ( x > 0 ) return 1 ; if ( x == 0 ) return dis ( p [ 1 ], a ) < dis ( p [ 1 ], b ); } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { double aa , bb ; scanf ( \"%lf%lf\" , & aa , & bb ); p [ i ] = point ( aa , bb ); } int t = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( p [ i ]. y < p [ t ]. y || ( p [ i ]. y == p [ t ]. y && p [ i ]. x < p [ t ]. x )) { t = i ; } } swap ( p [ t ], p [ 1 ]); sort ( p + 2 , p + n + 1 , cmp ); s [ 1 ] = p [ 1 ]; s [ 2 ] = p [ 2 ]; top = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { while ( top > 1 && cross ( point ( s [ top - 1 ], p [ i ]), point ( s [ top - 1 ], s [ top ])) >= 0 ) top -- ; s [ ++ top ] = p [ i ]; } int i , j ; s [ top + 1 ] = s [ 1 ]; for ( int x = 1 ; x <= top - 2 ; x ++ ) { i = ( x + 1 ) % top ; j = ( x + 3 ) % top ; for ( int y = x + 2 ; y <= top ; y ++ ) { while ( i % top + 1 != y && sign (( s [ i + 1 ] - s [ x ]) * ( s [ y ] - s [ x ]) - ( s [ i ] - s [ x ]) * ( s [ y ] - s [ x ])) == 1 ) //while (i%top+1!=y&&sign(cross(point(s[i+1],s[x]),point(s[y],s[x]))-cross(point(s[i],s[x]),point(s[y],s[x]))) == 1) i = i % top + 1 ; //while (j%top+1!=x&&sign(cross(point(s[y],s[x]),point(s[j+1],s[x]))-cross(point(s[y],s[x]),point(s[j]-s[x]))) == 1) while ( j % top + 1 != x && sign (( s [ y ] - s [ x ]) * ( s [ j + 1 ] - s [ x ]) - ( s [ y ] - s [ x ]) * ( s [ j ] - s [ x ])) == 1 ) j = j % top + 1 ; ans = max ( ans ,( s [ i ] - s [ x ]) * ( s [ y ] - s [ x ]) + ( s [ y ] - s [ x ]) * ( s [ j ] - s [ x ])); } } printf ( \"%.3f \\n \" , ans / 2.0 ); return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"BZOJ 1069 \u70b9\u96c6\u4e2d\u6c42\u56db\u70b9\u6700\u5927\u9762\u79ef"},{"location":"2019/BZOJ/BZOJ%201069/#1","text":"Lydsy 1069 [SCOI2007]\u6700\u5927\u571f\u5730\u9762\u79ef","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/BZOJ/BZOJ%201069/#2","text":"\u5728\u67d0\u5757\u5e73\u9762\u571f\u5730\u4e0a\u6709N\u4e2a\u70b9\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u5176\u4e2d\u7684\u4efb\u610f\u56db\u4e2a\u70b9\uff0c\u5c06\u8fd9\u7247\u571f\u5730\u56f4\u8d77\u6765\uff0c\u5f53\u7136\uff0c\u4f60\u5e0c\u671b\u8fd9\u56db\u4e2a\u70b9\u56f4\u6210\u7684\u591a\u8fb9\u5f62\u9762\u79ef\u6700\u5927\u3002(N<=2000)","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/BZOJ/BZOJ%201069/#3","text":"\u51f8\u5305\u3001\u65cb\u8f6c\u5361\u58f3\u7b97\u6cd5","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/BZOJ/BZOJ%201069/#4","text":"\u5728\u70b9\u96c6\u4e2d\u9009\u62e9\u56db\u4e2a\u70b9\u4f7f\u5f97\u5b83\u4eec\u56f4\u6210\u7684\u9762\u79ef\u6700\u5927\u3002\u901a\u8fc7\u76f4\u89c2\u611f\u53d7\u548c\u51f8\u5305\u7684\u5b9a\u4e49\u53ef\u4ee5\u77e5\u9053\u8fd9\u56db\u4e2a\u70b9\u4e00\u5b9a\u8981\u5728\u70b9\u96c6\u7684\u51f8\u5305\u4e0a\u9009\u53d6\u3002\u9996\u5148\u5bf9\u70b9\u96c6\u6c42\u51f8\u5305\uff0c\u7136\u540e\u5728\u51f8\u5305\u4e0a\u679a\u4e3e\u4e24\u4e2a\u70b9\u4f5c\u4e3a\u5f85\u5bfb\u627e\u7684\u56db\u8fb9\u5f62\u7684\u5bf9\u89d2\u7ebf\uff0c\u7136\u540e\u4f7f\u7528\u65cb\u8f6c\u5361\u58f3\u6c42\u9762\u79ef\u7684\u601d\u60f3\u5bfb\u627e\u4f7f\u5f97\u5bf9\u89d2\u7ebf\u4e24\u4fa7\u7684\u4e24\u4e2a\u4e09\u89d2\u5f62\u9762\u79ef\u6700\u5927\u7684\u4e09\u89d2\u5f62\u9876\u70b9\u3002\u7ef4\u62a4\u603b\u9762\u79ef\u7684\u6700\u5927\u503c\u5373\u53ef\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/BZOJ/BZOJ%201069/#5","text":"\u4f7f\u7528\u65cb\u8f6c\u5361\u58f3\u7b97\u6cd5\u65f6\u679a\u4e3e\u7684\u5bf9\u89d2\u7ebf\u7684\u4e24\u4e2a\u7aef\u70b9\u5e94\u5f53\u81f3\u5c11\u95f4\u9694\u4e00\u4e2a\u70b9\u4ee5\u5bb9\u7eb3\u4e09\u89d2\u5f62\u7684\u9876\u70b9\u3002\u4e09\u89d2\u5f62\u9876\u70b9\u5728\u65cb\u8f6c\u65f6\u4e0d\u5e94\u8d8a\u8fc7\u4e09\u89d2\u5f62\u7684\u5e95\u8fb9\u3002\u7531\u4e8e\u672c\u9898\u4e2d\u95f4\u8fc7\u7a0b\u5168\u90e8\u662fdouble\u7c7b\u578b\uff0c\u6240\u4ee5\u8981\u6ce8\u610f\u7cbe\u5ea6\u4fdd\u8bc1\u3002\u9700\u8981\u4f7f\u7528eps\u6765\u5224\u65ad\u4efb\u610f\u6570\u4e0e0\u7684\u5173\u7cfb\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/BZOJ/BZOJ%201069/#6","text":"https://www.lydsy.com/JudgeOnline/problem.php?id=1069","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/BZOJ/BZOJ%201069/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include <iostream> #include <cstdlib> #include <cstdio> #include <cmath> #include <cstring> #include <algorithm> #define maxn 2005 #define eps 1e-4 using namespace std ; int n , top ; double ans = 0 ; struct point { double x , y ; point () {} point ( double a , double b ) { x = a ; y = b ; } point ( point a , point b ) { x = b . x - a . x ; y = b . y - a . y ; } } p [ maxn ], s [ maxn ]; double sign ( double a ) { if ( fabs ( a ) <= eps ) return 0 ; else return a > 0 ? 1 : - 1 ; } double cross ( point a , point b ) { double s = ( a . x * b . y - a . y * b . x ); return s ; } double dis ( point a , point b ) { return ( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y ); } point operator - ( point a , point b ) { return ( point ) { a . x - b . x , a . y - b . y }; } double operator * ( point a , point b ) { return a . x * b . y - a . y * b . x ; } bool cmp ( point a , point b ) { double x = cross ( point ( p [ 1 ], a ), point ( p [ 1 ], b )); if ( x > 0 ) return 1 ; if ( x == 0 ) return dis ( p [ 1 ], a ) < dis ( p [ 1 ], b ); } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { double aa , bb ; scanf ( \"%lf%lf\" , & aa , & bb ); p [ i ] = point ( aa , bb ); } int t = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( p [ i ]. y < p [ t ]. y || ( p [ i ]. y == p [ t ]. y && p [ i ]. x < p [ t ]. x )) { t = i ; } } swap ( p [ t ], p [ 1 ]); sort ( p + 2 , p + n + 1 , cmp ); s [ 1 ] = p [ 1 ]; s [ 2 ] = p [ 2 ]; top = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { while ( top > 1 && cross ( point ( s [ top - 1 ], p [ i ]), point ( s [ top - 1 ], s [ top ])) >= 0 ) top -- ; s [ ++ top ] = p [ i ]; } int i , j ; s [ top + 1 ] = s [ 1 ]; for ( int x = 1 ; x <= top - 2 ; x ++ ) { i = ( x + 1 ) % top ; j = ( x + 3 ) % top ; for ( int y = x + 2 ; y <= top ; y ++ ) { while ( i % top + 1 != y && sign (( s [ i + 1 ] - s [ x ]) * ( s [ y ] - s [ x ]) - ( s [ i ] - s [ x ]) * ( s [ y ] - s [ x ])) == 1 ) //while (i%top+1!=y&&sign(cross(point(s[i+1],s[x]),point(s[y],s[x]))-cross(point(s[i],s[x]),point(s[y],s[x]))) == 1) i = i % top + 1 ; //while (j%top+1!=x&&sign(cross(point(s[y],s[x]),point(s[j+1],s[x]))-cross(point(s[y],s[x]),point(s[j]-s[x]))) == 1) while ( j % top + 1 != x && sign (( s [ y ] - s [ x ]) * ( s [ j + 1 ] - s [ x ]) - ( s [ y ] - s [ x ]) * ( s [ j ] - s [ x ])) == 1 ) j = j % top + 1 ; ans = max ( ans ,( s [ i ] - s [ x ]) * ( s [ y ] - s [ x ]) + ( s [ y ] - s [ x ]) * ( s [ j ] - s [ x ])); } } printf ( \"%.3f \\n \" , ans / 2.0 ); return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/BZOJ/BZOJ%201069/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/Codeforces%20505D/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 CodeForces 505D Mr. Kitayuta\u2019s Technology 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u7ed9n\u4e2a\u70b9\uff0c\u7136\u540e\u7ed9\u51fam\u4e2a\u6761\u4ef6a\u3001b\uff0c\u8868\u793aa\u53ef\u5230\u8fbeb\uff0c\u6c42\u6700\u5c11\u9700\u8981\u5efa\u591a\u5c11\u6761\u6709\u5411\u8fb9\u624d\u80fd\u6ee1\u8db3\u6240\u6709\u6761\u4ef6\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u6784\u9020\u3001\u62d3\u6251\u3001bfs 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u9996\u5148\u5bf9\u4e8e\u6bcf\u4e2a\u5355\u72ec\u7684\u8fde\u901a\u5757\uff08\u628a\u8fb9\u90fd\u770b\u6210\u53cc\u5411\u8fb9\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5b83\u62c9\u6210\u4e00\u6761\u94fe\u6216\u4e00\u4e2a\u73af\u3002 \u94fe\u7684\u60c5\u51b5\u5982\u6837\u4f8b\u4e00\uff1a1->2->3->4\u3002\u8fd9\u6837\u524d\u9762\u7684\u70b9\u90fd\u53ef\u4ee5\u5230\u8fbe\u76f8\u5bf9\u4f4d\u7f6e\u540e\u9762\u7684\u70b9\uff0c\u4e14\u603b\u8fb9\u6570\u6700\u5c0f\uff0c\u4e3a\u70b9\u6570-1\u3002\u4f46\u662f\u82e5\u8be5\u8054\u901a\u5757\u4e2d\u5b58\u5728\u73af\uff0c\u5219\u65e0\u6cd5\u62c9\u6210\u4e00\u6839\u94fe\uff0c\u5982\u6837\u4f8b\u4e8c\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u52a0\u4e00\u6761\u94fe\u5c3e\u5230\u94fe\u9996\u7684\u8fb9\u89e3\u51b3\u6240\u6709\u7684\u73af\u7684\u51b2\u7a81\u3002\u5728\u6837\u4f8b\u4e8c\u4e2d\u4e3a1->2->3->4->1\u3002\u8fd9\u6837\u603b\u8fb9\u6570\u6700\u5c0f\uff0c\u4e3a\u70b9\u6570\u3002 \u6240\u4ee5\u5148\u628a\u8fb9\u770b\u6210\u53cc\u5411\u8fb9\uff0c\u5bf9\u6bcf\u4e2a\u8fde\u901a\u5757\u67d3\u8272\uff0c\u7136\u540e\u62d3\u6251\u5224\u65ad\u662f\u5426\u5b58\u5728\u73af\uff0c\u82e5\u5b58\u5728\uff0c\u7b54\u6848+=\u8fde\u901a\u5757\u4e2d\u7684\u70b9\u6570\uff1b\u5426\u5219+= \u8fde\u901a\u5757\u4e2d\u7684\u70b9\u6570-1\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u9700\u8981\u60f3\u5230\u94fe\u548c\u73af\u5206\u522b\u5e94\u8be5\u5982\u4f55\u6784\u9020\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://codeforces.com/contest/505/problem/D 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <bits//stdc++.h> using namespace std ; struct EDGE { int to , next ; } edge [ 500005 ], dedge [ 500005 ]; int head [ 100005 ], dhead [ 100005 ], cnt , dcnt ; void addedge ( int fr , int to , int k ){ if ( ! k ){ edge [ cnt ] = { to , head [ fr ]}; head [ fr ] = cnt ++ ; } else { dedge [ dcnt ] = { to , dhead [ fr ]}; dhead [ fr ] = dcnt ++ ; dedge [ dcnt ] = { fr , dhead [ to ]}; dhead [ to ] = dcnt ++ ; } } int ans , color [ 100005 ], n , m , in [ 100005 ]; void init (){ memset ( color , - 1 , sizeof ( color )); memset ( head , - 1 , sizeof ( head )); memset ( dhead , - 1 , sizeof ( dhead )); cnt = dcnt = 0 ; } queue < int > q2 ; vector < int > pp ; void bfs ( int q ){ while ( q2 . size ()) q2 . pop (); pp . clear (); queue < int > que ; que . push ( q ); while ( que . size ()){ int k = que . front (); que . pop (); pp . push_back ( k ); if ( ! in [ k ]) q2 . push ( k ); for ( int i = dhead [ k ]; i !=- 1 ; i = dedge [ i ]. next ){ int v = dedge [ i ]. to ; if ( color [ v ] !=- 1 ) continue ; color [ v ] = color [ k ]; que . push ( v ); } } } void tuopu ( int q ){ if ( pp . size () <= 1 ) return ; while ( q2 . size ()){ int k = q2 . front (); q2 . pop (); for ( int i = head [ k ]; i !=- 1 ; i = edge [ i ]. next ){ int v = edge [ i ]. to ; in [ v ] -- ; if ( ! in [ v ]) q2 . push ( v ); } } bool key = 0 ; for ( int i = 0 ; i < pp . size (); i ++ ){ if ( in [ pp [ i ]]){ key = 1 ; break ; } } if ( key ) ans += pp . size (); else ans += pp . size () - 1 ; } int main (){ init (); cin >> n >> m ; for ( int i = 0 ; i < m ; i ++ ){ int u , v ; cin >> u >> v ; addedge ( u , v , 0 ); addedge ( u , v , 1 ); in [ v ] ++ ; } int num_color = 0 ; for ( int i = 1 ; i <= n ; i ++ ){ if ( color [ i ] ==- 1 ){ color [ i ] = num_color ++ ; bfs ( i ); tuopu ( color [ i ]); } } cout << ans << endl ; } 8. \u4f5c\u8005-\u987e\u4f73\u660a \u00b6","title":"Codeforces 505D \u6784\u9020+\u62d3\u6251+bfs"},{"location":"2019/Codeforces/Codeforces%20505D/#1","text":"CodeForces 505D Mr. Kitayuta\u2019s Technology","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/Codeforces%20505D/#2","text":"\u7ed9n\u4e2a\u70b9\uff0c\u7136\u540e\u7ed9\u51fam\u4e2a\u6761\u4ef6a\u3001b\uff0c\u8868\u793aa\u53ef\u5230\u8fbeb\uff0c\u6c42\u6700\u5c11\u9700\u8981\u5efa\u591a\u5c11\u6761\u6709\u5411\u8fb9\u624d\u80fd\u6ee1\u8db3\u6240\u6709\u6761\u4ef6\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/Codeforces%20505D/#3","text":"\u6784\u9020\u3001\u62d3\u6251\u3001bfs","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/Codeforces%20505D/#4","text":"\u9996\u5148\u5bf9\u4e8e\u6bcf\u4e2a\u5355\u72ec\u7684\u8fde\u901a\u5757\uff08\u628a\u8fb9\u90fd\u770b\u6210\u53cc\u5411\u8fb9\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5b83\u62c9\u6210\u4e00\u6761\u94fe\u6216\u4e00\u4e2a\u73af\u3002 \u94fe\u7684\u60c5\u51b5\u5982\u6837\u4f8b\u4e00\uff1a1->2->3->4\u3002\u8fd9\u6837\u524d\u9762\u7684\u70b9\u90fd\u53ef\u4ee5\u5230\u8fbe\u76f8\u5bf9\u4f4d\u7f6e\u540e\u9762\u7684\u70b9\uff0c\u4e14\u603b\u8fb9\u6570\u6700\u5c0f\uff0c\u4e3a\u70b9\u6570-1\u3002\u4f46\u662f\u82e5\u8be5\u8054\u901a\u5757\u4e2d\u5b58\u5728\u73af\uff0c\u5219\u65e0\u6cd5\u62c9\u6210\u4e00\u6839\u94fe\uff0c\u5982\u6837\u4f8b\u4e8c\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u52a0\u4e00\u6761\u94fe\u5c3e\u5230\u94fe\u9996\u7684\u8fb9\u89e3\u51b3\u6240\u6709\u7684\u73af\u7684\u51b2\u7a81\u3002\u5728\u6837\u4f8b\u4e8c\u4e2d\u4e3a1->2->3->4->1\u3002\u8fd9\u6837\u603b\u8fb9\u6570\u6700\u5c0f\uff0c\u4e3a\u70b9\u6570\u3002 \u6240\u4ee5\u5148\u628a\u8fb9\u770b\u6210\u53cc\u5411\u8fb9\uff0c\u5bf9\u6bcf\u4e2a\u8fde\u901a\u5757\u67d3\u8272\uff0c\u7136\u540e\u62d3\u6251\u5224\u65ad\u662f\u5426\u5b58\u5728\u73af\uff0c\u82e5\u5b58\u5728\uff0c\u7b54\u6848+=\u8fde\u901a\u5757\u4e2d\u7684\u70b9\u6570\uff1b\u5426\u5219+= \u8fde\u901a\u5757\u4e2d\u7684\u70b9\u6570-1\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/Codeforces%20505D/#5","text":"\u9700\u8981\u60f3\u5230\u94fe\u548c\u73af\u5206\u522b\u5e94\u8be5\u5982\u4f55\u6784\u9020\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/Codeforces%20505D/#6","text":"http://codeforces.com/contest/505/problem/D","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/Codeforces%20505D/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <bits//stdc++.h> using namespace std ; struct EDGE { int to , next ; } edge [ 500005 ], dedge [ 500005 ]; int head [ 100005 ], dhead [ 100005 ], cnt , dcnt ; void addedge ( int fr , int to , int k ){ if ( ! k ){ edge [ cnt ] = { to , head [ fr ]}; head [ fr ] = cnt ++ ; } else { dedge [ dcnt ] = { to , dhead [ fr ]}; dhead [ fr ] = dcnt ++ ; dedge [ dcnt ] = { fr , dhead [ to ]}; dhead [ to ] = dcnt ++ ; } } int ans , color [ 100005 ], n , m , in [ 100005 ]; void init (){ memset ( color , - 1 , sizeof ( color )); memset ( head , - 1 , sizeof ( head )); memset ( dhead , - 1 , sizeof ( dhead )); cnt = dcnt = 0 ; } queue < int > q2 ; vector < int > pp ; void bfs ( int q ){ while ( q2 . size ()) q2 . pop (); pp . clear (); queue < int > que ; que . push ( q ); while ( que . size ()){ int k = que . front (); que . pop (); pp . push_back ( k ); if ( ! in [ k ]) q2 . push ( k ); for ( int i = dhead [ k ]; i !=- 1 ; i = dedge [ i ]. next ){ int v = dedge [ i ]. to ; if ( color [ v ] !=- 1 ) continue ; color [ v ] = color [ k ]; que . push ( v ); } } } void tuopu ( int q ){ if ( pp . size () <= 1 ) return ; while ( q2 . size ()){ int k = q2 . front (); q2 . pop (); for ( int i = head [ k ]; i !=- 1 ; i = edge [ i ]. next ){ int v = edge [ i ]. to ; in [ v ] -- ; if ( ! in [ v ]) q2 . push ( v ); } } bool key = 0 ; for ( int i = 0 ; i < pp . size (); i ++ ){ if ( in [ pp [ i ]]){ key = 1 ; break ; } } if ( key ) ans += pp . size (); else ans += pp . size () - 1 ; } int main (){ init (); cin >> n >> m ; for ( int i = 0 ; i < m ; i ++ ){ int u , v ; cin >> u >> v ; addedge ( u , v , 0 ); addedge ( u , v , 1 ); in [ v ] ++ ; } int num_color = 0 ; for ( int i = 1 ; i <= n ; i ++ ){ if ( color [ i ] ==- 1 ){ color [ i ] = num_color ++ ; bfs ( i ); tuopu ( color [ i ]); } } cout << ans << endl ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/Codeforces%20505D/#8-","text":"","title":"8. \u4f5c\u8005-\u987e\u4f73\u660a"},{"location":"2019/Codeforces/Codeforces%20600E/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"Codeforces 600E"},{"location":"2019/Codeforces/Codeforces%20600E/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/Codeforces%20600E/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/Codeforces%20600E/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/Codeforces%20600E/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/Codeforces%20600E/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/Codeforces%20600E/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/Codeforces%20600E/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/Codeforces%20600E/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20100548G/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 100548G"},{"location":"2019/Codeforces/GYM%20100548G/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20100548G/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20100548G/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20100548G/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20100548G/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20100548G/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20100548G/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20100548G/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20100837F/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 100837F \u7ade\u8d5b\u6811+\u72b6\u6001\u538b\u7f29DP"},{"location":"2019/Codeforces/GYM%20100837F/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20100837F/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20100837F/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20100837F/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20100837F/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20100837F/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20100837F/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20100837F/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20101161G/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 101161G \u77e9\u9635\u5feb\u901f\u5e42\u4f18\u5316DP"},{"location":"2019/Codeforces/GYM%20101161G/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20101161G/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20101161G/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20101161G/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20101161G/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20101161G/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20101161G/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20101161G/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20101981M/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 GYM 101981M Mediocre String Problem 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u7ed9\u4e00\u4e2a\u4e32s\u548c\u4e32t\uff0c\u6c42s\u7684\u5b50\u4e32s[i] - s[j]\u4e0et\u7684\u524d\u7f00t[1]~t[k]\u80fd\u62fc\u6210\u56de\u6587\u4e32\u7684(i\uff0cj\uff0ck)\u4e09\u5143\u7ec4\u6570\uff0c\u5176\u4e2dj\u2013i+1>k\u3002 $$ 1<=|t|<|s|<=1e6 $$ 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u672c\u9898\u6d89\u53ca exkmp\u548cmanacher \u7b97\u6cd5\u7684\u5e94\u7528\u3002 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 s[i]-s[j]\u4e0et[1]-t[k]\u80fd\u62fc\u6210\u56de\u6587\u4e32\uff0c\u663e\u7136\u8981\u6ee1\u8db3\uff1a s[i+k-1]-s[i]\uff08\u6ce8\u610f\u987a\u5e8f\uff09\u4e0et[1]-t[k]\u5bf9\u5e94\u76f8\u7b49\uff1b s[i+k]-s[j]\u662f\u56de\u6587\u4e32\u3002 \u6211\u4eec\u5c06s\u4e32\u7ffb\u8f6c\uff0c\u5b50\u95ee\u98981\u5373\u6c42s\u7684\u6bcf\u4e2a\u540e\u7f00\u4e0et\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\uff0c\u53ef\u7528exkmp\u89e3\u51b3\u3002 \u8bbe\u7ffb\u8f6c\u540es\u7684\u540e\u7f00s[i]~s[n]\u4e0et\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u4e3aextend[i] \u63a5\u4e0b\u6765\u53ea\u9700\u6c42\u51fa\u4ee5s[i-1]\u4e3a\u7ed3\u5c3e\u7684\u56de\u6587\u4e32\u6570c[i-1]\uff0c\u7b54\u6848\u5373\u4e3a \u2211extend[i]*c[i-1] \u2211extend[i]*c[i-1] \u3002 \u7528manacher\u8dd1\u51fa\u6bcf\u4e2a\u4e2d\u5fc3i\u7684\u6700\u957f\u56de\u6587\u534a\u5f84r[i]\uff0c\u5dee\u5206\u540e\uff08c[i]++\uff0cc[i+r[i]]--\uff09\u505a\u524d\u7f00\u548c\u5373\u4e3a\u6240\u6c42c[i]\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(|s|+|t|) O(|s|+|t|) \u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u7ffb\u8f6c\u4f1a\u4f7f\u201c\u4ee5\u67d0\u4e00\u4f4d\u5f00\u59cb\u5411\u524d\u5f62\u6210\u7684\u5b50\u4e32\u201d\u8f6c\u5316\u4e3a\u201c\u4ee5\u67d0\u4e00\u4f4d\u5f00\u59cb\u7684\u540e\u7f00\u201d\u4ee5\u7b80\u5316\u67d0\u4e9b\u5b57\u7b26\u4e32\u95ee\u9898\uff1b \u5728\u5bf9\u6700\u957f\u56de\u6587\u534a\u5f84r[i]\u505a\u5dee\u5206\u65f6\uff0c\u6ce8\u610f\u8981\u5bf9\u5947\u5076\u56de\u6587\u4e2d\u5fc3\u5206\u522b\u8ba8\u8bba\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 https://blog.csdn.net/dyx404514/article/details/41831947 https://www.cnblogs.com/love-yh/p/7072161.html 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MAXN = 1000010 ; int n , m , c [ MAXN ]; int nxt [ MAXN ], extend [ MAXN ]; char s [ MAXN ], t [ MAXN ]; char Ma [ MAXN << 1 ]; int Mp [ MAXN << 1 ]; void pre_EKMP ( char x [], int m , int nxt []){ nxt [ 0 ] = m ; int j = 0 ; while ( j + 1 < m && x [ j ] == x [ j + 1 ]) j ++ ; nxt [ 1 ] = j ; int k = 1 ; for ( int i = 2 ; i < m ; i ++ ){ int p = nxt [ k ] + k - 1 ; int L = nxt [ i - k ]; if ( i + L < p + 1 ) nxt [ i ] = L ; else { j = max ( 0 , p - i + 1 ); while ( i + j < m && x [ i + j ] == x [ j ]) j ++ ; nxt [ i ] = j ; k = i ; } } } void EKMP ( char x [], int m , char y [], int n , int nxt [], int extend []){ pre_EKMP ( x , m , nxt ); int j = 0 ; while ( j < n && j < m && x [ j ] == y [ j ]) j ++ ; extend [ 0 ] = j ; int k = 0 ; for ( int i = 1 ; i < n ; i ++ ){ int p = extend [ k ] + k - 1 ; int L = nxt [ i - k ]; if ( i + L < p + 1 ) extend [ i ] = L ; else { j = max ( 0 , p - i + 1 ); while ( i + j < n && j < m && y [ i + j ] == x [ j ]) j ++ ; extend [ i ] = j ; k = i ; } } } void Manacher ( char s [], int len ){ int l = 0 ; Ma [ l ++ ] = '$' ; Ma [ l ++ ] = '#' ; for ( int i = 0 ; i < len ; i ++ ){ Ma [ l ++ ] = s [ i ]; Ma [ l ++ ] = '#' ; } Ma [ l ] = 0 ; int mx = 0 , id = 0 ; for ( int i = 0 ; i < l ; i ++ ){ Mp [ i ] = mx > i ? min ( Mp [ 2 * id - i ], mx - i ) : 1 ; while ( Ma [ i + Mp [ i ]] == Ma [ i - Mp [ i ]]) Mp [ i ] ++ ; if ( i + Mp [ i ] > mx ){ mx = i + Mp [ i ]; id = i ; } } } int main (){ scanf ( \"%s\" , s ); n = strlen ( s ); reverse ( s , s + n ); scanf ( \"%s\" , t ); m = strlen ( t ); EKMP ( t , m , s , n , nxt , extend ); Manacher ( s , n ); for ( int i = 2 ; i < 2 * n + 2 ; i ++ ){ int r = Mp [ i ] / 2 ; if ( i & 1 ){ c [ i / 2 + 1 ] ++ ; c [ i / 2 + r + 1 ] -- ; } else { c [ i / 2 ] ++ ; c [ i / 2 + r ] -- ; } } for ( int i = 1 ; i <= n ; i ++ ) c [ i ] += c [ i - 1 ]; ll ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += 1LL * extend [ i ] * c [ i ]; cout << ans ; return 0 ; } 8. \u4f5c\u8005-\u9648\u946b \u00b6","title":"GYM 101981M exkmp+manacher"},{"location":"2019/Codeforces/GYM%20101981M/#1","text":"GYM 101981M Mediocre String Problem","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20101981M/#2","text":"\u7ed9\u4e00\u4e2a\u4e32s\u548c\u4e32t\uff0c\u6c42s\u7684\u5b50\u4e32s[i] - s[j]\u4e0et\u7684\u524d\u7f00t[1]~t[k]\u80fd\u62fc\u6210\u56de\u6587\u4e32\u7684(i\uff0cj\uff0ck)\u4e09\u5143\u7ec4\u6570\uff0c\u5176\u4e2dj\u2013i+1>k\u3002 $$ 1<=|t|<|s|<=1e6 $$","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20101981M/#3","text":"\u672c\u9898\u6d89\u53ca exkmp\u548cmanacher \u7b97\u6cd5\u7684\u5e94\u7528\u3002","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20101981M/#4","text":"s[i]-s[j]\u4e0et[1]-t[k]\u80fd\u62fc\u6210\u56de\u6587\u4e32\uff0c\u663e\u7136\u8981\u6ee1\u8db3\uff1a s[i+k-1]-s[i]\uff08\u6ce8\u610f\u987a\u5e8f\uff09\u4e0et[1]-t[k]\u5bf9\u5e94\u76f8\u7b49\uff1b s[i+k]-s[j]\u662f\u56de\u6587\u4e32\u3002 \u6211\u4eec\u5c06s\u4e32\u7ffb\u8f6c\uff0c\u5b50\u95ee\u98981\u5373\u6c42s\u7684\u6bcf\u4e2a\u540e\u7f00\u4e0et\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\uff0c\u53ef\u7528exkmp\u89e3\u51b3\u3002 \u8bbe\u7ffb\u8f6c\u540es\u7684\u540e\u7f00s[i]~s[n]\u4e0et\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u4e3aextend[i] \u63a5\u4e0b\u6765\u53ea\u9700\u6c42\u51fa\u4ee5s[i-1]\u4e3a\u7ed3\u5c3e\u7684\u56de\u6587\u4e32\u6570c[i-1]\uff0c\u7b54\u6848\u5373\u4e3a \u2211extend[i]*c[i-1] \u2211extend[i]*c[i-1] \u3002 \u7528manacher\u8dd1\u51fa\u6bcf\u4e2a\u4e2d\u5fc3i\u7684\u6700\u957f\u56de\u6587\u534a\u5f84r[i]\uff0c\u5dee\u5206\u540e\uff08c[i]++\uff0cc[i+r[i]]--\uff09\u505a\u524d\u7f00\u548c\u5373\u4e3a\u6240\u6c42c[i]\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(|s|+|t|) O(|s|+|t|) \u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20101981M/#5","text":"\u7ffb\u8f6c\u4f1a\u4f7f\u201c\u4ee5\u67d0\u4e00\u4f4d\u5f00\u59cb\u5411\u524d\u5f62\u6210\u7684\u5b50\u4e32\u201d\u8f6c\u5316\u4e3a\u201c\u4ee5\u67d0\u4e00\u4f4d\u5f00\u59cb\u7684\u540e\u7f00\u201d\u4ee5\u7b80\u5316\u67d0\u4e9b\u5b57\u7b26\u4e32\u95ee\u9898\uff1b \u5728\u5bf9\u6700\u957f\u56de\u6587\u534a\u5f84r[i]\u505a\u5dee\u5206\u65f6\uff0c\u6ce8\u610f\u8981\u5bf9\u5947\u5076\u56de\u6587\u4e2d\u5fc3\u5206\u522b\u8ba8\u8bba\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20101981M/#6","text":"https://blog.csdn.net/dyx404514/article/details/41831947 https://www.cnblogs.com/love-yh/p/7072161.html","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20101981M/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MAXN = 1000010 ; int n , m , c [ MAXN ]; int nxt [ MAXN ], extend [ MAXN ]; char s [ MAXN ], t [ MAXN ]; char Ma [ MAXN << 1 ]; int Mp [ MAXN << 1 ]; void pre_EKMP ( char x [], int m , int nxt []){ nxt [ 0 ] = m ; int j = 0 ; while ( j + 1 < m && x [ j ] == x [ j + 1 ]) j ++ ; nxt [ 1 ] = j ; int k = 1 ; for ( int i = 2 ; i < m ; i ++ ){ int p = nxt [ k ] + k - 1 ; int L = nxt [ i - k ]; if ( i + L < p + 1 ) nxt [ i ] = L ; else { j = max ( 0 , p - i + 1 ); while ( i + j < m && x [ i + j ] == x [ j ]) j ++ ; nxt [ i ] = j ; k = i ; } } } void EKMP ( char x [], int m , char y [], int n , int nxt [], int extend []){ pre_EKMP ( x , m , nxt ); int j = 0 ; while ( j < n && j < m && x [ j ] == y [ j ]) j ++ ; extend [ 0 ] = j ; int k = 0 ; for ( int i = 1 ; i < n ; i ++ ){ int p = extend [ k ] + k - 1 ; int L = nxt [ i - k ]; if ( i + L < p + 1 ) extend [ i ] = L ; else { j = max ( 0 , p - i + 1 ); while ( i + j < n && j < m && y [ i + j ] == x [ j ]) j ++ ; extend [ i ] = j ; k = i ; } } } void Manacher ( char s [], int len ){ int l = 0 ; Ma [ l ++ ] = '$' ; Ma [ l ++ ] = '#' ; for ( int i = 0 ; i < len ; i ++ ){ Ma [ l ++ ] = s [ i ]; Ma [ l ++ ] = '#' ; } Ma [ l ] = 0 ; int mx = 0 , id = 0 ; for ( int i = 0 ; i < l ; i ++ ){ Mp [ i ] = mx > i ? min ( Mp [ 2 * id - i ], mx - i ) : 1 ; while ( Ma [ i + Mp [ i ]] == Ma [ i - Mp [ i ]]) Mp [ i ] ++ ; if ( i + Mp [ i ] > mx ){ mx = i + Mp [ i ]; id = i ; } } } int main (){ scanf ( \"%s\" , s ); n = strlen ( s ); reverse ( s , s + n ); scanf ( \"%s\" , t ); m = strlen ( t ); EKMP ( t , m , s , n , nxt , extend ); Manacher ( s , n ); for ( int i = 2 ; i < 2 * n + 2 ; i ++ ){ int r = Mp [ i ] / 2 ; if ( i & 1 ){ c [ i / 2 + 1 ] ++ ; c [ i / 2 + r + 1 ] -- ; } else { c [ i / 2 ] ++ ; c [ i / 2 + r ] -- ; } } for ( int i = 1 ; i <= n ; i ++ ) c [ i ] += c [ i - 1 ]; ll ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += 1LL * extend [ i ] * c [ i ]; cout << ans ; return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20101981M/#8-","text":"","title":"8. \u4f5c\u8005-\u9648\u946b"},{"location":"2019/Codeforces/GYM%20101987L/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 101987L"},{"location":"2019/Codeforces/GYM%20101987L/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20101987L/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20101987L/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20101987L/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20101987L/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20101987L/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20101987L/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20101987L/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102012H/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 GYM 102012H Rikka with A Long Colour Palette 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u6709n\u6761\u7ebf\u6bb5[l,r]\uff0ck\u79cd\u989c\u8272\uff0c\u4e3a\u6bcf\u6761\u7ebf\u6bb5\u67d3\u4e00\u79cd\u989c\u8272\uff0c\u95ee\u80fd\u88abk\u79cd\u989c\u8272\u8986\u76d6\u7684\u533a\u95f4\u7684\u6700\u5927\u603b\u957f\uff0c\u5e76\u8f93\u51fa\u4e00\u79cd\u67d3\u8272\u65b9\u6848\u3002 $$ \u2211n<=2e6\uff0c1<=k<=2e5\uff0c0<=l<r<= 1e9 $$ 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u672c\u9898\u6d89\u53ca \u8d2a\u5fc3\u548c\u626b\u63cf\u7ebf \u7684\u601d\u60f3 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u628an\u6761\u7ebf\u6bb5\u76842*n\u4e2a\u7aef\u70b9\u6309\u4f4d\u7f6e\u6392\u5e8f\uff0c\u76f8\u540c\u4f4d\u7f6e\u53f3\u7aef\u70b9\u66f4\u9760\u524d\uff0c\u628ak\u79cd\u989c\u8272\u52a0\u5165\u672a\u67d3\u8272\u961f\u5217rCol\u91cc\u3002 \u4ece\u524d\u5230\u540e\u626b\u63cf\u6bcf\u4e2a\u7aef\u70b9\uff1a \u82e5rCol\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u7aef\u70b9\u5230\u4e0a\u4e2a\u7aef\u70b9\u4e4b\u95f4\u7684\u533a\u95f4\u5df2\u8986\u76d6k\u79cd\u989c\u8272\uff0c\u7d2f\u52a0\u7b54\u6848\uff1b \u5982\u679c\u8be5\u7aef\u70b9\u662f\u5de6\u7aef\u70b9\uff0c\u4e14rCol\u4e0d\u7a7a\uff0c\u5219\u53d6\u961f\u5934\u4e3a\u8be5\u7ebf\u6bb5\u7acb\u5373\u67d3\u8272\uff0c\u82e5rCol\u4e3a\u7a7a\uff0c\u968f\u4fbf\u67d3\u8272\u4f1a\u6709\u540e\u6548\u6027\uff0c\u4e0d\u59a8\u5c06\u8be5\u7ebf\u6bb5\u6254\u8fdb\u5ef6\u8fdf\u67d3\u8272\u961f\u5217rSeg\u4e2d\uff1b \u5982\u679c\u8be5\u7aef\u70b9\u662f\u53f3\u7aef\u70b9\uff0c\u4e14\u5df2\u88ab\u67d3\u8272\uff0c\u5219\u5c06\u8be5\u989c\u8272\u5f52\u8fd8\u5230rCol\u4e2d\uff0c\u82e5\u672a\u88ab\u67d3\u8272\uff0c\u5219\u8bf4\u660e\u8be5\u7ebf\u6bb5\u65e2\u6ca1\u6709\u5728\u5de6\u7aef\u70b9\u7acb\u5373\u67d3\u8272\uff0c\u53c8\u6ca1\u6709\u5728\u53f3\u7aef\u70b9\u524d\u5ef6\u8fdf\u67d3\u8272\uff0c\u4e0d\u4f1a\u518d\u6709\u8d21\u732e\uff0c\u968f\u4fbf\u67d3\u8272\u5373\u53ef\u3002 \u5904\u7406\u5b8c\u8be5\u7aef\u70b9\u540e\uff0c\u82e5rCol\u4e0d\u7a7a\uff0c\u5219\u4ecerSeg\u4e2d\u53d6\u51fa\u5ef6\u8fdf\u67d3\u8272\u7684\u7ebf\u6bb5\u4e00\u4e00\u4e3a\u5176\u5206\u914d\u989c\u8272\uff0c\u76f4\u5230\u4e24\u8005\u5176\u4e2d\u4e00\u4e2a\u4e3a\u7a7a\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u6392\u5e8f O(nlogn) O(nlogn) +\u626b\u63cf\u4f4d\u7f6e O(n) O(n) +\u5ef6\u8fdf\u67d3\u8272 O(n) O(n) \u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u6392\u5e8f\u65f6\u76f8\u540c\u4f4d\u7f6e\u53f3\u7aef\u70b9\u66f4\u9760\u524d\uff0c\u662f\u56e0\u4e3a\u53f3\u7aef\u70b9\u5f52\u8272\u8981\u5148\u4e8e\u5de6\u7aef\u70b9\u67d3\u8272\uff1b \u5df2\u7ecf\u626b\u63cf\u5b8c\u53f3\u7aef\u70b9\u7684\u7ebf\u6bb5\uff0c\u82e5\u5176\u51fa\u73b0\u5728rSeg\u4e2d\uff0c\u8981\u53ca\u65f6\u5254\u9664\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 https://acm.ecnu.edu.cn/wiki/index.php?title=2018_ACM-ICPC_Xuzhou_Regional_Onsite 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <bits/stdc++.h> #define sz(x) ((int)x.size()) #define mp(x, y) make_pair(x, y) using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const int MAXN = 400010 ; int T , n , k , col [ MAXN ]; struct Node { int st , id ; Node (){} Node ( int _st , int _id ){ st = _st ; id = _id ; } bool operator < ( const Node & nd ) const { if ( st == nd . st ) return id < nd . id ; return st < nd . st ; } } seg [ MAXN ]; queue < int > rCol , rSeg ; int main (){ scanf ( \"%d\" , & T ); while ( T -- ){ scanf ( \"%d%d\" , & n , & k ); while ( sz ( rCol )) rCol . pop (); while ( sz ( rSeg )) rSeg . pop (); for ( int i = 1 ; i <= n ; i ++ ){ int l , r ; scanf ( \"%d%d\" , & l , & r ); col [ i ] = 0 ; seg [ i ] = Node ( l , i ); seg [ i + n ] = Node ( r , - i ); } if ( n < k ){ printf ( \"0 \\n 1\" ); for ( int i = 2 ; i <= n ; i ++ ) printf ( \" 1\" ); printf ( \" \\n \" ); continue ; } sort ( seg + 1 , seg + 2 * n + 1 ); for ( int i = 1 ; i <= k ; i ++ ) rCol . push ( i ); ll ans = 0 ; for ( int i = 1 ; i <= 2 * n ; i ++ ){ if ( sz ( rCol ) == 0 ) ans += seg [ i ]. st - seg [ i - 1 ]. st ; if ( seg [ i ]. id > 0 ){ if ( sz ( rCol )){ int tc = rCol . front (); col [ seg [ i ]. id ] = tc ; rCol . pop (); } else rSeg . push ( seg [ i ]. id ); } else { if ( col [ - seg [ i ]. id ]) rCol . push ( col [ - seg [ i ]. id ]); else col [ - seg [ i ]. id ] = 1 ; } while ( sz ( rCol ) && sz ( rSeg )){ int tc = rCol . front (); int ts = rSeg . front (); rSeg . pop (); if ( col [ ts ]) continue ; col [ ts ] = tc ; rCol . pop (); } } printf ( \"%I64d \\n \" , ans ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d%c\" , col [ i ], i == n ? '\\n' : ' ' ); } return 0 ; } 8. \u4f5c\u8005-\u9648\u946b \u00b6","title":"GYM 102012H \u8d2a\u5fc3+\u626b\u63cf\u7ebf"},{"location":"2019/Codeforces/GYM%20102012H/#1","text":"GYM 102012H Rikka with A Long Colour Palette","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102012H/#2","text":"\u6709n\u6761\u7ebf\u6bb5[l,r]\uff0ck\u79cd\u989c\u8272\uff0c\u4e3a\u6bcf\u6761\u7ebf\u6bb5\u67d3\u4e00\u79cd\u989c\u8272\uff0c\u95ee\u80fd\u88abk\u79cd\u989c\u8272\u8986\u76d6\u7684\u533a\u95f4\u7684\u6700\u5927\u603b\u957f\uff0c\u5e76\u8f93\u51fa\u4e00\u79cd\u67d3\u8272\u65b9\u6848\u3002 $$ \u2211n<=2e6\uff0c1<=k<=2e5\uff0c0<=l<r<= 1e9 $$","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102012H/#3","text":"\u672c\u9898\u6d89\u53ca \u8d2a\u5fc3\u548c\u626b\u63cf\u7ebf \u7684\u601d\u60f3","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102012H/#4","text":"\u628an\u6761\u7ebf\u6bb5\u76842*n\u4e2a\u7aef\u70b9\u6309\u4f4d\u7f6e\u6392\u5e8f\uff0c\u76f8\u540c\u4f4d\u7f6e\u53f3\u7aef\u70b9\u66f4\u9760\u524d\uff0c\u628ak\u79cd\u989c\u8272\u52a0\u5165\u672a\u67d3\u8272\u961f\u5217rCol\u91cc\u3002 \u4ece\u524d\u5230\u540e\u626b\u63cf\u6bcf\u4e2a\u7aef\u70b9\uff1a \u82e5rCol\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u7aef\u70b9\u5230\u4e0a\u4e2a\u7aef\u70b9\u4e4b\u95f4\u7684\u533a\u95f4\u5df2\u8986\u76d6k\u79cd\u989c\u8272\uff0c\u7d2f\u52a0\u7b54\u6848\uff1b \u5982\u679c\u8be5\u7aef\u70b9\u662f\u5de6\u7aef\u70b9\uff0c\u4e14rCol\u4e0d\u7a7a\uff0c\u5219\u53d6\u961f\u5934\u4e3a\u8be5\u7ebf\u6bb5\u7acb\u5373\u67d3\u8272\uff0c\u82e5rCol\u4e3a\u7a7a\uff0c\u968f\u4fbf\u67d3\u8272\u4f1a\u6709\u540e\u6548\u6027\uff0c\u4e0d\u59a8\u5c06\u8be5\u7ebf\u6bb5\u6254\u8fdb\u5ef6\u8fdf\u67d3\u8272\u961f\u5217rSeg\u4e2d\uff1b \u5982\u679c\u8be5\u7aef\u70b9\u662f\u53f3\u7aef\u70b9\uff0c\u4e14\u5df2\u88ab\u67d3\u8272\uff0c\u5219\u5c06\u8be5\u989c\u8272\u5f52\u8fd8\u5230rCol\u4e2d\uff0c\u82e5\u672a\u88ab\u67d3\u8272\uff0c\u5219\u8bf4\u660e\u8be5\u7ebf\u6bb5\u65e2\u6ca1\u6709\u5728\u5de6\u7aef\u70b9\u7acb\u5373\u67d3\u8272\uff0c\u53c8\u6ca1\u6709\u5728\u53f3\u7aef\u70b9\u524d\u5ef6\u8fdf\u67d3\u8272\uff0c\u4e0d\u4f1a\u518d\u6709\u8d21\u732e\uff0c\u968f\u4fbf\u67d3\u8272\u5373\u53ef\u3002 \u5904\u7406\u5b8c\u8be5\u7aef\u70b9\u540e\uff0c\u82e5rCol\u4e0d\u7a7a\uff0c\u5219\u4ecerSeg\u4e2d\u53d6\u51fa\u5ef6\u8fdf\u67d3\u8272\u7684\u7ebf\u6bb5\u4e00\u4e00\u4e3a\u5176\u5206\u914d\u989c\u8272\uff0c\u76f4\u5230\u4e24\u8005\u5176\u4e2d\u4e00\u4e2a\u4e3a\u7a7a\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u6392\u5e8f O(nlogn) O(nlogn) +\u626b\u63cf\u4f4d\u7f6e O(n) O(n) +\u5ef6\u8fdf\u67d3\u8272 O(n) O(n) \u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102012H/#5","text":"\u6392\u5e8f\u65f6\u76f8\u540c\u4f4d\u7f6e\u53f3\u7aef\u70b9\u66f4\u9760\u524d\uff0c\u662f\u56e0\u4e3a\u53f3\u7aef\u70b9\u5f52\u8272\u8981\u5148\u4e8e\u5de6\u7aef\u70b9\u67d3\u8272\uff1b \u5df2\u7ecf\u626b\u63cf\u5b8c\u53f3\u7aef\u70b9\u7684\u7ebf\u6bb5\uff0c\u82e5\u5176\u51fa\u73b0\u5728rSeg\u4e2d\uff0c\u8981\u53ca\u65f6\u5254\u9664\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102012H/#6","text":"https://acm.ecnu.edu.cn/wiki/index.php?title=2018_ACM-ICPC_Xuzhou_Regional_Onsite","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102012H/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <bits/stdc++.h> #define sz(x) ((int)x.size()) #define mp(x, y) make_pair(x, y) using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const int MAXN = 400010 ; int T , n , k , col [ MAXN ]; struct Node { int st , id ; Node (){} Node ( int _st , int _id ){ st = _st ; id = _id ; } bool operator < ( const Node & nd ) const { if ( st == nd . st ) return id < nd . id ; return st < nd . st ; } } seg [ MAXN ]; queue < int > rCol , rSeg ; int main (){ scanf ( \"%d\" , & T ); while ( T -- ){ scanf ( \"%d%d\" , & n , & k ); while ( sz ( rCol )) rCol . pop (); while ( sz ( rSeg )) rSeg . pop (); for ( int i = 1 ; i <= n ; i ++ ){ int l , r ; scanf ( \"%d%d\" , & l , & r ); col [ i ] = 0 ; seg [ i ] = Node ( l , i ); seg [ i + n ] = Node ( r , - i ); } if ( n < k ){ printf ( \"0 \\n 1\" ); for ( int i = 2 ; i <= n ; i ++ ) printf ( \" 1\" ); printf ( \" \\n \" ); continue ; } sort ( seg + 1 , seg + 2 * n + 1 ); for ( int i = 1 ; i <= k ; i ++ ) rCol . push ( i ); ll ans = 0 ; for ( int i = 1 ; i <= 2 * n ; i ++ ){ if ( sz ( rCol ) == 0 ) ans += seg [ i ]. st - seg [ i - 1 ]. st ; if ( seg [ i ]. id > 0 ){ if ( sz ( rCol )){ int tc = rCol . front (); col [ seg [ i ]. id ] = tc ; rCol . pop (); } else rSeg . push ( seg [ i ]. id ); } else { if ( col [ - seg [ i ]. id ]) rCol . push ( col [ - seg [ i ]. id ]); else col [ - seg [ i ]. id ] = 1 ; } while ( sz ( rCol ) && sz ( rSeg )){ int tc = rCol . front (); int ts = rSeg . front (); rSeg . pop (); if ( col [ ts ]) continue ; col [ ts ] = tc ; rCol . pop (); } } printf ( \"%I64d \\n \" , ans ); for ( int i = 1 ; i <= n ; i ++ ) printf ( \"%d%c\" , col [ i ], i == n ? '\\n' : ' ' ); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102012H/#8-","text":"","title":"8. \u4f5c\u8005-\u9648\u946b"},{"location":"2019/Codeforces/GYM%20102056C/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102056C"},{"location":"2019/Codeforces/GYM%20102056C/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102056C/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102056C/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102056C/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102056C/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102056C/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102056C/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102056C/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102056F/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102056F"},{"location":"2019/Codeforces/GYM%20102056F/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102056F/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102056F/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102056F/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102056F/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102056F/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102056F/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102056F/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102056G/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102056G"},{"location":"2019/Codeforces/GYM%20102056G/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102056G/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102056G/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102056G/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102056G/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102056G/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102056G/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102056G/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102056I/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102056I"},{"location":"2019/Codeforces/GYM%20102056I/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102056I/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102056I/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102056I/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102056I/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102056I/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102056I/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102056I/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102056L/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102056L"},{"location":"2019/Codeforces/GYM%20102056L/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102056L/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102056L/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102056L/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102056L/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102056L/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102056L/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102056L/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102220D/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102220D"},{"location":"2019/Codeforces/GYM%20102220D/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102220D/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102220D/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102220D/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102220D/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102220D/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102220D/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102220D/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/Codeforces/GYM%20102220E/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"GYM 102220E"},{"location":"2019/Codeforces/GYM%20102220E/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/Codeforces/GYM%20102220E/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/Codeforces/GYM%20102220E/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/Codeforces/GYM%20102220E/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/Codeforces/GYM%20102220E/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/Codeforces/GYM%20102220E/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/Codeforces/GYM%20102220E/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/Codeforces/GYM%20102220E/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%204465/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 HDU 4465 Candy 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u6709\u4e24\u4e2a\u76d2\u5b50\uff0c\u4e00\u5f00\u59cb\u6bcf\u4e2a\u91cc\u9762\u90fd\u6709n\u4e2a\u7cd6\u679c\u3002\u6bcf\u5929\u9009\u62e9\u4e00\u4e2a\u76d2\u5b50\u3002\u9009\u7b2c\u4e00\u4e2a\u76d2\u5b50\u7684\u6982\u7387\u4e3ap,\u9009\u7b2c\u4e8c\u4e2a\u7684\u6982\u7387\u4e3a\uff081-p\uff09\u3002\u5bf9\u4e8e\u6240\u9009\u62e9\u7684\u76d2\u5b50\uff0c\u5982\u679c\u8fd8\u6709\u7cd6\u679c\uff0c\u4ed6\u4f1a\u5403\u5176\u4e2d\u4e00\u4e2a\u3002 \u6709\u4e00\u5929\uff0c\u5f53\u6253\u5f00\u4e00\u4e2a\u76d2\u5b50\u65f6\uff0c\u4ed6\u53d1\u73b0\u6ca1\u6709\u7cd6\u679c\u4e86\u3002\u95ee\u53e6\u4e00\u4e2a\u76d2\u5b50\u91cc\u5269\u4e0b\u7684\u9884\u671f\u7cd6\u679c\u6570\u91cf\u3002\u7b54\u6848\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e\u56db\u4f4d\u3002 $$ 1\u2264n\u22642e5, 0\u2264p\u22641\uff0c\u5c0f\u6570\u70b9\u540e6\u4f4d $$ 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u6982\u7387\u7684\u8ba1\u7b97\u65b9\u6cd5\u4ee5\u53ca\u7cbe\u5ea6\u63a7\u5236\u65b9\u6cd5 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u9996\u5148\u5f88\u81ea\u7136\u5c31\u80fd\u5f97\u51fa\u6982\u7387dp\u7684\u505a\u6cd5\u3002\u8bbedp[i][j]\u4e3a\u7b2c\u4e00\u4e2a\u76d2\u5b50\u4e2d\u5269\u4f59\u7cd6\u679c\u6570\u4e3ai\uff0c\u7b2c\u4e8c\u4e2a\u76d2\u5b50\u4e2d\u5269\u4f59\u7cd6\u679c\u6570\u4e3aj\u7684\u6982\u7387\uff0c\u8f6c\u79fb\u65b9\u7a0b dp[i-1][j]+=dp[i][j]*p,dp[i][j-1]+=dp[i][j]*(1-p) dp[i-1][j]+=dp[i][j]*p,dp[i][j-1]+=dp[i][j]*(1-p) \u521d\u59cb\u72b6\u6001 dp[n][n]=1 \uff0c\u76ee\u6807\u4e3a \\sum_{i=1}^{n} i * d p[0][i]+\\sum_{i=1}^{n} i * d p[i][0] \\sum_{i=1}^{n} i * d p[0][i]+\\sum_{i=1}^{n} i * d p[i][0] \uff0c\u53ef\u662f\u8fd9\u9053\u9898\u7684\u8303\u56f4\u662f2e5\uff0c\u65f6\u95f4\u548c\u7a7a\u95f4\u90fd\u4e0d\u591f\uff0c\u5bfb\u6c42\u516c\u5f0f\u505a\u6cd5\u3002 \u4ee4\u7b2c\u4e00\u4e2a\u76d2\u5b50\u53d6\u5149\u65f6\u7b2c\u4e8c\u4e2a\u76d2\u5b50\u7684\u7cd6\u679c\u7684\u671f\u671b\u4e3asolve(p), solve(p) = \\sum{(n-i)*C(n+i,n)*(p^{n+1}(1-p)^i)} solve(p) = \\sum{(n-i)*C(n+i,n)*(p^{n+1}(1-p)^i)} \u6ce8\u610f\u4ed6\u6253\u5f00\u76d2\u5b50\u65f6\u53d1\u73b0\u6ca1\u4e86\uff0c\u6240\u4ee5\u662fp\u7684(n+1)\u6b21\u65b9 \u7b2c\u4e8c\u4e2a\u76d2\u5b50\u53d6\u5149\u65f6\u7b2c\u4e00\u4e2a\u76d2\u5b50\u7684\u7cd6\u679c\u7684\u671f\u671b\u4e3asolve(1-p), $$ ans=solve(p)+solve(1-p) $$ \u5f53p=0\u6216p=1\u65f6\u9700\u8981\u7279\u5224\uff0c\u7b54\u6848\u4e3an\u3002 \u7136\u800c\u8fd9\u6837\u505a\u867d\u7136\u590d\u6742\u5ea6\u80fd\u901a\u8fc7\uff0c\u4f46\u662f\u4f1aWA\u3002\u539f\u56e0\u662f\u9898\u4e2d\u7684\u7cbe\u5ea6\u8981\u6c42\u5f88\u9ad8\uff0c\u5c0f\u6570\u7684\u9ad8\u6b21\u65b9\u4e22\u5931\u7cbe\u5ea6\u592a\u4e25\u91cd\u4e86\u3002\u9700\u8981\u53d6\u5bf9\u6570\u8fdb\u884c\u8ba1\u7b97\u3002 solve(p)=\\sum (n-i)*e^{\\log (C(n+i,n)*(p^{n+1})*((1-p)^i))} solve(p)=\\sum (n-i)*e^{\\log (C(n+i,n)*(p^{n+1})*((1-p)^i))} = \\sum(n-i)exp(log(C(n+i,n))+(n+1)*log(p)+i*log(1-p)) = \\sum(n-i)exp(log(C(n+i,n))+(n+1)*log(p)+i*log(1-p)) 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u6982\u7387\u7684\u8ba1\u7b97\u516c\u5f0f\u5bb9\u6613\u60f3\u5230\uff0c\u4e3b\u8981\u96be\u70b9\u662f\u5982\u4f55\u51cf\u5c11\u7cbe\u5ea6\u635f\u5931\u3002\u53d6\u5bf9\u6570\u8fdb\u884c\u8ba1\u7b97\u662f\u4e00\u79cd\u4e0d\u9519\u7684\u65b9\u6cd5\uff0c\u4ee5\u540e\u9047\u5230\u7c7b\u4f3c\u7684\u95ee\u9898\u65f6\u53ef\u4ee5\u501f\u9274\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://acm.hdu.edu.cn/showproblem.php?pid=4465 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <bits/stdc++.h> using namespace std ; #define LB long double LB f [ 400005 ]; int n ; void init (){ f [ 1 ] = 0 ; for ( int i = 2 ; i < 400005 ; i ++ ) f [ i ] = f [ i - 1 ] + log ( i ); } double solve ( LB p ){ double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ){ sum += ( n - i ) * exp (( n + 1 ) * log ( p ) + i * log ( 1 - p ) + ( f [ n + i ] - f [ n ] - f [ i ])); } return sum ; } int main (){ init (); LB p ; int _ = 1 ; while ( cin >> n >> p ){ double ans ; if ( p == 0 || p == 1 ) ans = n ; else ans = solve ( p ) + solve ( 1 - p ); printf ( \"Case %d: %.6lf \\n \" , _ ++ , ans ); } } 8. \u4f5c\u8005-\u987e\u4f73\u660a \u00b6","title":"HDU 4465 \u671f\u671b+\u7cbe\u5ea6\u63a7\u5236"},{"location":"2019/HDU/HDU%204465/#1","text":"HDU 4465 Candy","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%204465/#2","text":"\u6709\u4e24\u4e2a\u76d2\u5b50\uff0c\u4e00\u5f00\u59cb\u6bcf\u4e2a\u91cc\u9762\u90fd\u6709n\u4e2a\u7cd6\u679c\u3002\u6bcf\u5929\u9009\u62e9\u4e00\u4e2a\u76d2\u5b50\u3002\u9009\u7b2c\u4e00\u4e2a\u76d2\u5b50\u7684\u6982\u7387\u4e3ap,\u9009\u7b2c\u4e8c\u4e2a\u7684\u6982\u7387\u4e3a\uff081-p\uff09\u3002\u5bf9\u4e8e\u6240\u9009\u62e9\u7684\u76d2\u5b50\uff0c\u5982\u679c\u8fd8\u6709\u7cd6\u679c\uff0c\u4ed6\u4f1a\u5403\u5176\u4e2d\u4e00\u4e2a\u3002 \u6709\u4e00\u5929\uff0c\u5f53\u6253\u5f00\u4e00\u4e2a\u76d2\u5b50\u65f6\uff0c\u4ed6\u53d1\u73b0\u6ca1\u6709\u7cd6\u679c\u4e86\u3002\u95ee\u53e6\u4e00\u4e2a\u76d2\u5b50\u91cc\u5269\u4e0b\u7684\u9884\u671f\u7cd6\u679c\u6570\u91cf\u3002\u7b54\u6848\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e\u56db\u4f4d\u3002 $$ 1\u2264n\u22642e5, 0\u2264p\u22641\uff0c\u5c0f\u6570\u70b9\u540e6\u4f4d $$","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%204465/#3","text":"\u6982\u7387\u7684\u8ba1\u7b97\u65b9\u6cd5\u4ee5\u53ca\u7cbe\u5ea6\u63a7\u5236\u65b9\u6cd5","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%204465/#4","text":"\u9996\u5148\u5f88\u81ea\u7136\u5c31\u80fd\u5f97\u51fa\u6982\u7387dp\u7684\u505a\u6cd5\u3002\u8bbedp[i][j]\u4e3a\u7b2c\u4e00\u4e2a\u76d2\u5b50\u4e2d\u5269\u4f59\u7cd6\u679c\u6570\u4e3ai\uff0c\u7b2c\u4e8c\u4e2a\u76d2\u5b50\u4e2d\u5269\u4f59\u7cd6\u679c\u6570\u4e3aj\u7684\u6982\u7387\uff0c\u8f6c\u79fb\u65b9\u7a0b dp[i-1][j]+=dp[i][j]*p,dp[i][j-1]+=dp[i][j]*(1-p) dp[i-1][j]+=dp[i][j]*p,dp[i][j-1]+=dp[i][j]*(1-p) \u521d\u59cb\u72b6\u6001 dp[n][n]=1 \uff0c\u76ee\u6807\u4e3a \\sum_{i=1}^{n} i * d p[0][i]+\\sum_{i=1}^{n} i * d p[i][0] \\sum_{i=1}^{n} i * d p[0][i]+\\sum_{i=1}^{n} i * d p[i][0] \uff0c\u53ef\u662f\u8fd9\u9053\u9898\u7684\u8303\u56f4\u662f2e5\uff0c\u65f6\u95f4\u548c\u7a7a\u95f4\u90fd\u4e0d\u591f\uff0c\u5bfb\u6c42\u516c\u5f0f\u505a\u6cd5\u3002 \u4ee4\u7b2c\u4e00\u4e2a\u76d2\u5b50\u53d6\u5149\u65f6\u7b2c\u4e8c\u4e2a\u76d2\u5b50\u7684\u7cd6\u679c\u7684\u671f\u671b\u4e3asolve(p), solve(p) = \\sum{(n-i)*C(n+i,n)*(p^{n+1}(1-p)^i)} solve(p) = \\sum{(n-i)*C(n+i,n)*(p^{n+1}(1-p)^i)} \u6ce8\u610f\u4ed6\u6253\u5f00\u76d2\u5b50\u65f6\u53d1\u73b0\u6ca1\u4e86\uff0c\u6240\u4ee5\u662fp\u7684(n+1)\u6b21\u65b9 \u7b2c\u4e8c\u4e2a\u76d2\u5b50\u53d6\u5149\u65f6\u7b2c\u4e00\u4e2a\u76d2\u5b50\u7684\u7cd6\u679c\u7684\u671f\u671b\u4e3asolve(1-p), $$ ans=solve(p)+solve(1-p) $$ \u5f53p=0\u6216p=1\u65f6\u9700\u8981\u7279\u5224\uff0c\u7b54\u6848\u4e3an\u3002 \u7136\u800c\u8fd9\u6837\u505a\u867d\u7136\u590d\u6742\u5ea6\u80fd\u901a\u8fc7\uff0c\u4f46\u662f\u4f1aWA\u3002\u539f\u56e0\u662f\u9898\u4e2d\u7684\u7cbe\u5ea6\u8981\u6c42\u5f88\u9ad8\uff0c\u5c0f\u6570\u7684\u9ad8\u6b21\u65b9\u4e22\u5931\u7cbe\u5ea6\u592a\u4e25\u91cd\u4e86\u3002\u9700\u8981\u53d6\u5bf9\u6570\u8fdb\u884c\u8ba1\u7b97\u3002 solve(p)=\\sum (n-i)*e^{\\log (C(n+i,n)*(p^{n+1})*((1-p)^i))} solve(p)=\\sum (n-i)*e^{\\log (C(n+i,n)*(p^{n+1})*((1-p)^i))} = \\sum(n-i)exp(log(C(n+i,n))+(n+1)*log(p)+i*log(1-p)) = \\sum(n-i)exp(log(C(n+i,n))+(n+1)*log(p)+i*log(1-p))","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%204465/#5","text":"\u6982\u7387\u7684\u8ba1\u7b97\u516c\u5f0f\u5bb9\u6613\u60f3\u5230\uff0c\u4e3b\u8981\u96be\u70b9\u662f\u5982\u4f55\u51cf\u5c11\u7cbe\u5ea6\u635f\u5931\u3002\u53d6\u5bf9\u6570\u8fdb\u884c\u8ba1\u7b97\u662f\u4e00\u79cd\u4e0d\u9519\u7684\u65b9\u6cd5\uff0c\u4ee5\u540e\u9047\u5230\u7c7b\u4f3c\u7684\u95ee\u9898\u65f6\u53ef\u4ee5\u501f\u9274\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%204465/#6","text":"http://acm.hdu.edu.cn/showproblem.php?pid=4465","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%204465/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <bits/stdc++.h> using namespace std ; #define LB long double LB f [ 400005 ]; int n ; void init (){ f [ 1 ] = 0 ; for ( int i = 2 ; i < 400005 ; i ++ ) f [ i ] = f [ i - 1 ] + log ( i ); } double solve ( LB p ){ double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ){ sum += ( n - i ) * exp (( n + 1 ) * log ( p ) + i * log ( 1 - p ) + ( f [ n + i ] - f [ n ] - f [ i ])); } return sum ; } int main (){ init (); LB p ; int _ = 1 ; while ( cin >> n >> p ){ double ans ; if ( p == 0 || p == 1 ) ans = n ; else ans = solve ( p ) + solve ( 1 - p ); printf ( \"Case %d: %.6lf \\n \" , _ ++ , ans ); } }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%204465/#8-","text":"","title":"8. \u4f5c\u8005-\u987e\u4f73\u660a"},{"location":"2019/HDU/HDU%204474/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 HDU 4474 Yet Another Multiple Problem 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u7ed9\u4e00\u4e2a\u6570\u5b57n\u548cm\u4e2a0-9\u7684\u6570\u5b57\uff0c\u95een\u7684\u6700\u5c0f\u591a\u5c11\u500d\u4e2d\u6ca1\u6709m\u4e2d\u4efb\u610f\u4e00\u4e2a\u6570\u5b57\u3002 n \u2264 1e4 n \u2264 1e4 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 bfs 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u7531\u5408\u6cd5\u7684\u6570\u5b57\u6784\u6210\u7684\u6574\u6570\uff0c\u76f4\u5230\u51fa\u73b0\u80fd\u88abn\u6574\u9664\u6216\u8005\u961f\u5217\u4e3a\u7a7a\uff0c\u6240\u4ee5bfs\u5c31\u884c\u4e86 \u5982\u679c\u6709\u4e24\u4e2a\u6574\u6570%n==x,\u90a3\u4e48\u663e\u7136\u540e\u9762\u90a3\u4e2a\u53ef\u4ee5contine\u4e86\uff0c\u56e0\u4e3a\u589e\u52a0\u4e00\u4f4dy\u7684\u8bdd\u4f59\u6570\u90fd\u7b49\u4e8e(x*10+y)%n,\u524d\u9762\u7684\u90a3\u4e2a\u6570\u53ef\u4ee5\u8986\u76d6\u540e\u9762\u7684\u6570\u7684\u6240\u6709\u540e\u7eed\u72b6\u6001\uff0c\u5e76\u4e14\u66f4\u5c0f\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u4ece\u9898\u76ee\u5165\u624b\u540e\u6709\u4e24\u4e2a\u65b9\u5411\uff0c\u5373\u627e\u7b26\u5408\u8981\u6c42\u7684\u6570\u5b57\u5224\u65ad\u662f\u5426\u4e3an\u7684\u6574\u6570\u500d\uff0c\u6216\u8005\u627en\u7684\u6574\u6570\u500d\u5224\u65ad\u662f\u5426\u7b26\u5408\u8981\u6c42\u3002\u4f46\u662f\u663e\u7136\u540e\u4e00\u79cd\u6ca1\u6709\u529e\u6cd5\u8fdb\u884c\u526a\u679d\uff0c\u6240\u4ee5\u8981\u4f7f\u7528\u7b2c\u4e00\u79cd\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://acm.hdu.edu.cn/showproblem.php?pid=4474 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include <bits/stdc++.h> using namespace std ; #define LL long long bool cantuse [ 20 ]; vector < char > a ; queue < string > que ; bool vis [ 100005 ]; LL n , m ; void init (){ memset ( cantuse , 0 , sizeof ( cantuse )); a . clear (); memset ( vis , 0 , sizeof ( vis )); while ( que . size ()) que . pop (); } int mod ( string s , int md ){ int ret = 0 ; for ( int i = 0 ; i < s . length (); i ++ ){ ret = ( ret * 10 + s [ i ] - '0' ) % md ; } return ret ; } string bfs (){ while ( que . size ()){ string k = que . front (); que . pop (); int md = mod ( k , n ); if ( vis [ md ]) continue ; vis [ md ] = 1 ; if ( md == 0 ) return k ; for ( LL i = 0 ; i < a . size (); i ++ ){ string tmp = k + a [ i ]; que . push ( tmp ); } } return \"-1\" ; } int main (){ int _ = 1 ; while ( cin >> n >> m ){ init (); for ( LL i = 0 ; i < m ; i ++ ){ LL x ; cin >> x ; cantuse [ x ] = 1 ; } for ( LL i = 0 ; i < 10 ; i ++ ){ if ( ! cantuse [ i ]) { if ( i != 0 ){ string tmp = \"\" ; tmp += char ( i + '0' ); que . push ( tmp ); } a . push_back ( char ( i + '0' )); } } printf ( \"Case %d: \" , _ ++ ); cout << bfs () << endl ; } } 8. \u4f5c\u8005-\u987e\u4f73\u660a \u00b6","title":"HDU 4474 BFS"},{"location":"2019/HDU/HDU%204474/#1","text":"HDU 4474 Yet Another Multiple Problem","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%204474/#2","text":"\u7ed9\u4e00\u4e2a\u6570\u5b57n\u548cm\u4e2a0-9\u7684\u6570\u5b57\uff0c\u95een\u7684\u6700\u5c0f\u591a\u5c11\u500d\u4e2d\u6ca1\u6709m\u4e2d\u4efb\u610f\u4e00\u4e2a\u6570\u5b57\u3002 n \u2264 1e4 n \u2264 1e4","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%204474/#3","text":"bfs","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%204474/#4","text":"\u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u7531\u5408\u6cd5\u7684\u6570\u5b57\u6784\u6210\u7684\u6574\u6570\uff0c\u76f4\u5230\u51fa\u73b0\u80fd\u88abn\u6574\u9664\u6216\u8005\u961f\u5217\u4e3a\u7a7a\uff0c\u6240\u4ee5bfs\u5c31\u884c\u4e86 \u5982\u679c\u6709\u4e24\u4e2a\u6574\u6570%n==x,\u90a3\u4e48\u663e\u7136\u540e\u9762\u90a3\u4e2a\u53ef\u4ee5contine\u4e86\uff0c\u56e0\u4e3a\u589e\u52a0\u4e00\u4f4dy\u7684\u8bdd\u4f59\u6570\u90fd\u7b49\u4e8e(x*10+y)%n,\u524d\u9762\u7684\u90a3\u4e2a\u6570\u53ef\u4ee5\u8986\u76d6\u540e\u9762\u7684\u6570\u7684\u6240\u6709\u540e\u7eed\u72b6\u6001\uff0c\u5e76\u4e14\u66f4\u5c0f\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%204474/#5","text":"\u4ece\u9898\u76ee\u5165\u624b\u540e\u6709\u4e24\u4e2a\u65b9\u5411\uff0c\u5373\u627e\u7b26\u5408\u8981\u6c42\u7684\u6570\u5b57\u5224\u65ad\u662f\u5426\u4e3an\u7684\u6574\u6570\u500d\uff0c\u6216\u8005\u627en\u7684\u6574\u6570\u500d\u5224\u65ad\u662f\u5426\u7b26\u5408\u8981\u6c42\u3002\u4f46\u662f\u663e\u7136\u540e\u4e00\u79cd\u6ca1\u6709\u529e\u6cd5\u8fdb\u884c\u526a\u679d\uff0c\u6240\u4ee5\u8981\u4f7f\u7528\u7b2c\u4e00\u79cd\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%204474/#6","text":"http://acm.hdu.edu.cn/showproblem.php?pid=4474","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%204474/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include <bits/stdc++.h> using namespace std ; #define LL long long bool cantuse [ 20 ]; vector < char > a ; queue < string > que ; bool vis [ 100005 ]; LL n , m ; void init (){ memset ( cantuse , 0 , sizeof ( cantuse )); a . clear (); memset ( vis , 0 , sizeof ( vis )); while ( que . size ()) que . pop (); } int mod ( string s , int md ){ int ret = 0 ; for ( int i = 0 ; i < s . length (); i ++ ){ ret = ( ret * 10 + s [ i ] - '0' ) % md ; } return ret ; } string bfs (){ while ( que . size ()){ string k = que . front (); que . pop (); int md = mod ( k , n ); if ( vis [ md ]) continue ; vis [ md ] = 1 ; if ( md == 0 ) return k ; for ( LL i = 0 ; i < a . size (); i ++ ){ string tmp = k + a [ i ]; que . push ( tmp ); } } return \"-1\" ; } int main (){ int _ = 1 ; while ( cin >> n >> m ){ init (); for ( LL i = 0 ; i < m ; i ++ ){ LL x ; cin >> x ; cantuse [ x ] = 1 ; } for ( LL i = 0 ; i < 10 ; i ++ ){ if ( ! cantuse [ i ]) { if ( i != 0 ){ string tmp = \"\" ; tmp += char ( i + '0' ); que . push ( tmp ); } a . push_back ( char ( i + '0' )); } } printf ( \"Case %d: \" , _ ++ ); cout << bfs () << endl ; } }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%204474/#8-","text":"","title":"8. \u4f5c\u8005-\u987e\u4f73\u660a"},{"location":"2019/HDU/HDU%204742/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 4742"},{"location":"2019/HDU/HDU%204742/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%204742/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%204742/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%204742/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%204742/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%204742/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%204742/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%204742/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%205468/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 5468"},{"location":"2019/HDU/HDU%205468/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%205468/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%205468/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%205468/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%205468/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%205468/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%205468/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%205468/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%205534/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 5534 \u5b8c\u5168\u80cc\u5305"},{"location":"2019/HDU/HDU%205534/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%205534/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%205534/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%205534/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%205534/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%205534/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%205534/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%205534/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%205934/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 5934"},{"location":"2019/HDU/HDU%205934/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%205934/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%205934/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%205934/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%205934/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%205934/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%205934/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%205934/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%205985/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 5985"},{"location":"2019/HDU/HDU%205985/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%205985/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%205985/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%205985/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%205985/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%205985/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%205985/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%205985/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%205992/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 5992"},{"location":"2019/HDU/HDU%205992/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%205992/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%205992/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%205992/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%205992/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%205992/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%205992/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%205992/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%206219/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 6219"},{"location":"2019/HDU/HDU%206219/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%206219/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%206219/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%206219/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%206219/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%206219/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%206219/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%206219/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%206230/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 6230"},{"location":"2019/HDU/HDU%206230/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%206230/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%206230/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%206230/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%206230/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%206230/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%206230/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%206230/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%206252/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 6252"},{"location":"2019/HDU/HDU%206252/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%206252/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%206252/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%206252/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%206252/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%206252/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%206252/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%206252/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/HDU/HDU%206562/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"HDU 6562 \u786c\u6838\u7ebf\u6bb5\u6811"},{"location":"2019/HDU/HDU%206562/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/HDU/HDU%206562/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/HDU/HDU%206562/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/HDU/HDU%206562/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/HDU/HDU%206562/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/HDU/HDU%206562/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/HDU/HDU%206562/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/HDU/HDU%206562/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/LOJ/LOJ%206062/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"LOJ 6062 \u7ebf\u6bb5\u6811+\u4e8c\u5206\u56fe\u5339\u914dHall\u5b9a\u7406"},{"location":"2019/LOJ/LOJ%206062/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/LOJ/LOJ%206062/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/LOJ/LOJ%206062/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/LOJ/LOJ%206062/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/LOJ/LOJ%206062/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/LOJ/LOJ%206062/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/LOJ/LOJ%206062/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/LOJ/LOJ%206062/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/POJ/POJ%201156/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"POJ 1156 \u57fa\u7840\u7ebf\u6bb5\u51e0\u4f55+\u6700\u77ed\u8def"},{"location":"2019/POJ/POJ%201156/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/POJ/POJ%201156/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/POJ/POJ%201156/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/POJ/POJ%201156/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/POJ/POJ%201156/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/POJ/POJ%201156/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/POJ/POJ%201156/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/POJ/POJ%201156/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/POJ/POJ%201401/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1401 Intersection 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u7ed9\u5b9a\u4e00\u4e2a\u77e9\u5f62\u7684\u5de6\u4e0a\u89d2\u548c\u53c8\u4e0b\u89d2\u5750\u6807\uff0c\u518d\u7ed9\u5b9a\u4e00\u6761\u7ebf\u6bb5\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u5750\u6807\u3002\u5224\u65ad\u7ebf\u6bb5\u4e0e\u77e9\u5f62\u6709\u6ca1\u6709\u516c\u5171\u70b9\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5411\u91cf\u53c9\u79ef\uff0c\u5224\u65ad\u7ebf\u6bb5\u76f8\u4ea4\uff08\u5feb\u901f\u6392\u65a5\u548c\u8de8\u7acb\u5b9e\u9a8c\uff09 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u77e9\u5f62\u7684\u6bcf\u6761\u8fb9\uff0c\u4f7f\u7528\u7ebf\u6bb5\u76f8\u4ea4\u6a21\u677f\u53ef\u4ee5\u5224\u65ad\u662f\u5426\u4e0e\u7ebf\u6bb5\u6709\u4ea4\u70b9\u3002\u7136\u540e\u518d\u901a\u8fc7\u5224\u65ad\u7ebf\u6bb5\u7684\u7aef\u70b9\u662f\u5426\u5728\u77e9\u5f62\u5185\u6216\u77e9\u5f62\u7684\u8fb9\u754c\u4e0a\u6765\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u5728\u77e9\u5f62\u5185\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u672c\u9898\u6ca1\u6709\u8bf4\u660e\u7ed9\u5b9a\u5de6\u4e0a\u89d2\u548c\u53f3\u4e0b\u89d2\u70b9\u65f6\u7684\u987a\u5e8f\u3002\u6240\u4ee5\u9700\u8981\u6839\u636e\u5750\u6807\u5148\u884c\u5224\u65ad\u3002\u8fd8\u6709\u5f53\u7ebf\u6bb5\u5b8c\u5168\u5728\u77e9\u5f62\u5185\u90e8\u65f6\u7ebf\u6bb5\u4e0e\u77e9\u5f62\u7684\u8fb9\u6846\u81ea\u7136\u6ca1\u6709\u4ea4\u70b9\uff0c\u4f46\u8fd9\u4e5f\u662f\u7ebf\u6bb5\u4e0e\u77e9\u5f62\u6709\u516c\u5171\u70b9\u7684\u4e00\u79cd\u5408\u6cd5\u60c5\u51b5\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1410 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include <iostream> #include <cstdio> using namespace std ; struct point { int x ; int y ; point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point (){} }; int cross ( point a , point b ) { return a . x * b . y - b . x * a . y ; } bool touch ( point abegin , point aend , point bbegin , point bend ) { if ( min ( abegin . x , aend . x ) <= max ( bbegin . x , bend . x ) && min ( bbegin . x , bend . x ) <= max ( abegin . x , aend . x ) && min ( abegin . y , aend . y ) <= max ( bbegin . y , bend . y ) && min ( bbegin . y , bend . y ) <= max ( abegin . y , aend . y ) ) { point a ( bbegin , abegin ); point b ( bbegin , bend ); point c ( bbegin , aend ); int m = cross ( a , b ) * cross ( c , b ); ///<=0 a = point ( aend , bbegin ); b = point ( aend , abegin ); c = point ( aend , bend ); int mm = cross ( a , b ) * cross ( c , b ); ///<=0 if ( m <= 0 && mm <= 0 ) { return 1 ; } } return 0 ; } bool inrectangle ( point p , point a , point b ) { if ( a . x <= p . x && p . x <= b . x && b . y <= p . y && p . y <= a . y ) return 1 ; return 0 ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { point testbegin , testend ; scanf ( \"%d%d%d%d\" , & testbegin . x , & testbegin . y , & testend . x , & testend . y ); point a [ 4 ]; scanf ( \"%d%d%d%d\" , & a [ 0 ]. x , & a [ 0 ]. y , & a [ 2 ]. x , & a [ 2 ]. y ); if ( a [ 0 ]. x > a [ 2 ]. x ) swap ( a [ 0 ]. x , a [ 2 ]. x ); if ( a [ 0 ]. y < a [ 2 ]. y ) swap ( a [ 0 ]. y , a [ 2 ]. y ); a [ 1 ]. x = a [ 0 ]. x ; a [ 1 ]. y = a [ 2 ]. y ; a [ 3 ]. x = a [ 2 ]. x ; a [ 3 ]. y = a [ 0 ]. y ; bool ok = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( touch ( a [ i ], a [( i + 1 ) % 4 ], testbegin , testend )) { ok = 1 ; } } if ( inrectangle ( testbegin , a [ 0 ], a [ 2 ]) || inrectangle ( testend , a [ 0 ], a [ 2 ])) { ok = 1 ; } if ( ok ) { printf ( \"T \\n \" ); } else { printf ( \"F \\n \" ); } } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"POJ 1401 \u7ebf\u6bb5\u76f8\u4ea4"},{"location":"2019/POJ/POJ%201401/#1","text":"POJ 1401 Intersection","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/POJ/POJ%201401/#2","text":"\u7ed9\u5b9a\u4e00\u4e2a\u77e9\u5f62\u7684\u5de6\u4e0a\u89d2\u548c\u53c8\u4e0b\u89d2\u5750\u6807\uff0c\u518d\u7ed9\u5b9a\u4e00\u6761\u7ebf\u6bb5\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u5750\u6807\u3002\u5224\u65ad\u7ebf\u6bb5\u4e0e\u77e9\u5f62\u6709\u6ca1\u6709\u516c\u5171\u70b9\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/POJ/POJ%201401/#3","text":"\u5411\u91cf\u53c9\u79ef\uff0c\u5224\u65ad\u7ebf\u6bb5\u76f8\u4ea4\uff08\u5feb\u901f\u6392\u65a5\u548c\u8de8\u7acb\u5b9e\u9a8c\uff09","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/POJ/POJ%201401/#4","text":"\u679a\u4e3e\u77e9\u5f62\u7684\u6bcf\u6761\u8fb9\uff0c\u4f7f\u7528\u7ebf\u6bb5\u76f8\u4ea4\u6a21\u677f\u53ef\u4ee5\u5224\u65ad\u662f\u5426\u4e0e\u7ebf\u6bb5\u6709\u4ea4\u70b9\u3002\u7136\u540e\u518d\u901a\u8fc7\u5224\u65ad\u7ebf\u6bb5\u7684\u7aef\u70b9\u662f\u5426\u5728\u77e9\u5f62\u5185\u6216\u77e9\u5f62\u7684\u8fb9\u754c\u4e0a\u6765\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u5728\u77e9\u5f62\u5185\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/POJ/POJ%201401/#5","text":"\u672c\u9898\u6ca1\u6709\u8bf4\u660e\u7ed9\u5b9a\u5de6\u4e0a\u89d2\u548c\u53f3\u4e0b\u89d2\u70b9\u65f6\u7684\u987a\u5e8f\u3002\u6240\u4ee5\u9700\u8981\u6839\u636e\u5750\u6807\u5148\u884c\u5224\u65ad\u3002\u8fd8\u6709\u5f53\u7ebf\u6bb5\u5b8c\u5168\u5728\u77e9\u5f62\u5185\u90e8\u65f6\u7ebf\u6bb5\u4e0e\u77e9\u5f62\u7684\u8fb9\u6846\u81ea\u7136\u6ca1\u6709\u4ea4\u70b9\uff0c\u4f46\u8fd9\u4e5f\u662f\u7ebf\u6bb5\u4e0e\u77e9\u5f62\u6709\u516c\u5171\u70b9\u7684\u4e00\u79cd\u5408\u6cd5\u60c5\u51b5\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/POJ/POJ%201401/#6","text":"http://poj.org/problem?id=1410","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/POJ/POJ%201401/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include <iostream> #include <cstdio> using namespace std ; struct point { int x ; int y ; point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point (){} }; int cross ( point a , point b ) { return a . x * b . y - b . x * a . y ; } bool touch ( point abegin , point aend , point bbegin , point bend ) { if ( min ( abegin . x , aend . x ) <= max ( bbegin . x , bend . x ) && min ( bbegin . x , bend . x ) <= max ( abegin . x , aend . x ) && min ( abegin . y , aend . y ) <= max ( bbegin . y , bend . y ) && min ( bbegin . y , bend . y ) <= max ( abegin . y , aend . y ) ) { point a ( bbegin , abegin ); point b ( bbegin , bend ); point c ( bbegin , aend ); int m = cross ( a , b ) * cross ( c , b ); ///<=0 a = point ( aend , bbegin ); b = point ( aend , abegin ); c = point ( aend , bend ); int mm = cross ( a , b ) * cross ( c , b ); ///<=0 if ( m <= 0 && mm <= 0 ) { return 1 ; } } return 0 ; } bool inrectangle ( point p , point a , point b ) { if ( a . x <= p . x && p . x <= b . x && b . y <= p . y && p . y <= a . y ) return 1 ; return 0 ; } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { point testbegin , testend ; scanf ( \"%d%d%d%d\" , & testbegin . x , & testbegin . y , & testend . x , & testend . y ); point a [ 4 ]; scanf ( \"%d%d%d%d\" , & a [ 0 ]. x , & a [ 0 ]. y , & a [ 2 ]. x , & a [ 2 ]. y ); if ( a [ 0 ]. x > a [ 2 ]. x ) swap ( a [ 0 ]. x , a [ 2 ]. x ); if ( a [ 0 ]. y < a [ 2 ]. y ) swap ( a [ 0 ]. y , a [ 2 ]. y ); a [ 1 ]. x = a [ 0 ]. x ; a [ 1 ]. y = a [ 2 ]. y ; a [ 3 ]. x = a [ 2 ]. x ; a [ 3 ]. y = a [ 0 ]. y ; bool ok = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( touch ( a [ i ], a [( i + 1 ) % 4 ], testbegin , testend )) { ok = 1 ; } } if ( inrectangle ( testbegin , a [ 0 ], a [ 2 ]) || inrectangle ( testend , a [ 0 ], a [ 2 ])) { ok = 1 ; } if ( ok ) { printf ( \"T \\n \" ); } else { printf ( \"F \\n \" ); } } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/POJ/POJ%201401/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/ZOJ/ZOJ%203937/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ZOJ 3937 \u6811\u4e0adfs+\u659c\u7387\u4f18\u5316DP+\u53ef\u6301\u4e45\u5316\u7ef4\u62a4\u51f8\u58f3"},{"location":"2019/ZOJ/ZOJ%203937/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/ZOJ/ZOJ%203937/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/ZOJ/ZOJ%203937/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/ZOJ/ZOJ%203937/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/ZOJ/ZOJ%203937/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/ZOJ/ZOJ%203937/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/ZOJ/ZOJ%203937/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/ZOJ/ZOJ%203937/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/ZOJ/ZOJ%204027/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ZOJ 4027 \u6784\u9020+\u62d3\u6251+bfs"},{"location":"2019/ZOJ/ZOJ%204027/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/ZOJ/ZOJ%204027/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/ZOJ/ZOJ%204027/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/ZOJ/ZOJ%204027/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/ZOJ/ZOJ%204027/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/ZOJ/ZOJ%204027/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/ZOJ/ZOJ%204027/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/ZOJ/ZOJ%204027/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/ZOJ/ZOJ%204028/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ZOJ 4028 LIS"},{"location":"2019/ZOJ/ZOJ%204028/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/ZOJ/ZOJ%204028/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/ZOJ/ZOJ%204028/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/ZOJ/ZOJ%204028/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/ZOJ/ZOJ%204028/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/ZOJ/ZOJ%204028/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/ZOJ/ZOJ%204028/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/ZOJ/ZOJ%204028/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/ZOJ/ZOJ%204114/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 ZOJ 4114 Flipping Game 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u7ed9\u4e24\u4e2a\u957f\u5ea6\u4e3an\u768401\u4e32\uff0c\u6bcf\u6b21\u6311\u9009\u7b2c\u4e00\u4e2a\u4e32\u5176\u4e2d\u7684m\u4f4d\u7ffb\u8f6c\uff080\u53d8\u62101,1\u53d8\u62100,m\u4f4d\u4e0d\u7528\u8fde\u7eed\uff09\u95ee\u7ecf\u8fc7k\u6b21\u7684\u540e\u5f97\u5230\u7b2c\u4e8c\u4e2a\u4e32\u7684\u65b9\u6848\u6570\u3002 n,m,k \u2264 100 n,m,k \u2264 100 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 DP 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u82e5\u4e24\u4e2a\u4e32\u7684\u67d0\u4e00\u4f4d\u76f8\u540c\uff0c\u5219\u8be5\u4f4d\u7ecf\u8fc7\u4e86\u5076\u6570\u6b21\u7ffb\u8f6c\uff0c\u5426\u5219\u7ecf\u8fc7\u4e86\u5947\u6570\u6b21\u7684\u7ffb\u8f6c\u3002 dp[i][j]\u8868\u793a\u7ecf\u8fc7\u4e86i\u8f6e\u7ffb\u8f6c\u540e\u5947\u6570\u4f4d\u6570\u7b49\u4e8ej\u7684\u65b9\u6848\u6570\uff0c\u5076\u6570\u7684\u4f4d\u6570\u7b49\u4e8en-j\u3002\u4ece0-m\u679a\u4e3ek\uff0c\u8868\u793aj\u4e2a\u5947\u6570\u4f4d\u4e2d\u6709k\u4e2a\u7ffb\u8f6c\u6210\u4e86\u5076\u6570\uff0c(n-j)\u4e2a\u5076\u6570\u4f4d\u4e2d\u6709(m-k)\u4f4d\u7ffb\u8f6c\u6210\u4e86\u5947\u6570\u4f4d\uff0c\u6240\u4ee5 dp[i+1][j-k+(m-k)]+=dp[i][j]*C[j][k]*C[n-j][m-k] ; 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u770b\u4e0a\u53bb\u8fd9\u9898\u4f3c\u4e4e\u6709\u4e24\u79cd\u6b63\u786e\u7684\u521d\u59cb\u503c\u8bbe\u7f6e\u65b9\u6cd5\uff1a dp[0][0]=1, \u6c42 dp[k][num_odd] OR dp[0][num_odd]=1 ,\u6c42 dp[k][0] \u3002\u53ef\u662f\u7ecf\u8fc7\u8bd5\u9a8c\u53d1\u73b0\u4e24\u79cd\u7684\u7b54\u6848\u4e0d\u4e00\u6837\u3002\u4ed4\u7ec6\u60f3\u60f3\uff0c\u6211\u4eec\u7684dp\u8fc7\u7a0b\u4e2d\u53ea\u8bb0\u5f55\u4e86\u5947\u6570\u4f4d\u7684\u4e2a\u6570\uff0c\u5e76\u6ca1\u6709\u5177\u4f53\u7edf\u8ba1\u54ea\u4f4d\u662f\u5947\u6570\uff0c\u56e0\u6b64\u6211\u4eec\u6700\u540e\u5f97\u5230\u7684dp[k][num_odd]\u662f\u6240\u6709\u7684\u5947\u6570\u4f4d\u6570\u7b49\u4e8e\u7b54\u6848\u7684\u65b9\u6848\u6570\uff0c\u53ef\u662f\u663e\u7136\u4ed6\u4eec\u65e0\u6cd5\u548c\u8981\u6c42\u7684\u7b2c\u4e8c\u4e2a\u4e32\u5b8c\u5168\u5339\u914d\u3002\u56e0\u6b64\u628a\u521d\u59cb\u503c dp[0][num_odd] \u8bbe\u62101\u6c42 dp[k][0] \u624d\u662f\u6b63\u786e\u7684\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4114 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <bits/stdc++.h> using namespace std ; #define LL long long LL dp [ 105 ][ 105 ], C [ 105 ][ 105 ]; const int mod = 998244353 ; void init (){ for ( int i = 0 ; i <= 100 ; i ++ ) C [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= 100 ; i ++ ){ for ( int j = 1 ; j <= i ; j ++ ){ C [ i ][ j ] = ( C [ i - 1 ][ j - 1 ] + C [ i - 1 ][ j ]) % mod ; } } } int main (){ init (); int T ; cin >> T ; while ( T -- ){ int n , q , m ; cin >> n >> q >> m ; string s1 , s2 ; cin >> s1 >> s2 ; int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ){ if ( s1 [ i ] == s2 [ i ]) even ++ ; else odd ++ ; } memset ( dp , 0 , sizeof ( dp )); dp [ 0 ][ odd ] = 1 ; for ( int i = 0 ; i <= q ; i ++ ){ for ( int j = 0 ; j <= n ; j ++ ){ for ( int k = 0 ; k <= m ; k ++ ){ if ( j >= k && ( n - j ) >= ( m - k )){ dp [ i + 1 ][ j - k + ( m - k )] += dp [ i ][ j ] * C [ j ][ k ] % mod * C [ n - j ][ m - k ] % mod ; dp [ i + 1 ][ j - k + ( m - k )] %= mod ; } } } } cout << dp [ q ][ 0 ] << endl ; } } 8. \u4f5c\u8005-\u987e\u4f73\u660a \u00b6","title":"ZOJ 4114 DP"},{"location":"2019/ZOJ/ZOJ%204114/#1","text":"ZOJ 4114 Flipping Game","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/ZOJ/ZOJ%204114/#2","text":"\u7ed9\u4e24\u4e2a\u957f\u5ea6\u4e3an\u768401\u4e32\uff0c\u6bcf\u6b21\u6311\u9009\u7b2c\u4e00\u4e2a\u4e32\u5176\u4e2d\u7684m\u4f4d\u7ffb\u8f6c\uff080\u53d8\u62101,1\u53d8\u62100,m\u4f4d\u4e0d\u7528\u8fde\u7eed\uff09\u95ee\u7ecf\u8fc7k\u6b21\u7684\u540e\u5f97\u5230\u7b2c\u4e8c\u4e2a\u4e32\u7684\u65b9\u6848\u6570\u3002 n,m,k \u2264 100 n,m,k \u2264 100","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/ZOJ/ZOJ%204114/#3","text":"DP","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/ZOJ/ZOJ%204114/#4","text":"\u82e5\u4e24\u4e2a\u4e32\u7684\u67d0\u4e00\u4f4d\u76f8\u540c\uff0c\u5219\u8be5\u4f4d\u7ecf\u8fc7\u4e86\u5076\u6570\u6b21\u7ffb\u8f6c\uff0c\u5426\u5219\u7ecf\u8fc7\u4e86\u5947\u6570\u6b21\u7684\u7ffb\u8f6c\u3002 dp[i][j]\u8868\u793a\u7ecf\u8fc7\u4e86i\u8f6e\u7ffb\u8f6c\u540e\u5947\u6570\u4f4d\u6570\u7b49\u4e8ej\u7684\u65b9\u6848\u6570\uff0c\u5076\u6570\u7684\u4f4d\u6570\u7b49\u4e8en-j\u3002\u4ece0-m\u679a\u4e3ek\uff0c\u8868\u793aj\u4e2a\u5947\u6570\u4f4d\u4e2d\u6709k\u4e2a\u7ffb\u8f6c\u6210\u4e86\u5076\u6570\uff0c(n-j)\u4e2a\u5076\u6570\u4f4d\u4e2d\u6709(m-k)\u4f4d\u7ffb\u8f6c\u6210\u4e86\u5947\u6570\u4f4d\uff0c\u6240\u4ee5 dp[i+1][j-k+(m-k)]+=dp[i][j]*C[j][k]*C[n-j][m-k] ;","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/ZOJ/ZOJ%204114/#5","text":"\u770b\u4e0a\u53bb\u8fd9\u9898\u4f3c\u4e4e\u6709\u4e24\u79cd\u6b63\u786e\u7684\u521d\u59cb\u503c\u8bbe\u7f6e\u65b9\u6cd5\uff1a dp[0][0]=1, \u6c42 dp[k][num_odd] OR dp[0][num_odd]=1 ,\u6c42 dp[k][0] \u3002\u53ef\u662f\u7ecf\u8fc7\u8bd5\u9a8c\u53d1\u73b0\u4e24\u79cd\u7684\u7b54\u6848\u4e0d\u4e00\u6837\u3002\u4ed4\u7ec6\u60f3\u60f3\uff0c\u6211\u4eec\u7684dp\u8fc7\u7a0b\u4e2d\u53ea\u8bb0\u5f55\u4e86\u5947\u6570\u4f4d\u7684\u4e2a\u6570\uff0c\u5e76\u6ca1\u6709\u5177\u4f53\u7edf\u8ba1\u54ea\u4f4d\u662f\u5947\u6570\uff0c\u56e0\u6b64\u6211\u4eec\u6700\u540e\u5f97\u5230\u7684dp[k][num_odd]\u662f\u6240\u6709\u7684\u5947\u6570\u4f4d\u6570\u7b49\u4e8e\u7b54\u6848\u7684\u65b9\u6848\u6570\uff0c\u53ef\u662f\u663e\u7136\u4ed6\u4eec\u65e0\u6cd5\u548c\u8981\u6c42\u7684\u7b2c\u4e8c\u4e2a\u4e32\u5b8c\u5168\u5339\u914d\u3002\u56e0\u6b64\u628a\u521d\u59cb\u503c dp[0][num_odd] \u8bbe\u62101\u6c42 dp[k][0] \u624d\u662f\u6b63\u786e\u7684\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/ZOJ/ZOJ%204114/#6","text":"http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4114","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/ZOJ/ZOJ%204114/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <bits/stdc++.h> using namespace std ; #define LL long long LL dp [ 105 ][ 105 ], C [ 105 ][ 105 ]; const int mod = 998244353 ; void init (){ for ( int i = 0 ; i <= 100 ; i ++ ) C [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= 100 ; i ++ ){ for ( int j = 1 ; j <= i ; j ++ ){ C [ i ][ j ] = ( C [ i - 1 ][ j - 1 ] + C [ i - 1 ][ j ]) % mod ; } } } int main (){ init (); int T ; cin >> T ; while ( T -- ){ int n , q , m ; cin >> n >> q >> m ; string s1 , s2 ; cin >> s1 >> s2 ; int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ){ if ( s1 [ i ] == s2 [ i ]) even ++ ; else odd ++ ; } memset ( dp , 0 , sizeof ( dp )); dp [ 0 ][ odd ] = 1 ; for ( int i = 0 ; i <= q ; i ++ ){ for ( int j = 0 ; j <= n ; j ++ ){ for ( int k = 0 ; k <= m ; k ++ ){ if ( j >= k && ( n - j ) >= ( m - k )){ dp [ i + 1 ][ j - k + ( m - k )] += dp [ i ][ j ] * C [ j ][ k ] % mod * C [ n - j ][ m - k ] % mod ; dp [ i + 1 ][ j - k + ( m - k )] %= mod ; } } } } cout << dp [ q ][ 0 ] << endl ; } }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/ZOJ/ZOJ%204114/#8-","text":"","title":"8. \u4f5c\u8005-\u987e\u4f73\u660a"},{"location":"2019/ZOJ/ZOJ%204122/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ZOJ 4122 Dijkstra+\u5220\u8fb9+\u6b27\u62c9\u8def"},{"location":"2019/ZOJ/ZOJ%204122/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/ZOJ/ZOJ%204122/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/ZOJ/ZOJ%204122/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/ZOJ/ZOJ%204122/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/ZOJ/ZOJ%204122/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/ZOJ/ZOJ%204122/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/ZOJ/ZOJ%204122/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/ZOJ/ZOJ%204122/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ACM 2017ECF"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202017ECF/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ACM 2018\u5357\u4eacF"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E5%8D%97%E4%BA%ACF/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"ACM 2018\u6c88\u9633C"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E5%8C%BA%E5%9F%9F%E8%B5%9B/ACM%202018%E6%B2%88%E9%98%B3C/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"\u725b\u5ba249-E \u7ebf\u6027\u57fa"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%89%9B%E5%AE%A249-E/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"\u8ba1\u849c\u5ba21555I"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A21555I/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 \u8ba1\u849c\u5ba2 39272 Tree 2. \u9898\u610f\u7b80\u8ff0 \u00b6 1 2 3 4 \u6709\u4e00\u68f5n\u4e2a\u8282\u70b9\u7684\u6811\uff0c\u70b9\u6709\u70b9\u6743\uff0c\u6709\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a 1 s t\uff1a\u5c06\u4ece\u8282\u70b91\u5230s\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u70b9\u6743|=t\uff1b 2 s t\uff1a\u5c06\u4ece\u8282\u70b91\u5230s\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u70b9\u6743&=t\uff1b 3 s t\uff1a\u8be2\u95ee\u8282\u70b91\u5230s\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u5f02\u6216\u548c\u662f\u5426\u7b49\u4e8et\u3002 1<=n<=1e5 1<=n<=1e5 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u672c\u9898\u8003\u5bdf\u6811\u94fe\u5256\u5206\u7684\u57fa\u7840\u53ca\u7ebf\u6bb5\u6811\u7684\u6784\u9020\u3002 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u76f4\u63a5\u6811\u5256\u540e\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u5f02\u6216\u548c\uff0c\u53d1\u73b0\u5f02\u6216\u548c\u6709\u5982\u4e0b\u6027\u8d28\uff1a \u82e5\u8be5\u4f4d\u4e3a1\uff0c\u8bf4\u660e\u533a\u95f4\u5185\u6709\u5947\u6570\u4e2a\u8be5\u4f4d\u4e3a1\u7684\u70b9\uff1b \u82e5\u8be5\u4f4d\u4e3a0\uff0c\u8bf4\u660e\u533a\u95f4\u5185\u6709\u5076\u6570\u4e2a\u8be5\u4f4d\u4e3a1\u7684\u70b9\u3002 or\u4e00\u4e2a\u6570\u4e4b\u540e\uff0c\u4f1a\u5c06\u539f\u672c\u4e3a0\u7684\u4f4d\u53d8\u4e3a1\uff1a \u82e5\u533a\u95f4\u957f\u5ea6\u4e3a\u5947\u6570\uff1a \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a1\uff0c\u5219\u6709\u5076\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u4ecd\u4e3a1\uff1b \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a0\uff0c\u5219\u6709\u5947\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u53d8\u4e3a1\uff1b \u7b49\u540c\u4e8e\u76f4\u63a5or\u8be5\u6570\u3002 \u82e5\u533a\u95f4\u957f\u5ea6\u4e3a\u5076\u6570\uff1a \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a1\uff0c\u5219\u6709\u5947\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u53d8\u4e3a0\uff1b \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a0\uff0c\u5219\u6709\u5076\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u4ecd\u4e3a0\u3002 \u7b49\u540c\u4e8eand\u8be5\u6570\u7684\u53cd\u3002 and\u4e00\u4e2a\u6570\u4e4b\u540e\uff0c\u4f1a\u5c06\u539f\u672c\u4e3a1\u7684\u4f4d\u53d8\u4e3a0\uff0c\u5982\u4e0a\u5206\u6790\u540e\u53d1\u73b0\uff0c\u65e0\u8bba\u533a\u95f4\u957f\u5ea6\u4e3a\u5947\u6570\u6216\u5076\u6570\uff0c\u90fd\u7b49\u540c\u4e8e\u76f4\u63a5and\u8be5\u6570\u3002 \u7efc\u4e0a\uff0c\u8bbe\u533a\u95f4or\u7684\u6570\u4e3au\uff0cand\u7684\u6570\u4e3av\uff0c\u5f02\u6216\u548c\u4e3asum\uff0c \u5219\u5f53\u533a\u95f4\u957f\u5ea6\u4e3a\u5947\u6570\u65f6\uff0csum=sum&v|u\uff1b \u957f\u5ea6\u4e3a\u5076\u6570\u65f6\uff0csum=sum&v&(~u)\u3002 \u800c\u5148and\u518dor\u548c\u5148or\u518dand\u662f\u6709\u533a\u522b\u7684\uff0c\u6240\u4ee5\u5f53\u5176\u4e2d\u4e00\u4e2a\u6807\u8bb0\u4fee\u6539\u65f6\uff0c\u53e6\u4e00\u4e2a\u6807\u8bb0\u90fd\u8981\u7ee7\u627f\u5176\u4fee\u6539\uff0c\u4ee5\u786e\u4fdd\u4e24\u8005\u662f\u7b49\u4ef7\u7684\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6 O(nlognlogn) O(nlognlogn) \u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u56e0\u4e3a\u4f4d\u8fd0\u7b97\u4e0d\u6ee1\u8db3\u4ea4\u6362\u5f8b\uff0c\u6240\u4ee5\u5f53\u5176\u4e2d\u4e00\u4e2a\u6807\u8bb0\u4fee\u6539\u65f6\uff0c\u53e6\u4e00\u4e2a\u6807\u8bb0\u8981\u7ee7\u627f\u5176\u4fee\u6539\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 https://www.cnblogs.com/ivanovcraft/p/9019090.html https://www.cnblogs.com/xyq0220/p/10945971.html 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 #include <bits/stdc++.h> #define sz(x) ((int)x.size()) #define mp(x, y) make_pair(x, y) using namespace std ; typedef long long ll ; const int MAXN = 100010 ; const int inf = ( 1 << 30 ) - 1 ; int n , m ; int cnt , tid [ MAXN ], rnk [ MAXN ]; int faz [ MAXN ], dep [ MAXN ], val [ MAXN ]; int siz [ MAXN ], son [ MAXN ], top [ MAXN ]; int tot , head [ MAXN ]; int sum [ MAXN << 2 ], lazAd [ MAXN << 2 ], lazOr [ MAXN << 2 ]; #define lson (p << 1) #define rson (p << 1 | 1) #define mid ((l + r) >> 1) struct Edge { int to , next ; } edges [ MAXN << 1 ]; void addEdge ( int x , int y ){ edges [ ++ tot ]. to = y ; edges [ tot ]. next = head [ x ]; head [ x ] = tot ; } void dfs1 ( int x , int fa ){ faz [ x ] = fa ; dep [ x ] = dep [ fa ] + 1 ; siz [ x ] = 1 ; for ( int i = head [ x ]; i ; i = edges [ i ]. next ){ int y = edges [ i ]. to ; if ( y == fa ) continue ; dfs1 ( y , x ); siz [ x ] += siz [ y ]; if ( siz [ y ] > siz [ son [ x ]]) son [ x ] = y ; } } void dfs2 ( int x , int tp ){ top [ x ] = tp ; tid [ x ] = ++ cnt ; rnk [ cnt ] = x ; if ( son [ x ]) dfs2 ( son [ x ], tp ); for ( int i = head [ x ]; i ; i = edges [ i ]. next ){ int y = edges [ i ]. to ; if ( y == faz [ x ] || y == son [ x ]) continue ; dfs2 ( y , y ); } } void build ( int p , int l , int r ){ lazAd [ p ] = inf ; lazOr [ p ] = 0 ; if ( l == r ){ sum [ p ] = val [ rnk [ l ]]; return ; } build ( lson , l , mid ); build ( rson , mid + 1 , r ); sum [ p ] = sum [ lson ] ^ sum [ rson ]; } void updLaz ( int p , int f , int v ){ if ( f ) lazAd [ p ] &= v , lazOr [ p ] &= v ; else lazOr [ p ] |= v , lazAd [ p ] |= v ; } void updSum ( int p , int l , int r ){ if (( r - l + 1 ) & 1 ) sum [ p ] = (( sum [ p ] & lazAd [ p ]) | lazOr [ p ]); else sum [ p ] = ( sum [ p ] & lazAd [ p ] & ( inf ^ lazOr [ p ])); } void push_down ( int p , int l , int r ){ if ( lazAd [ p ] != inf ){ updLaz ( lson , 1 , lazAd [ p ]); updLaz ( rson , 1 , lazAd [ p ]); lazAd [ p ] = inf ; } if ( lazOr [ p ]){ updLaz ( lson , 0 , lazOr [ p ]); updLaz ( rson , 0 , lazOr [ p ]); lazOr [ p ] = 0 ; } updSum ( lson , l , mid ); updSum ( rson , mid + 1 , r ); } void upd ( int p , int L , int R , int f , int v , int l , int r ){ if ( L <= l && r <= R ){ updLaz ( p , f , v ); updSum ( p , l , r ); return ; } push_down ( p , l , r ); if ( L <= mid ) upd ( lson , L , R , f , v , l , mid ); if ( R > mid ) upd ( rson , L , R , f , v , mid + 1 , r ); sum [ p ] = sum [ lson ] ^ sum [ rson ]; } int ask ( int p , int L , int R , int l , int r ){ if ( L <= l && r <= R ) return sum [ p ]; push_down ( p , l , r ); int ans = 0 ; if ( L <= mid ) ans ^= ask ( lson , L , R , l , mid ); if ( R > mid ) ans ^= ask ( rson , L , R , mid + 1 , r ); return ans ; } void upd_path ( int x , int y , int f , int v ){ while ( top [ x ] != top [ y ]){ if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); upd ( 1 , tid [ top [ x ]], tid [ x ], f , v , 1 , n ); x = faz [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); upd ( 1 , tid [ x ], tid [ y ], f , v , 1 , n ); } int ask_path ( int x , int y ){ int ans = 0 ; while ( top [ x ] != top [ y ]){ if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); ans ^= ask ( 1 , tid [ top [ x ]], tid [ x ], 1 , n ); x = faz [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); ans ^= ask ( 1 , tid [ x ], tid [ y ], 1 , n ); return ans ; } int main (){ scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , val + i ); for ( int i = 1 ; i < n ; i ++ ){ int u , v ; scanf ( \"%d%d\" , & u , & v ); addEdge ( u , v ); addEdge ( v , u ); } dfs1 ( 1 , 0 ); dfs2 ( 1 , 1 ); build ( 1 , 1 , n ); while ( m -- ){ int opt , s , t ; scanf ( \"%d%d%d\" , & opt , & s , & t ); if ( opt == 1 ) upd_path ( 1 , s , 0 , t ); else if ( opt == 2 ) upd_path ( 1 , s , 1 , t ); else puts ( ask_path ( 1 , s ) == t ? \"NO\" : \"YES\" ); } return 0 ; } 8. \u4f5c\u8005-\u9648\u946b \u00b6","title":"\u8ba1\u849c\u5ba2 39272 \u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#1","text":"\u8ba1\u849c\u5ba2 39272 Tree","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#2","text":"1 2 3 4 \u6709\u4e00\u68f5n\u4e2a\u8282\u70b9\u7684\u6811\uff0c\u70b9\u6709\u70b9\u6743\uff0c\u6709\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a 1 s t\uff1a\u5c06\u4ece\u8282\u70b91\u5230s\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u70b9\u6743|=t\uff1b 2 s t\uff1a\u5c06\u4ece\u8282\u70b91\u5230s\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u70b9\u6743&=t\uff1b 3 s t\uff1a\u8be2\u95ee\u8282\u70b91\u5230s\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u5f02\u6216\u548c\u662f\u5426\u7b49\u4e8et\u3002 1<=n<=1e5 1<=n<=1e5","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#3","text":"\u672c\u9898\u8003\u5bdf\u6811\u94fe\u5256\u5206\u7684\u57fa\u7840\u53ca\u7ebf\u6bb5\u6811\u7684\u6784\u9020\u3002","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#4","text":"\u76f4\u63a5\u6811\u5256\u540e\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u5f02\u6216\u548c\uff0c\u53d1\u73b0\u5f02\u6216\u548c\u6709\u5982\u4e0b\u6027\u8d28\uff1a \u82e5\u8be5\u4f4d\u4e3a1\uff0c\u8bf4\u660e\u533a\u95f4\u5185\u6709\u5947\u6570\u4e2a\u8be5\u4f4d\u4e3a1\u7684\u70b9\uff1b \u82e5\u8be5\u4f4d\u4e3a0\uff0c\u8bf4\u660e\u533a\u95f4\u5185\u6709\u5076\u6570\u4e2a\u8be5\u4f4d\u4e3a1\u7684\u70b9\u3002 or\u4e00\u4e2a\u6570\u4e4b\u540e\uff0c\u4f1a\u5c06\u539f\u672c\u4e3a0\u7684\u4f4d\u53d8\u4e3a1\uff1a \u82e5\u533a\u95f4\u957f\u5ea6\u4e3a\u5947\u6570\uff1a \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a1\uff0c\u5219\u6709\u5076\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u4ecd\u4e3a1\uff1b \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a0\uff0c\u5219\u6709\u5947\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u53d8\u4e3a1\uff1b \u7b49\u540c\u4e8e\u76f4\u63a5or\u8be5\u6570\u3002 \u82e5\u533a\u95f4\u957f\u5ea6\u4e3a\u5076\u6570\uff1a \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a1\uff0c\u5219\u6709\u5947\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u53d8\u4e3a0\uff1b \u82e5\u5f02\u6216\u548c\u8be5\u4f4d\u4e3a0\uff0c\u5219\u6709\u5076\u6570\u4e2a0\u53d8\u4e3a1\uff0c\u8be5\u4f4d\u4ecd\u4e3a0\u3002 \u7b49\u540c\u4e8eand\u8be5\u6570\u7684\u53cd\u3002 and\u4e00\u4e2a\u6570\u4e4b\u540e\uff0c\u4f1a\u5c06\u539f\u672c\u4e3a1\u7684\u4f4d\u53d8\u4e3a0\uff0c\u5982\u4e0a\u5206\u6790\u540e\u53d1\u73b0\uff0c\u65e0\u8bba\u533a\u95f4\u957f\u5ea6\u4e3a\u5947\u6570\u6216\u5076\u6570\uff0c\u90fd\u7b49\u540c\u4e8e\u76f4\u63a5and\u8be5\u6570\u3002 \u7efc\u4e0a\uff0c\u8bbe\u533a\u95f4or\u7684\u6570\u4e3au\uff0cand\u7684\u6570\u4e3av\uff0c\u5f02\u6216\u548c\u4e3asum\uff0c \u5219\u5f53\u533a\u95f4\u957f\u5ea6\u4e3a\u5947\u6570\u65f6\uff0csum=sum&v|u\uff1b \u957f\u5ea6\u4e3a\u5076\u6570\u65f6\uff0csum=sum&v&(~u)\u3002 \u800c\u5148and\u518dor\u548c\u5148or\u518dand\u662f\u6709\u533a\u522b\u7684\uff0c\u6240\u4ee5\u5f53\u5176\u4e2d\u4e00\u4e2a\u6807\u8bb0\u4fee\u6539\u65f6\uff0c\u53e6\u4e00\u4e2a\u6807\u8bb0\u90fd\u8981\u7ee7\u627f\u5176\u4fee\u6539\uff0c\u4ee5\u786e\u4fdd\u4e24\u8005\u662f\u7b49\u4ef7\u7684\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6 O(nlognlogn) O(nlognlogn) \u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#5","text":"\u56e0\u4e3a\u4f4d\u8fd0\u7b97\u4e0d\u6ee1\u8db3\u4ea4\u6362\u5f8b\uff0c\u6240\u4ee5\u5f53\u5176\u4e2d\u4e00\u4e2a\u6807\u8bb0\u4fee\u6539\u65f6\uff0c\u53e6\u4e00\u4e2a\u6807\u8bb0\u8981\u7ee7\u627f\u5176\u4fee\u6539\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#6","text":"https://www.cnblogs.com/ivanovcraft/p/9019090.html https://www.cnblogs.com/xyq0220/p/10945971.html","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 #include <bits/stdc++.h> #define sz(x) ((int)x.size()) #define mp(x, y) make_pair(x, y) using namespace std ; typedef long long ll ; const int MAXN = 100010 ; const int inf = ( 1 << 30 ) - 1 ; int n , m ; int cnt , tid [ MAXN ], rnk [ MAXN ]; int faz [ MAXN ], dep [ MAXN ], val [ MAXN ]; int siz [ MAXN ], son [ MAXN ], top [ MAXN ]; int tot , head [ MAXN ]; int sum [ MAXN << 2 ], lazAd [ MAXN << 2 ], lazOr [ MAXN << 2 ]; #define lson (p << 1) #define rson (p << 1 | 1) #define mid ((l + r) >> 1) struct Edge { int to , next ; } edges [ MAXN << 1 ]; void addEdge ( int x , int y ){ edges [ ++ tot ]. to = y ; edges [ tot ]. next = head [ x ]; head [ x ] = tot ; } void dfs1 ( int x , int fa ){ faz [ x ] = fa ; dep [ x ] = dep [ fa ] + 1 ; siz [ x ] = 1 ; for ( int i = head [ x ]; i ; i = edges [ i ]. next ){ int y = edges [ i ]. to ; if ( y == fa ) continue ; dfs1 ( y , x ); siz [ x ] += siz [ y ]; if ( siz [ y ] > siz [ son [ x ]]) son [ x ] = y ; } } void dfs2 ( int x , int tp ){ top [ x ] = tp ; tid [ x ] = ++ cnt ; rnk [ cnt ] = x ; if ( son [ x ]) dfs2 ( son [ x ], tp ); for ( int i = head [ x ]; i ; i = edges [ i ]. next ){ int y = edges [ i ]. to ; if ( y == faz [ x ] || y == son [ x ]) continue ; dfs2 ( y , y ); } } void build ( int p , int l , int r ){ lazAd [ p ] = inf ; lazOr [ p ] = 0 ; if ( l == r ){ sum [ p ] = val [ rnk [ l ]]; return ; } build ( lson , l , mid ); build ( rson , mid + 1 , r ); sum [ p ] = sum [ lson ] ^ sum [ rson ]; } void updLaz ( int p , int f , int v ){ if ( f ) lazAd [ p ] &= v , lazOr [ p ] &= v ; else lazOr [ p ] |= v , lazAd [ p ] |= v ; } void updSum ( int p , int l , int r ){ if (( r - l + 1 ) & 1 ) sum [ p ] = (( sum [ p ] & lazAd [ p ]) | lazOr [ p ]); else sum [ p ] = ( sum [ p ] & lazAd [ p ] & ( inf ^ lazOr [ p ])); } void push_down ( int p , int l , int r ){ if ( lazAd [ p ] != inf ){ updLaz ( lson , 1 , lazAd [ p ]); updLaz ( rson , 1 , lazAd [ p ]); lazAd [ p ] = inf ; } if ( lazOr [ p ]){ updLaz ( lson , 0 , lazOr [ p ]); updLaz ( rson , 0 , lazOr [ p ]); lazOr [ p ] = 0 ; } updSum ( lson , l , mid ); updSum ( rson , mid + 1 , r ); } void upd ( int p , int L , int R , int f , int v , int l , int r ){ if ( L <= l && r <= R ){ updLaz ( p , f , v ); updSum ( p , l , r ); return ; } push_down ( p , l , r ); if ( L <= mid ) upd ( lson , L , R , f , v , l , mid ); if ( R > mid ) upd ( rson , L , R , f , v , mid + 1 , r ); sum [ p ] = sum [ lson ] ^ sum [ rson ]; } int ask ( int p , int L , int R , int l , int r ){ if ( L <= l && r <= R ) return sum [ p ]; push_down ( p , l , r ); int ans = 0 ; if ( L <= mid ) ans ^= ask ( lson , L , R , l , mid ); if ( R > mid ) ans ^= ask ( rson , L , R , mid + 1 , r ); return ans ; } void upd_path ( int x , int y , int f , int v ){ while ( top [ x ] != top [ y ]){ if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); upd ( 1 , tid [ top [ x ]], tid [ x ], f , v , 1 , n ); x = faz [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); upd ( 1 , tid [ x ], tid [ y ], f , v , 1 , n ); } int ask_path ( int x , int y ){ int ans = 0 ; while ( top [ x ] != top [ y ]){ if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); ans ^= ask ( 1 , tid [ top [ x ]], tid [ x ], 1 , n ); x = faz [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); ans ^= ask ( 1 , tid [ x ], tid [ y ], 1 , n ); return ans ; } int main (){ scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , val + i ); for ( int i = 1 ; i < n ; i ++ ){ int u , v ; scanf ( \"%d%d\" , & u , & v ); addEdge ( u , v ); addEdge ( v , u ); } dfs1 ( 1 , 0 ); dfs2 ( 1 , 1 ); build ( 1 , 1 , n ); while ( m -- ){ int opt , s , t ; scanf ( \"%d%d%d\" , & opt , & s , & t ); if ( opt == 1 ) upd_path ( 1 , s , 0 , t ); else if ( opt == 2 ) upd_path ( 1 , s , 1 , t ); else puts ( ask_path ( 1 , s ) == t ? \"NO\" : \"YES\" ); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A239272/#8-","text":"","title":"8. \u4f5c\u8005-\u9648\u946b"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"\u8ba1\u849c\u5ba2 A1607 \u524d\u7f00\u7ebf\u6027\u57fa"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1607/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"\u8ba1\u849c\u5ba2 A1617 \u7ebf\u6bb5\u6811+\u4e8c\u5206\u56fe\u5339\u914dHall\u5b9a\u7406+\u5c3a\u53d6"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1617/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/","text":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0 \u00b6 POJ 1156 The Doors 2. \u9898\u610f\u7b80\u8ff0 \u00b6 \u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002 3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528 \u00b6 \u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def 4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0 \u00b6 \u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002 5. \u6280\u5de7\u548c\u5751\u70b9 \u00b6 \u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002 6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599 \u00b6 http://poj.org/problem?id=1556 7. \u5b8c\u6574\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; } 8. \u4f5c\u8005-\u6c5f\u7eea\u6862 \u00b6","title":"\u8ba1\u849c\u5ba2 A1998 \u5206\u5757+\u524d\u7f00\u548c+\u4e8c\u5206"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#1","text":"POJ 1156 The Doors","title":"1. \u9898\u76ee\u4e0e\u9898\u76ee\u540d\u79f0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#2","text":"\u5728\u4e00\u4e2a10*10\u5927\u5c0f\u7684\u7a7a\u95f4\u5185\u6709\u4e0d\u8d85\u8fc718\u4e2a\u5899\uff0c\u6bcf\u4e2a\u5899\u4e0a\u6709\u4e24\u4e2a\u95e8\u3002\u95ee\u4ece\u8d77\u70b9\uff080\uff0c5\uff09\u5230\u7ec8\u70b9\uff0810\uff0c5\uff09\u7684\u6700\u77ed\u8def\u5f84\u662f\u591a\u5c11\u3002","title":"2. \u9898\u610f\u7b80\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#3","text":"\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u7edd\u5bf9\u76f8\u4ea4\uff08\u5fc5\u987b\u4ea4\u53c9\u5230\u4e24\u8fb9\u51fa\u5934\u6210\u4e3a\u201cX\u201d\u5f62\u624d\u8ba4\u4e3a\u7edd\u5bf9\u76f8\u4ea4\uff09\uff0c\u6839\u636e\u9898\u610f\u5efa\u56fe\uff0c\u6700\u77ed\u8def","title":"3. \u4e3b\u8981\u77e5\u8bc6\u70b9\u53ca\u5176\u8fd0\u7528"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#4","text":"\u679a\u4e3e\u6bcf\u4e00\u4e2a\u95e8\u7684\u4e0a\u4e0b\u4e24\u4e2a\u7aef\u70b9\u3002\u5c06\u5b83\u4eec\u8fde\u7ebf\u3002\u6bcf\u4e2a\u95e8\u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u62bd\u8c61\u4e3a\u56fe\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\u3002\u5efa\u56fe\u65f6\u5224\u65ad\u4f4d\u4e8e\u4e24\u4e2a\u95e8\u4e4b\u95f4\u7684\u5899\u4f1a\u4e0d\u4f1a\u6321\u4f4f\u95e8\u3002\u5982\u679c\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u8ba4\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6743\u503c\u65e0\u7a77\u5927\u3002\u5982\u679c\u4e0d\u4f1a\u6321\u4f4f\uff0c\u90a3\u4e48\u7528\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4f5c\u4e3a\u56fe\u4e2d\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002","title":"4. \u5b8c\u6574\u89e3\u9898\u601d\u8def\u63cf\u8ff0"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#5","text":"\u679a\u4e3e\u7aef\u70b9\u65f6\uff0c\u540c\u4e00\u4e2a\u5899\u4e0a\u7684\u4e24\u4e2a\u95e8\u4e4b\u95f4\u5373\u4f7f\u6ca1\u6709\u88ab\u6321\u4f4f\u4e5f\u4e0d\u80fd\u76f8\u4e92\u8054\u901a\uff0c\u56e0\u4e3a\u8fd9\u4e0d\u7b26\u5408\u95ee\u9898\u7684\u5b9a\u4e49\u3002\u53ef\u4ee5\u4f7f\u7528\u5e73\u9762\u51e0\u4f55\u7684\u77e5\u8bc6\u5927\u5e45\u7b80\u5316\u672c\u9898\u4e2d\u5173\u4e8e\u7ebf\u6bb5\u76f8\u4ea4\u7684\u5224\u65ad\u3002","title":"5. \u6280\u5de7\u548c\u5751\u70b9"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#6","text":"http://poj.org/problem?id=1556","title":"6. \u53c2\u8003\u6587\u732e\u548c\u5b66\u4e60\u8d44\u6599"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <iostream> using namespace std ; const double INF = 1000000 ; const double eps = 1e-8 ; const int maxn = 1e3 + 3 ; struct point { double x , y ; point () {} point ( point a , point b ) { this -> x = b . x - a . x ; this -> y = b . y - a . y ; } point ( double a , double b ) { x = a ; y = b ; } } p [ maxn ]; double cross ( point a , point b ) { return ( a . x * b . y - a . y * b . x ); } double dist ( point a , point b ) { return sqrt (( a . x - b . x ) * ( a . x - b . x ) + ( a . y - b . y ) * ( a . y - b . y )); } bool judge ( point a , point b , point m , point n ) { if ( min ( a . x , b . x ) <= max ( m . x , n . x ) && min ( m . x , n . x ) <= max ( a . x , b . x ) && min ( a . y , b . y ) <= max ( m . y , n . y ) && min ( m . y , n . y ) <= max ( a . y , b . y ) ) { int cro1 = cross ( point ( a , m ), point ( a , b )) * cross ( point ( a , n ), point ( a , b )); int cro2 = cross ( point ( m , a ), point ( m , n )) * cross ( point ( m , b ), point ( m , n )); if ( cro1 <- eps && cro2 <- eps ) { return 1 ; } } return 0 ; } double d [ maxn ][ maxn ]; int main () { int n ; while ( scanf ( \"%d\" , & n ) && n !=- 1 ) { for ( int i = 0 ; i < n ; i ++ ) { double x ; scanf ( \"%lf\" , & x ); for ( int j = 1 ; j <= 4 ; j ++ ) { p [ i * 4 + j ]. x = x ; scanf ( \"%lf\" , & p [ i * 4 + j ]. y ); } } p [ 0 ] = point ( 0 , 5 ); p [ 4 * n + 1 ] = point ( 10 , 5 ); memset ( d , 0 , sizeof ( d )); for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = i + 1 ; j <= 4 * n + 1 ; j ++ ) { int l = ( i - 1 ) / 4 , r = ( j - 1 ) / 4 ; if ( i == 0 ) l = - 1 ; int flag = 1 ; if ( l == r ) { d [ i ][ j ] = d [ j ][ i ] = INF ; } else for ( int k = l + 1 ; k < r ; k ++ ) { if ( judge ( p [ 4 * k + 1 ], point ( p [ 4 * k + 1 ]. x , 0 ), p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 2 ], p [ 4 * k + 3 ], p [ i ], p [ j ])) { flag = 0 ; break ; } if ( judge ( p [ 4 * k + 4 ], point ( p [ 4 * k + 4 ]. x , 10 ), p [ i ], p [ j ])) { flag = 0 ; break ; } } d [ i ][ j ] = d [ j ][ i ] = ( flag ? dist ( p [ i ], p [ j ]) : INF ) ; } } for ( int i = 0 ; i <= 4 * n + 1 ; i ++ ) { for ( int j = 0 ; j <= 4 * n + 1 ; j ++ ) { for ( int k = 0 ; k <= 4 * n + 1 ; k ++ ) { d [ j ][ k ] = min ( d [ j ][ k ], d [ j ][ i ] + d [ i ][ k ]); } } } printf ( \"%.2f \\n \" , d [ 0 ][ 4 * n + 1 ]); } return 0 ; }","title":"7. \u5b8c\u6574\u4ee3\u7801"},{"location":"2019/%E8%AE%A1%E8%92%9C%E5%AE%A2/%E8%AE%A1%E8%92%9C%E5%AE%A2A1998/#8-","text":"","title":"8. \u4f5c\u8005-\u6c5f\u7eea\u6862"},{"location":"Base/","text":"\u5728\u6b64\u90e8\u5206\u6211\u4eec\u7ed9\u51fa\u4e86\u4ee5\u4e0b\u5e38\u7528\u7684\u57fa\u7840\u7b97\u6cd5\u548c\u57fa\u672c\u601d\u60f3 \u6392\u5e8f\u7b97\u6cd5 \u4e8c\u5206 \u9ad8\u7cbe\u5ea6\u8ba1\u7b97 \u524d\u7f00\u548c\u4e0e\u5dee\u5206 \u53cc\u6307\u9488 \u4f4d\u8fd0\u7b97 \u79bb\u6563\u5316 \u533a\u95f4\u5408\u5e76 \u8d2a\u5fc3","title":"Index"},{"location":"Base/%E6%9E%9A%E4%B8%BE/","text":"","title":"\u679a\u4e3e"},{"location":"Base/%E8%B4%AA%E5%BF%83/","text":"","title":"\u8d2a\u5fc3"},{"location":"Base/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","text":"","title":"\u5f52\u5e76\u6392\u5e8f"},{"location":"Base/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","text":"1. \u4efb\u52a1 \u00b6 \u5c06\u4e00\u4e2a\u4e71\u5e8f\u6570\u7ec4\u6309\u5347\u5e8f\u6392\u5e8f 2. \u63a5\u53e3 \u00b6 void quick_sort(int q[], int l, int r) \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O( N \\log N) O( N \\log N) q[] ....\u8981\u6392\u5e8f\u7684\u6570\u7ec4 l ......\u6392\u5e8f\u7684\u5de6\u533a\u95f4\u7aef\u70b9 r ......\u6392\u5e8f\u7684\u53f3\u533a\u95f4\u7aef\u70b9 3. \u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 void quick_sort ( int q [], int l , int r ) { if ( l >= r ) return ; int x = q [ l + r >> 1 ], i = l - 1 , j = r + 1 ; while ( i < j ){ while ( q [ ++ i ] < x ); while ( q [ -- j ] > x ); if ( i < j ) swap ( q [ i ], q [ j ]); } quick_sort ( q , l , j ); quick_sort ( q , j + 1 , r ); } 4. \u4f7f\u7528\u8303\u4f8b \u00b6 AcWing 785. \u5feb\u901f\u6392\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <bits/stdc++.h> using namespace std ; const int N = 100000 ; int q [ N ]; void quick_sort ( int q [], int l , int r ) { if ( l >= r ) return ; int x = q [ l + r >> 1 ], i = l - 1 , j = r + 1 ; while ( i < j ){ while ( q [ ++ i ] < x ); while ( q [ -- j ] > x ); if ( i < j ) swap ( q [ i ], q [ j ]); } quick_sort ( q , l , j ); quick_sort ( q , j + 1 , r ); } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & q [ i ]); quick_sort ( q , 0 , n - 1 ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%d \" , q [ i ]); return 0 ; } \u7f16\u8f91\u4fe1\u606f \u672c\u9875\u8d21\u732e\u8005\uff1a \u9c81\u660e\u7ff0 \u9875\u9762\u6700\u540e\u66f4\u65b0\u65f6\u95f4 : 2019/12/21","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"Base/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#1","text":"\u5c06\u4e00\u4e2a\u4e71\u5e8f\u6570\u7ec4\u6309\u5347\u5e8f\u6392\u5e8f","title":"1. \u4efb\u52a1"},{"location":"Base/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#2","text":"void quick_sort(int q[], int l, int r) \u65f6\u95f4\u590d\u6742\u5ea6\uff1a O( N \\log N) O( N \\log N) q[] ....\u8981\u6392\u5e8f\u7684\u6570\u7ec4 l ......\u6392\u5e8f\u7684\u5de6\u533a\u95f4\u7aef\u70b9 r ......\u6392\u5e8f\u7684\u53f3\u533a\u95f4\u7aef\u70b9","title":"2. \u63a5\u53e3"},{"location":"Base/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#3","text":"1 2 3 4 5 6 7 8 9 10 11 void quick_sort ( int q [], int l , int r ) { if ( l >= r ) return ; int x = q [ l + r >> 1 ], i = l - 1 , j = r + 1 ; while ( i < j ){ while ( q [ ++ i ] < x ); while ( q [ -- j ] > x ); if ( i < j ) swap ( q [ i ], q [ j ]); } quick_sort ( q , l , j ); quick_sort ( q , j + 1 , r ); }","title":"3. \u4ee3\u7801"},{"location":"Base/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#4","text":"AcWing 785. \u5feb\u901f\u6392\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <bits/stdc++.h> using namespace std ; const int N = 100000 ; int q [ N ]; void quick_sort ( int q [], int l , int r ) { if ( l >= r ) return ; int x = q [ l + r >> 1 ], i = l - 1 , j = r + 1 ; while ( i < j ){ while ( q [ ++ i ] < x ); while ( q [ -- j ] > x ); if ( i < j ) swap ( q [ i ], q [ j ]); } quick_sort ( q , l , j ); quick_sort ( q , j + 1 , r ); } int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & q [ i ]); quick_sort ( q , 0 , n - 1 ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%d \" , q [ i ]); return 0 ; } \u7f16\u8f91\u4fe1\u606f \u672c\u9875\u8d21\u732e\u8005\uff1a \u9c81\u660e\u7ff0 \u9875\u9762\u6700\u540e\u66f4\u65b0\u65f6\u95f4 : 2019/12/21","title":"4. \u4f7f\u7528\u8303\u4f8b"},{"location":"DP/","text":"","title":"Index"},{"location":"DP/%E5%8C%BA%E9%97%B4DP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //n \u5806\u77f3\u5b50\u6392\u6210\u2f00\u5217\uff0c\u6bcf\u5806\u77f3\u5b50\u6709\u4e00\u4e2a\u91cd\u91cf w[i] //\u6bcf\u6b21\u5408\u5e76\u53ef\u4ee5\u5408\u5e76\u76f8\u90bb\u7684\u4e24\u5806\u77f3\u5b50\uff0c\u2f00\u6b21\u5408\u5e76\u7684\u4ee3\u4ef7\u4e3a\u4e24\u5806\u2f6f\u2f26\u7684\u91cd\u91cf\u548c w[i]+w[i+1]\u3002 //\u95ee\u5b89\u6392\u600e\u6837\u7684\u5408\u5e76\u987a\u5e8f\uff0c\u80fd\u591f\u4f7f\u5f97\u603b\u5408\u5e76\u4ee3\u4ef7\u8fbe\u5230\u6700\u5927 long long w [ maxn ], n ; class IntervalDp { public : long long dp [ maxn ][ maxn ], sum [ maxn ]; //dp[i][j]\u8868\u793a\u628a\u7b2c i \u5806\u5230\u7b2c j \u5806\u7684\u77f3\u5b50\u5408\u5e76\u5728\u2f00\u8d77\u7684\u6700\u4f18\u503c //sum[i]\u4e3a\u524d i \u5806\u77f3\u5b50\u7684\u548c long long solve ( LL * w , LL n ) { //\u63a5\u53e3 for ( int i = 1 ; i <= n ; i ++ ){ sum [ i ] = sum [ i - 1 ] + w [ i ]; } for ( int len = 2 ; len <= n ; len ++ ){ for ( int i = 1 ; i <= n - len + 1 ; i ++ ){ int j = i + len - 1 ; for ( int k = i ; k <= j - 1 ; k ++ ){ dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k ] + dp [ k + 1 ][ j ] + sum [ j ] - sum [ i - 1 ]); } } } return dp [ 1 ][ n ]; } }; \u6574\u7406\u4eba \u8ba118-8 \u97a0\u6c38\u5168","title":"\u533a\u95f4 DP"},{"location":"DP/%E6%95%B0%E4%BD%8DDP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //(\u4e00\u5b9a\u8981\u628a dp \u65b9\u7a0b\u6240\u8868\u793a\u7684\u72b6\u6001\u8bbe\u597d\u518d\u8f6c\u79fb) //hdu2089 \u9898\u610f\uff1a\u533a\u95f4\u5185\u4e0d\u5305\u542b 62 \u548c 4 \u7684\u4e2a\u6570 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 25 ; int n , m ; class DigitDp { public : int dp [ N ][ 2 ], a [ N ]; ///dp[i][j]\u4ee3\u8868\u679a\u4e3e\u5230\u7b2c i \u4f4d\u524d\u4e00\u4f4d\u662f j \u7684\u65b9\u6848\u6570 int dfs ( int now , int pre , int limit ) { if ( ! now ) return 1 ; ///\u679a\u4e3e\u5230\u6700\u540e\u4e00\u4f4d\u540e\u5c31\u8981\u68c0\u67e5\u72b6\u6001\u8fd9\u91cc\u56e0\u4e3a\u679a\u4e3e\u7684\u8fc7\u7a0b \u4e2d\u5c31\u628a\u72b6\u6001\u68c0\u67e5\u5b8c\u4e86\u76f4\u63a5\u8fd4\u56de 1 if ( ! limit && ~ dp [ now ][ pre ]) ///\u5982\u679c\u5f53\u524d\u4f4d\u7684\u503c\u6ca1\u8fbe\u5230\u6700\u9ad8\u4e14\u6b21\u72b6\u6001\u5df2\u7ecf \u8bbf\u95ee\u8fc7 return dp [ now ][ pre ]; int up = limit ? a [ now ] : 9 , ans = 0 ; ///\u6839\u636e limit \u662f\u5426\u662f 1 \u51b3\u5b9a\u4e0b\u4e00\u4f4d\u6700\u591a 17 \u679a\u4e3e\u5230\u591a\u5c11 for ( int i = 0 ; i <= up ; i ++ ) { if (( pre && i == 2 ) || ( i == 4 )) ///\u5982\u679c\u524d\u4e00\u4f4d\u662f 6 \u4e14\u5f53\u524d\u4f4d\u662f 2 \u6216\u8005\u5f53 \u524d\u4f4d\u662f 4 \u76f4\u63a5\u8df3\u8fc7 continue ; ans += dfs ( now - 1 , i == 6 , i == up && limit ); ///\u7edf\u8ba1\u5f53\u524d\u72b6\u6001\u7684\u7b54\u6848 \u4e5f\u5c31\u662f dp \u7684\u8fc7\u7a0b } if ( ! limit ) ///\u5f53\u524d\u4f4d\u503c\u672a\u8fbe\u5230\u6700\u9ad8\u624d\u80fd\u8bb0\u5fc6\u5316 dp [ now ][ pre ] = ans ; return ans ; } int solve ( int num ) { ///\u62c6\u6570\u5b57 int cnt = 0 ; while ( num ) { a [ ++ cnt ] = num % 10 ; num /= 10 ; } memset ( dp , - 1 , sizeof dp ); ///\u521d\u59cb\u5316-1 \u7684\u539f\u56e0\u5c31\u662f\u56e0\u4e3a\u6709\u4e9b\u72b6\u6001\u7684\u65b9\u6848 \u6570\u53ef\u80fd\u662f 0 return dfs ( cnt , 0 , 1 ); } } dp ; int main () { while ( scanf ( \"%d%d\" , & n , & m ) && n + m ) { printf ( \"%d \\n \" , dp . solve ( m ) - dp . solve ( n - 1 )); } } \u6574\u7406\u4eba \u7f51\u7edc 18-2 \u5434\u56fd\u5e86","title":"\u6570\u4f4d DP"},{"location":"DP/%E6%9C%9F%E6%9C%9BDP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ( \u4e00\u822c\u662f\u6b63\u63a8 ) ///CF148D \u539f\u6765\u888b\u5b50\u91cc\u6709 w \u53ea\u767d\u9f20\u548c b \u53ea\u9ed1\u9f20 \u9f99\u548c\u738b\u5983\u8f6e\u6d41\u4ece\u888b\u5b50\u91cc\u6293\u8001\u9f20\u3002\u8c01\u5148\u6293\u5230\u767d \u8272\u8001\u5e08\u8c01\u5c31\u8d62\u3002 \u738b\u5983\u6bcf\u6b21\u6293\u4e00\u53ea\u8001\u9f20\uff0c\u9f99\u6bcf\u6b21\u6293\u5b8c\u4e00\u53ea\u8001\u9f20\u4e4b\u540e\u4f1a\u6709\u4e00\u53ea\u8001\u9f20 \u8dd1\u51fa\u6765\u3002 \u6bcf\u6b21\u6293\u8001\u9f20\u548c\u8dd1\u51fa\u6765\u7684\u8001\u9f20\u90fd\u662f\u968f\u673a\u7684\u3002 \u5982\u679c\u4e24\u4e2a\u4eba\u90fd\u6ca1\u6709\u6293\u5230\u767d\u8272 \u8001\u9f20\u5219\u9f99\u8d62\u3002\u738b\u5983\u5148\u6293\u3002 \u95ee\u738b\u5983\u8d62\u7684\u6982\u7387\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 1005 ; const int mod = 1e9 + 7 ; int w , b ; class Pdp { public : double dp [ maxn ][ maxn ]; ///\u8bbe dp[i][j]\u8868\u793a\u73b0\u5728\u8f6e\u5230\u738b\u5983\u6293\u65f6\u6709 i \u53ea\u767d\u9f20\uff0cj \u53ea \u9ed1\u9f20\uff0c\u738b\u5983\u8d62\u7684\u6982\u7387 void init () { ///\u521d\u59cb\u5316 for ( int i = 1 ; i <= w ; i ++ ) ///\u56e0\u4e3a\u90fd\u662f\u767d\u8272\u8001\u9f20\uff0c\u6293\u4e00\u6b21\u80af\u5b9a\u8d62\u4e86\u3002 dp [ i ][ 0 ] = 1 ; for ( int i = 0 ; i <= b ; i ++ ) ///\u56e0\u4e3a\u6ca1\u6709\u767d\u8272\u8001\u9f20\u4e86 dp [ 0 ][ i ] = 0 ; } void solve () { ///\u63a8\u51fa\u9012\u63a8\u516c\u5f0f for ( int i = 1 ; i <= w ; i ++ ) { for ( int j = 1 ; j <= b ; j ++ ) { if ( i + j == 0 ) continue ; dp [ i ][ j ] += i * 1.0 / ( i + j ); ///\u767d if ( j >= 3 ) dp [ i ][ j ] += ( j * 1.0 ) / ( i + j ) * ( j - 1 ) * 1.0 / ( i + j - 1 ) * ( j - 2 ) / ( i + j - 2 ) * dp [ i ][ j - 3 ]; ///\u9ed1\u9ed1\u9ed1 if ( j >= 2 ) dp [ i ][ j ] += ( j * 1.0 ) / ( i + j ) * ( j - 1 ) * 1.0 / ( i + j - 1 ) * ( i ) * 1.0 / ( i + j - 2 ) * dp [ i - 1 ][ j - 2 ]; ///\u9ed1\u9ed1\u767d } } } void printans () { ///\u8f93\u51fa\u7b54\u6848 printf ( \"%.10f \\n \" , dp [ w ][ b ]); } } dp ; int main () { while ( ~ scanf ( \"%d%d\" , & w , & b )) { dp . init (); dp . solve (); dp . printans (); } } \u6574\u7406\u4eba \u7f51\u7edc 18-2 \u5434\u56fd\u5e86","title":"\u671f\u671b DP"},{"location":"DP/%E6%A0%91%E5%BD%A2DP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ///\u6c42\u6811\u7684\u91cd\u5fc3 class TreeRoot { public : int sz [ maxn ], f [ maxn ], vis [ maxn ], root ; //sz[i] i \u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u5927\u5c0f // f[i] i \u8282\u70b9\u4e3a\u6839\u7684\u6700\u5927\u5b50\u6811\u5927\u5c0f //root \u91cd\u5fc3 n \u6811\u7684\u8282\u70b9\u6570\u91cf void solve ( int u ) { sz [ u ] = 1 ; f [ u ] = 0 ; vis [ u ] = 1 ; for ( int i = head [ u ]; i != - 1 ; i = edge [ i ]. next ) { int v = edge [ i ]. to ; if ( vis [ v ]) continue ; solve ( v ); sz [ u ] += sz [ v ]; f [ u ] = max ( f [ u ], sz [ v ]); 15 } f [ u ] = max ( f [ u ], n - sz [ u ]); if ( f [ root ] > f [ u ] || root == 0 ) root = u ; } int get_root ( int x ) { //\u63a5\u53e3 root = 0 ; memset ( vis , 0 , sizeof vis ); solve ( x ); return root ; } }; //\u6c42\u6811\u7684\u6700\u5927\u72ec\u7acb\u96c6 vector < int > G [ maxn ]; class TreeNum { public : int sz [ maxn ], dp [ maxn ][ 2 ], vis [ maxn ]; ///\u5b50\u6811\u5927\u5c0f\uff0cdp[i][0/1]\u8282\u70b9 i \u9009/\u4e0d\u9009\u7684\u5b50\u6811\u6700\u4f18\u89e3\uff0c\u91cd\u590d\u70b9\u4e0d\u8bbf\u95ee void dfs ( int x ) { vis [ x ] = 1 ; dp [ x ][ 0 ] = 0 ; dp [ x ][ 1 ] = 1 ; for ( int i = 0 ; i < G [ x ]. size (); i ++ ) { int y = G [ x ][ i ]; if ( vis [ y ]) continue ; dfs ( y ); dp [ x ][ 0 ] += max ( dp [ y ][ 0 ], dp [ y ][ 1 ]); dp [ x ][ 1 ] += dp [ y ][ 0 ]; } } int get_num ( int x ) { //\u63a5\u53e3 memset ( vis , 0 , sizeof vis ); solve ( x ); return max ( dp [ x ][ 0 ], dp [ x ][ 1 ]); } }; \u6574\u7406\u4eba \u8ba118-8 \u97a0\u6c38\u5168","title":"\u6811\u5f62 DP"},{"location":"DP/%E6%A6%82%E7%8E%87DP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // (\u4e00\u822c\u662f\u9006\u63a8)19 // ///POJ2096 \u4e00\u4e2a\u8f6f\u4ef6\u6709 s \u4e2a\u5b50\u7cfb\u7edf\uff0c\u4f1a\u4ea7\u751f n \u79cd bug // \u67d0\u4eba\u4e00\u5929\u53d1\u73b0\u4e00\u4e2a bug, // \u8fd9\u4e2a bug \u5c5e\u4e8e\u4e00\u4e2a\u5b50\u7cfb\u7edf\uff0c\u5c5e\u4e8e\u4e00\u4e2a\u5206\u7c7b // \u6bcf\u4e2a bug \u5c5e\u4e8e\u67d0\u4e2a\u5b50\u7cfb\u7edf\u7684\u6982\u7387\u662f 1 / // s, // \u5c5e\u4e8e\u67d0\u79cd\u5206\u7c7b\u7684\u6982\u7387\u662f 1 / n // \u95ee\u53d1\u73b0 n \u79cd bug, // \u6bcf\u4e2a\u5b50\u7cfb\u7edf\u90fd\u53d1\u73b0 bug \u7684\u5929\u6570\u7684\u671f\u671b\u3002 const int N = 1005 ; const int mod = 1e9 + 7 ; int n , m ; class Edp { public : double dp [ N ][ N ]; ///dp[i][j]\u8868\u793a\u5df2\u7ecf\u627e\u5230 i \u79cd bug,j \u4e2a\u7cfb\u7edf\u7684 bug\uff0c\u8fbe\u5230\u76ee\u6807\u72b6 \u6001\u7684\u5929\u6570\u7684\u671f\u671b void init () { ///\u521d\u59cb\u5316 dp [ n ][ m ] = 0 ; ///dp[n][m]=0; } void solve () { ///\u63a8\u5bfc\u51fa\u9012\u63a8\u65b9\u7a0b\uff0c\u6bcf\u4e00\u79cd\u72b6\u6001\u7684\u6982\u7387\u4e0d\u8981\u7b97\u9519(\u8981\u7528 double) for ( int i = n ; i >= 0 ; i -- ) { for ( int j = m ; j >= 0 ; j -- ) { if ( i == n && j == m ) continue ; double p1 = ( i * j ) * 1.0 / ( n * m ); double p2 = (( n - i ) * j ) * 1.0 / ( n * m ); double p3 = ( i * ( m - j )) * 1.0 / ( n * m ); double p4 = (( n - i ) * ( m - j )) * 1.0 / ( n * m ); dp [ i ][ j ] = ( dp [ i + 1 ][ j ] * p2 + dp [ i ][ j + 1 ] * p3 + dp [ i + 1 ][ j + 1 ] * p4 + 1.0 ) / ( 1 - p1 ); } } } void printans () { ///\u8f93\u51fa printf ( \"%.4f \\n \" , dp [ 0 ][ 0 ]); ///\u8981\u6c42\u7684\u7b54\u6848 } } dp ; \u6574\u7406\u4eba \u7f51\u7edc 18-2 \u5434\u56fd\u5e86","title":"\u6982\u7387 DP"},{"location":"DP/%E7%8A%B6%E5%8E%8BDP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ///hdu5418 \u9898\u610f\uff1an \u4e2a\u57ce\u5e02\uff0cm \u6761\u65e0\u5411\u8fb9\uff0c\u95ee\u4ece 1 \u53f7\u57ce\u5e02\u7ecf\u8fc7\u6240\u6709\u57ce\u5e02\u5728\u56de\u5230 1 \u53f7\u57ce\u5e02\u7684 \u6700\u5c11\u82b1\u8d39 #include <bits/stdc++.h> using namespace std ; const int maxn = 2e6 + 6 ; const int N = 20 ; ///\u57ce\u5e02\u70b9\u6570 const int inf = 0x3f3f3f3f ; const int mod = 1e9 + 7 ; int n , m ; ///\u57ce\u5e02\u6570\u91cf\uff0c\u8fb9\u6570\u91cf int a [ N ][ N ]; ///\u90bb\u63a5\u77e9\u9635\u5b58\u56fe class State { public : int dp [ N ][( 1 << N ) + 10 ]; ///dp[i][S] \u4e3a\u5f53\u524d\u5728 i \u8d70\u8fc7\u7684\u96c6\u5408\u4e3a S \u7684\u82b1\u8d39, int solve () { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ][ j ] = min ( a [ i ][ j ], a [ i ][ k ] + a [ k ][ j ]); } } } ///floyd \u6c42\u4e24\u70b9\u95f4\u6700\u77ed\u8ddd\u79bb memset ( dp , inf , sizeof dp ); dp [ 0 ][ 1 ] = 0 ; int limit = 1 << n ; for ( int S = 0 ; S < limit ; S ++ ) { for ( int i = 0 ; i < n ; i ++ ) if (( 1 << i ) & S ) { ///\u8d77\u70b9 for ( int j = 0 ; j < n ; j ++ ) if ( ! (( 1 << j ) & S )) { ///\u7ec8\u70b9 dp [ j ][ S | ( 1 << j )] = min ( dp [ j ][ S | ( 1 << j )], dp [ i ][ S ] + a [ i ][ j ]); } } } int ans = inf ; 14 for ( int i = 0 ; i < n ; i ++ ) { ans = min ( ans , dp [ i ][ limit - 1 ] + a [ 0 ][ i ]); } return ans ; } } zdp ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) a [ i ][ j ] = ( i == j ? 0 : inf ); } for ( int i = 1 ; i <= m ; i ++ ) { int u , v , w ; scanf ( \"%d%d%d\" , & u , & v , & w ); u -- ; v -- ; ///\u8fb9\u4ece 0 \u5f00\u59cb\u8ba1\u6570\uff0c\u65b9\u4fbf\u8f6c\u79fb a [ u ][ v ] = min ( a [ u ][ v ], w ); ///\u907f\u514d\u6709\u91cd\u8fb9 a [ v ][ u ] = a [ u ][ v ]; } printf ( \"%d \\n \" , zdp . solve ()); } } \u6574\u7406\u4eba \u8ba118-8 \u97a0\u6c38\u5168","title":"\u72b6\u6001\u538b\u7f29DP"},{"location":"DP/%E8%83%8C%E5%8C%85DP/","text":"","title":"\u80cc\u5305DP"},{"location":"Data_Structure/","text":"","title":"Index"},{"location":"Data_Structure/RMQ/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 //poj3264 \u9759\u6001\u533a\u95f4\u6700\u5927\u503c\u51cf\u6700\u5c0f\u503c #include <map> #include <cmath> #include <vector> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; #define LL long long const int maxn = 1e5 + 7 ; const int mod = 99991 ; const int INF = 0x3f3f3f3f ; int MIN [ maxn << 2 ], MAX [ maxn << 2 ]; class RMQ { public : #define lson l, m, rt << 1 #define rson m + 1, r, rt << 1 | 1 void push_up ( int rt ) { MIN [ rt ] = min ( MIN [ rt << 1 ], MIN [ rt << 1 | 1 ]); MAX [ rt ] = max ( MAX [ rt << 1 ], MAX [ rt << 1 | 1 ]); } void build ( int l , int r , int rt ) { if ( l == r ) { scanf ( \"%d\" , & MIN [ rt ]); MAX [ rt ] = MIN [ rt ]; return ; } int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); push_up ( rt ); } int query_min ( int L , int R , int l , int r , int rt ) { 26 if ( L <= l && r <= R ) { return MIN [ rt ]; } int IMIN = INF ; int m = ( l + r ) >> 1 ; if ( L <= m ) IMIN = min ( IMIN , query_min ( L , R , lson )); if ( R > m ) IMIN = min ( IMIN , query_min ( L , R , rson )); return IMIN ; } int query_max ( int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return MAX [ rt ]; } int IMAX = 0 ; int m = ( l + r ) >> 1 ; if ( L <= m ) IMAX = max ( IMAX , query_max ( L , R , lson )); if ( R > m ) IMAX = max ( IMAX , query_max ( L , R , rson )); return IMAX ; } } rmq ; int main () { int n , q ; while ( ~ scanf ( \"%d%d\" , & n , & q )) { rmq . build ( 1 , n , 1 ); while ( q -- ) { int l , r ; scanf ( \"%d%d\" , & l , & r ); printf ( \"%d \\n \" , rmq . query_max ( l , r , 1 , n , 1 ) - rmq . query_min ( l , r , 1 , n , 1 )); } } return 0 ; } \u6ce8\uff1a\u8fd9\u662f\u57fa\u4e8e\u7ebf\u6bb5\u6811\u5b9e\u73b0 RMQ\uff0c\u5b83\u652f\u6301\u52a8\u6001 RMQ \u95ee\u9898\u7684\u6c42\u89e3\uff0c\u81f3\u4e8e\u533a\u95f4\u4fee\u6539\u7684\u4ee3\u7801\uff0c\u8bf7\u8be6 \u89c1\u7ebf\u6bb5\u6811\u6a21\u677f\u3002 \u6574\u7406\u4eba\uff1a\u8ba1 18-9 \u80e1\u5c0f\u6587","title":"RMQ"},{"location":"Data_Structure/ST/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //\u6d1b\u8c37 p3865 \u9898\u610f\uff1a\u67e5\u8be2\u9759\u6001\u533a\u95f4\u6700\u5927\u503c #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> 24 using namespace std ; #define LL long long const int maxn = 1e5 + 7 ; int dp [ maxn ][ 30 ]; int a [ maxn ]; class ST { public : void init_ST ( int n ) { memset ( dp , 0 , sizeof ( dp )); for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ][ 0 ] = a [ i ]; } for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; i ++ ) { dp [ i ][ j ] = max ( dp [ i ][ j - 1 ], dp [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } int query ( int l , int r ) { int k = log ( r - l + 1.0 ) / log ( 2.0 ); return max ( dp [ l ][ k ], dp [ r - ( 1 << k ) + 1 ][ k ]); } } st ; int main () { int n , m ; while ( ~ scanf ( \"%d%d\" , & n , & m )) { for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); } st . init_ST ( n ); while ( m -- ) { int l , r ; scanf ( \"%d%d\" , & l , & r ); printf ( \"%d \\n \" , st . query ( l , r )); } } return 0 ; } \u6574\u7406\u4eba \u8ba118-9 \u80e1\u5c0f\u6587","title":"ST\u8868"},{"location":"Data_Structure/%E5%88%86%E5%9D%97/","text":"1 2 HDU3468 \u9898\u610f\uff1an \u4e2a\u6570\uff0cq \u6b21\u8be2\u95ee\u5417\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa\u4e00\u4e2a\u5b57\u6bcd s\uff0c\u82e5 s = \u2018C\u2019\uff0c\u5219\u7ed9\u51fa\u4e00\u7ec4 x\uff0c y\uff0cz \u5c06[x, y]\u4e2d\u6240\u6709\u6570\u52a0\u4e0a z\u3002\u82e5 s = \u2018Q\u2019\uff0c\u5219\u7ed9\u51fa\u4e00\u7ec4 x\uff0cy\uff0c\u95ee[x, y]\u7684\u533a\u95f4\u548c\u662f\u591a\u5c11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> using namespace std ; const int N = 1e5 + 7 ; typedef long long ll ; 42 class Block { public : int pos [ N ], L [ N ], R [ N ], block , num , n , m ; ll add [ N ], a [ N ], sum [ N ]; void build () //\u521d\u59cb\u5316 { block = sqrt ( n ); num = block ; if ( n % block ) num ++ ; //num \u8868\u793a\u5757\u7684\u4e2a\u6570\uff0cblock \u8868\u793a\u5757\u7684\u5927\u5c0f\u3002 for ( int i = 1 ; i <= num ; i ++ ) { L [ i ] = ( i - 1 ) * block + 1 ; //\u8be5\u5757\u5de6\u7aef\u70b9\u4f4d\u7f6e R [ i ] = i * block ; //\u8be5\u5757\u53f3\u7aef\u70b9\u4f4d\u7f6e } R [ num ] = n ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = L [ i ]; j <= R [ i ]; j ++ ) { pos [ j ] = i ; //\u7b2c\u51e0\u4e2a\u5757 sum [ i ] += a [ j ]; //\u5757\u7684\u533a\u95f4\u548c add [ j ] = 0 ; //\u589e\u91cf\u6807\u8bb0 } } } void change ( int l , int r , ll d ) //\u4fee\u6539\u64cd\u4f5c { int p = pos [ l ]; int q = pos [ r ]; if ( p == q ) { for ( int i = l ; i <= r ; i ++ ) a [ i ] += d ; sum [ p ] += ( r - l + 1 ) * d ; } else { for ( int i = p + 1 ; i <= q - 1 ; i ++ ) add [ i ] += d ; for ( int i = l ; i <= R [ p ]; i ++ ) a [ i ] += d ; sum [ p ] += ( R [ p ] - l + 1 ) * d ; for ( int i = L [ q ]; i <= r ; i ++ ) 43 a [ i ] += d ; sum [ q ] += ( r - L [ q ] + 1 ) * d ; } } ll ask ( int l , int r ) //\u67e5\u8be2\u64cd\u4f5c { int p = pos [ l ]; int q = pos [ r ]; ll ans = 0 ; if ( p == q ) { for ( int i = l ; i <= r ; i ++ ) ans += a [ i ]; ans += ( r - l + 1 ) * add [ p ]; } else { for ( int i = p + 1 ; i <= q - 1 ; i ++ ) ans += sum [ i ] + add [ i ] * ( R [ i ] - L [ i ] + 1 ); for ( int i = l ; i <= R [ p ]; i ++ ) ans += a [ i ]; ans += add [ p ] * ( R [ p ] - l + 1 ); for ( int i = L [ q ]; i <= r ; i ++ ) ans += a [ i ]; ans += add [ q ] * ( r - L [ q ] + 1 ); } return ans ; } } q ; int main () { scanf ( \"%d %d\" , & q . n , & q . m ); for ( int i = 1 ; i <= q . n ; i ++ ) scanf ( \"%lld\" , & q . a [ i ]); q . build (); while ( q . m -- ) { char c ; int x , y ; ll z ; scanf ( \" %c\" , & c ); if ( c == 'Q' ) { scanf ( \"%d %d\" , & x , & y ); printf ( \"%lld \\n \" , q . ask ( x , y )); 44 } else { scanf ( \"%d %d %lld\" , & x , & y , & z ); q . change ( x , y , z ); } } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u8463\u6587\u777f","title":"\u5206\u5757\u7b97\u6cd5"},{"location":"Data_Structure/%E6%89%AB%E6%8F%8F%E7%BA%BF/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include <bits/stdc++.h> using namespace std ; #define rep(i, j, k) for (int i = j; i <= k; i++) #define debug puts(\"*\"); const int N = 220 ; int n , cnt , t = 1 ; struct node { int l , r , cnt ; double len ; } tree [ N << 2 ]; struct knode { double x1 , y1 , y2 ; int k ; friend bool operator < ( knode a , knode b ) { return a . x1 < b . x1 ; } } line [ N ]; double raw [ N ], b [ N ], val [ N ]; void discrete () { sort ( raw + 1 , raw + 2 * n + 1 ); // rep(i,1,2*n)cout<<raw[i]<<\" \";puts(\"\"); rep ( i , 1 , 2 * n ) if ( i == 1 || raw [ i ] != raw [ i - 1 ]) b [ ++ cnt ] = raw [ i ]; // rep(i,1,cnt)cout<<b[i]<<\" \"; } int findx ( double x ) { return lower_bound ( b + 1 , b + cnt + 1 , x ) - b ; } void pushup ( int rt , int l , int r ) { if ( tree [ rt ]. cnt ) { tree [ rt ]. len = b [ r + 1 ] - b [ l ]; } else if ( l != r ) { tree [ rt ]. len = tree [ rt << 1 ]. len + tree [ rt << 1 | 1 ]. len ; } else tree [ rt ]. len = 0 ; return ; } void build ( int rt , int l , int r ) { tree [ rt ]. l = l , tree [ rt ]. r = r ; tree [ rt ]. len = 0.0 ; tree [ rt ]. cnt = 0 ; // cout<<l<<\" \"<<r<<endl; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( rt << 1 , l , mid ); build ( rt << 1 | 1 , mid + 1 , r ); } void update ( int rt , int l , int r , int x ) { if ( l <= tree [ rt ]. l && tree [ rt ]. r <= r ) { tree [ rt ]. cnt += x ; pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); return ; } int mid = ( tree [ rt ]. l + tree [ rt ]. r ) >> 1 ; ///2 if ( l <= mid ) update ( rt << 1 , l , r , x ); if ( r > mid ) update ( rt << 1 | 1 , l , r , x ); pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); } int main () { while ( ~ scanf ( \"%d\" , & n )) { if ( ! n ) break ; cnt = 0 ; /// 1 rep ( i , 1 , n ) { double x1 , y1 , x2 , y2 ; scanf ( \"%lf%lf%lf%lf\" , & x1 , & y1 , & x2 , & y2 ); raw [ i * 2 - 1 ] = y1 , raw [ i * 2 ] = y2 ; line [ i * 2 - 1 ]. x1 = x1 , line [ i * 2 - 1 ]. y1 = y1 , line [ i * 2 - 1 ]. y2 = y2 ; line [ i * 2 - 1 ]. k = 1 ; line [ i * 2 ]. x1 = x2 , line [ i * 2 ]. y1 = y1 , line [ i * 2 ]. y2 = y2 ; line [ i * 2 ]. k = - 1 ; } discrete (); sort ( line + 1 , line + 2 * n + 1 ); double ans = 0 ; build ( 1 , 1 , cnt ); rep ( i , 1 , 2 * n ) { ans += tree [ 1 ]. len * ( line [ i ]. x1 - line [ i - 1 ]. x1 ); update ( 1 , findx ( line [ i ]. y1 ), findx ( line [ i ]. y2 ) - 1 , line [ i ]. k ); } printf ( \"Test case #%d \\n Total explored area: %.2lf \\n\\n \" , t ++ , ans ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u6768\u777f","title":"\u626b\u63cf\u7ebf"},{"location":"Data_Structure/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%841/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 //\u6d1b\u8c37 p3368 \u533a\u95f4\u66f4\u65b0\uff0c\u5355\u70b9\u67e5\u8be2 #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; #define LL long long const int maxn = 5e5 + 7 ; LL C [ maxn ]; int n , m ; class BITree { public : int lowbit ( int x ) { return x & ( - x ); } void update ( int x , LL y ) { for ( int i = x ; i <= n ; i += lowbit ( i )) { C [ i ] += y ; } } LL query ( int x ) { LL ans = 0 ; for ( int i = x ; i > 0 ; i -= lowbit ( i )) { ans += C [ i ]; } return ans ; } } bitree ; int main () { while ( ~ scanf ( \"%d%d\" , & n , & m )) { memset ( C , 0 , sizeof ( C )); LL temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { LL x ; scanf ( \"%lld\" , & x ); bitree . update ( i , x - temp ); temp = x ; } while ( m -- ) { int opt ; scanf ( \"%d\" , & opt ); if ( opt == 1 ) { int x , y ; LL k ; scanf ( \"%d%d%lld\" , & x , & y , & k ); bitree . update ( x , k ); bitree . update ( y + 1 , - k ); } else { int x ; scanf ( \"%d\" , & x ); printf ( \"%lld \\n \" , bitree . query ( x )); } } } return 0 ; } \u6574\u7406\u4eba \u8ba118-9 \u80e1\u5c0f\u6587","title":"\u4e00\u7ef4\u6811\u72b6\u6570\u7ec4"},{"location":"Data_Structure/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%842/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 //hdu1892 \u5355\u70b9\u66f4\u65b0\uff0c\u533a\u95f4\u6c42\u548c #include <map> #include <cmath> #include <vector> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; #define LL long long const int maxn = 1010 ; const int mod = 99991 ; 22 const int INF = 0x3f3f3f3f ; int c [ maxn ][ maxn ]; class BITree_2 { public : int lowbit ( int x ) { return x & ( - x ); } void update ( int x , int y , int val ) { for ( int i = x ; i <= 1001 ; i += lowbit ( i )) { for ( int j = y ; j <= 1001 ; j += lowbit ( j )) { c [ i ][ j ] += val ; } } } int query ( int x , int y ) { int ans = 0 ; for ( int i = x ; i > 0 ; i -= lowbit ( i )) { for ( int j = y ; j > 0 ; j -= lowbit ( j )) { ans += c [ i ][ j ]; } } return ans ; } } bitree_2 ; int main () { int T ; scanf ( \"%d\" , & T ); int cas = 1 ; while ( T -- ) { int Q ; scanf ( \"%d\" , & Q ); printf ( \"Case %d: \\n \" , cas ++ ); memset ( c , 0 , sizeof ( c )); while ( Q -- ) { char c ; scanf ( \" %c\" , & c ); if ( c == 'S' ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); x1 ++ , y1 ++ , x2 ++ , y2 ++ ; 23 if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); printf ( \"%d \\n \" , bitree_2 . query ( x2 , y2 ) - bitree_2 . query ( x2 , y1 - 1 ) - bitree_2 . query ( x1 - 1 , y2 ) + bitree_2 . query ( x1 - 1 , y1 - 1 ) + ( x2 - x1 + 1 ) * ( y2 - y1 + 1 )); } else if ( c == 'A' ) { int x , y , val ; scanf ( \"%d%d%d\" , & x , & y , & val ); x ++ , y ++ ; bitree_2 . update ( x , y , val ); } else if ( c == 'D' ) { int x , y , val ; scanf ( \"%d%d%d\" , & x , & y , & val ); x ++ , y ++ ; int temp = bitree_2 . query ( x , y ) - bitree_2 . query ( x , y - 1 ) - bitree_2 . query ( x - 1 , y ) + bitree_2 . query ( x - 1 , y - 1 ); temp ++ ; temp = min ( temp , val ); bitree_2 . update ( x , y , - temp ); } else { int x1 , y1 , x2 , y2 , val ; scanf ( \"%d%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 , & val ); x1 ++ , y1 ++ , x2 ++ , y2 ++ ; int temp = bitree_2 . query ( x1 , y1 ) - bitree_2 . query ( x1 , y1 - 1 ) - bitree_2 . query ( x1 - 1 , y1 ) + bitree_2 . query ( x1 - 1 , y1 - 1 ); temp ++ ; temp = min ( temp , val ); bitree_2 . update ( x1 , y1 , - temp ); bitree_2 . update ( x2 , y2 , temp ); } } } return 0 ; } \u6574\u7406\u4eba \u8ba118-9 \u80e1\u5c0f\u6587","title":"\u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/","text":"\u4f8b\u4e00\u3001\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728. \u00b6 ///\u6d1b\u8c37 P3806 \u7ed9\u5b9a\u4e00\u9897 n \u4e2a\u7ed3\u70b9\u7684\u65e0\u6839\u6811,\u6709 m \u6b21\u8be2\u95ee,\u6bcf\u6b21\u8be2\u95ee\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728. \u601d\u60f3: \u7528\u6876\u8bb0\u5f55\u8def\u5f84,\u5224\u65ad\u662f\u5426\u5b58\u5728\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9 \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle() \u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans[] \u6570\u7ec4 \u6a21\u5757\u8bf4\u660e: 1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570 Root.getroot() \u00b6 \u8f93\u5165 : \u4f7f\u7528 Root.getroot(u,fa,sum) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9, sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927\u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt 2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis() \u00b6 \u8f93\u5165\uff1a\u4f7f\u7528 CalDis.caldis(int u,int fa) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa : \u5f97\u5230 di[] \u6570\u7ec4, dis[] \u6570\u7ec4\u5927\u5c0f\u4e3a tp ,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[] \u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6 3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle() \u00b6 \u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans[] \u6570\u7ec4,,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f 4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz() \u00b6 \u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9 5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve() \u00b6 \u8f93\u5165 : \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans[] \u6570\u7ec4,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K [ amn ]; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; 48 calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > ( int ) 1e7 ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 bool jg [( int ) 1e7 + 1 ]; int ans [ amn ]; class SovleDis { public : CalDis cd ; queue < int > bk ; void sovle ( int u ) { jg [ 0 ] = 1 ; bk . push ( 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; 49 if ( vis [ v ]) continue ; cd . init ( v , w ); cd . caldis ( v , u ); for ( int j = 1 ; j <= cd . tp ; j ++ ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( K [ k ] >= cd . di [ j ]) ans [ k ] += jg [ K [ k ] - cd . di [ j ]]; } } for ( int j = 1 ; j <= cd . tp ; j ++ ) { jg [ cd . di [ j ]] = 1 ; bk . push ( cd . di [ j ]); } } while ( bk . size ()) { jg [ bk . front ()] = 0 ; bk . pop (); } } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; s . sovle ( u ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ]) continue ; rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d%d\" , & n , & m ); 50 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d\" , & K [ i ]); } df . sovle (); for ( int i = 1 ; i <= m ; i ++ ) { if ( ans [ i ]) printf ( \"AYE \\n \" ); else printf ( \"NAY \\n \" ); } } \u4f8b\u4e8c\u3001\u6811\u4e0a\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e K \u7684\u70b9\u5bf9\u6570\u91cf \u00b6 ///\u6d1b\u8c37 P4178 \u7ed9\u5b9a\u4e00\u68f5 n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u6761\u8fb9\u6709\u8fb9\u6743\uff0c\u6c42\u51fa\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6570\u91cf\u3002 \u601d\u60f3: \u7528\u5bb9\u65a5\u548c\u53cc\u6307\u9488\u8bb0\u5f55\u8def\u5f84,\u8ba1\u7b97\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6709\u591a\u5c11\u4e2a. \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle()\u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans \u6a21\u5757\u8bf4\u660e: 1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570 Root.getroot() \u00b6 \u8f93\u5165: \u4f7f\u7528 Root.getroot(u,fa,sum),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3au\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927 \u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt 2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis() \u00b6 \u8f93\u5165: \u4f7f\u7528 CalDis.caldis(int u,int fa),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230 di[]\u6570\u7ec4,di[]\u6570\u7ec4\u5927\u5c0f\u4e3a tp,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[]\u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6 3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle() \u00b6 \u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u,int fa,int w),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,w \u4e3a fa \u5230 u \u7684 \u8fb9\u6743 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f 4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz() \u00b6 \u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u),u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9 5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve() \u00b6 \u8f93\u5165: \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K ; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } 52 maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > K ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 int ans ; class SovleDis { public : CalDis cd ; int sovle ( int u , int fa , int w ) { cd . init ( u , w ); cd . caldis ( u , fa ); sort ( cd . di + 1 , cd . di + 1 + cd . tp ); int l = 1 , r = cd . tp , ans = 0 ; while ( l < r ) { if ( cd . di [ l ] + cd . di [ r ] <= K ) { ans += r - l ; l ++ ; } else r -- ; 53 } return ans ; } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; ans += s . sovle ( u , - 1 , 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ]) continue ; ans -= s . sovle ( v , u , w ); rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } ans = 0 ; scanf ( \"%d\" , & K ); df . sovle (); printf ( \"%d \\n \" , ans ); } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u8499\u665f\u7ef4","title":"\u70b9\u5206\u6cbb"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#k","text":"///\u6d1b\u8c37 P3806 \u7ed9\u5b9a\u4e00\u9897 n \u4e2a\u7ed3\u70b9\u7684\u65e0\u6839\u6811,\u6709 m \u6b21\u8be2\u95ee,\u6bcf\u6b21\u8be2\u95ee\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728. \u601d\u60f3: \u7528\u6876\u8bb0\u5f55\u8def\u5f84,\u5224\u65ad\u662f\u5426\u5b58\u5728\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9 \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle() \u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans[] \u6570\u7ec4 \u6a21\u5757\u8bf4\u660e:","title":"\u4f8b\u4e00\u3001\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728."},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#1-rootgetroot","text":"\u8f93\u5165 : \u4f7f\u7528 Root.getroot(u,fa,sum) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9, sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927\u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt","title":"1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570Root.getroot()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#2-caldiscaldis","text":"\u8f93\u5165\uff1a\u4f7f\u7528 CalDis.caldis(int u,int fa) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa : \u5f97\u5230 di[] \u6570\u7ec4, dis[] \u6570\u7ec4\u5927\u5c0f\u4e3a tp ,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[] \u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6","title":"2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#3-sovledissovle","text":"\u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans[] \u6570\u7ec4,,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f","title":"3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#4-dfzdfz","text":"\u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9","title":"4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#5-dfzsolve","text":"\u8f93\u5165 : \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans[] \u6570\u7ec4,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K [ amn ]; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; 48 calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > ( int ) 1e7 ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 bool jg [( int ) 1e7 + 1 ]; int ans [ amn ]; class SovleDis { public : CalDis cd ; queue < int > bk ; void sovle ( int u ) { jg [ 0 ] = 1 ; bk . push ( 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; 49 if ( vis [ v ]) continue ; cd . init ( v , w ); cd . caldis ( v , u ); for ( int j = 1 ; j <= cd . tp ; j ++ ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( K [ k ] >= cd . di [ j ]) ans [ k ] += jg [ K [ k ] - cd . di [ j ]]; } } for ( int j = 1 ; j <= cd . tp ; j ++ ) { jg [ cd . di [ j ]] = 1 ; bk . push ( cd . di [ j ]); } } while ( bk . size ()) { jg [ bk . front ()] = 0 ; bk . pop (); } } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; s . sovle ( u ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ]) continue ; rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d%d\" , & n , & m ); 50 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d\" , & K [ i ]); } df . sovle (); for ( int i = 1 ; i <= m ; i ++ ) { if ( ans [ i ]) printf ( \"AYE \\n \" ); else printf ( \"NAY \\n \" ); } }","title":"5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#k_1","text":"///\u6d1b\u8c37 P4178 \u7ed9\u5b9a\u4e00\u68f5 n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u6761\u8fb9\u6709\u8fb9\u6743\uff0c\u6c42\u51fa\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6570\u91cf\u3002 \u601d\u60f3: \u7528\u5bb9\u65a5\u548c\u53cc\u6307\u9488\u8bb0\u5f55\u8def\u5f84,\u8ba1\u7b97\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6709\u591a\u5c11\u4e2a. \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle()\u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans \u6a21\u5757\u8bf4\u660e:","title":"\u4f8b\u4e8c\u3001\u6811\u4e0a\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e K \u7684\u70b9\u5bf9\u6570\u91cf"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#1-rootgetroot_1","text":"\u8f93\u5165: \u4f7f\u7528 Root.getroot(u,fa,sum),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3au\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927 \u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt","title":"1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570 Root.getroot()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#2-caldiscaldis_1","text":"\u8f93\u5165: \u4f7f\u7528 CalDis.caldis(int u,int fa),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230 di[]\u6570\u7ec4,di[]\u6570\u7ec4\u5927\u5c0f\u4e3a tp,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[]\u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6","title":"2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#3-sovledissovle_1","text":"\u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u,int fa,int w),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,w \u4e3a fa \u5230 u \u7684 \u8fb9\u6743 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f","title":"3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#4-dfzdfz_1","text":"\u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u),u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9","title":"4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#5-dfzsolve_1","text":"\u8f93\u5165: \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K ; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } 52 maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > K ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 int ans ; class SovleDis { public : CalDis cd ; int sovle ( int u , int fa , int w ) { cd . init ( u , w ); cd . caldis ( u , fa ); sort ( cd . di + 1 , cd . di + 1 + cd . tp ); int l = 1 , r = cd . tp , ans = 0 ; while ( l < r ) { if ( cd . di [ l ] + cd . di [ r ] <= K ) { ans += r - l ; l ++ ; } else r -- ; 53 } return ans ; } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; ans += s . sovle ( u , - 1 , 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ]) continue ; ans -= s . sovle ( v , u , w ); rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } ans = 0 ; scanf ( \"%d\" , & K ); df . sovle (); printf ( \"%d \\n \" , ans ); } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u8499\u665f\u7ef4","title":"5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve()"},{"location":"Data_Structure/%E7%82%B9%E5%88%A8/","text":"1 2 3 4 5 6 ///\u6d1b\u8c37 P3384 \u9898\u610f\uff1a\u5bf9\u4e8e\u4e00\u9897\u6811\u6709\u5982\u4e0b\u64cd\u4f5c \u64cd\u4f5c 1: 1 x y z \u8868\u793a\u5c06\u6811\u4ece x \u5230 y \u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0a z\u3002 \u64cd\u4f5c 2: 2 x y \u8868\u793a\u6c42\u6811\u4ece x \u5230 y \u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\u3002 \u64cd\u4f5c 3: 3 x z \u8868\u793a\u5c06\u4ee5 x \u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0a z\u3002 \u64cd\u4f5c 4: 4 x \u8868\u793a\u6c42\u4ee5 x \u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 #include <bits/stdc++.h> #define ls rt << 1 #define rs rt << 1 | 1 using namespace std ; typedef long long ll ; const int N = 1e5 + 5 ; int n , m , mod ; struct Edge { int next , to ; } edge [ N << 1 ]; ///\u8fb9 int etot , head [ N ], Root ; int a [ N ]; inline void add ( int u , int v ) { edge [ etot ] = { head [ u ], v }; 34 head [ u ] = etot ++ ; } inline void init () { memset ( head , - 1 , sizeof ( head )); dfscnt = etot = 0 ; } class treeChainSubdivision { public : int son [ N ], tid [ N ], fa [ N ], dep [ N ], siz [ N ], top [ N ], rnk [ N ], dfscnt ; ///son \u91cd\u513f\u5b50\u7f16\u53f7,tid \u662f dfs \u5e8f,fa \u7236\u4eb2\u8282\u70b9,dep \u6df1\u5ea6\u4ece 1 \u5f00\u59cb\u7684 ///siz \u5b50\u6811\u5927\u5c0f,top \u5f53\u524d\u94fe\u9876\u7aef\u8282\u70b9,dfscnt \u662f dfs \u5e8f,rnk \u662f dfs \u5e8f\u4e3a i \u7684\u8282\u70b9 ///\u591a\u7ec4\u8f93\u5165\u65f6 son \u8981\u521d\u59cb\u5316\uff01\uff01\uff01 inline void dfs1 ( int x , int f , int deep ) { dep [ x ] = deep ; fa [ x ] = f ; siz [ x ] = 1 ; int maxson = - 1 ; for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == f ) continue ; dfs1 ( to , x , deep + 1 ); siz [ x ] += siz [ to ]; if ( siz [ to ] > maxson ) son [ x ] = to , maxson = siz [ to ]; } } inline void dfs2 ( int x , int topf ) { tid [ x ] = ++ dfscnt ; rnk [ dfscnt ] = x ; top [ x ] = topf ; if ( ! son [ x ]) return ; dfs2 ( son [ x ], topf ); for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa [ x ] || to == son [ x ]) continue ; dfs2 ( to , to ); } } inline void updpath ( int x , int y , int val ) { val %= mod ; while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); Tree . update ( 1 , 1 , n , tid [ top [ x ]], tid [ x ], val ); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); Tree . update ( 1 , 1 , n , tid [ x ], tid [ y ], val ); } inline int Qpath ( int x , int y ) { int ans = 0 ; while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); ans = ( ans + Tree . query ( 1 , 1 , n , tid [ top [ x ]], tid [ x ])) % mod ; x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); ans = ( ans + Tree . query ( 1 , 1 , n , tid [ x ], tid [ y ])) % mod ; return ans % mod ; } inline void updson ( int x , int val ) { Tree . update ( 1 , 1 , n , tid [ x ], tid [ x ] + siz [ x ] - 1 , val ); } inline int Qson ( int x ) { return Tree . query ( 1 , 1 , n , tid [ x ], tid [ x ] + siz [ x ] - 1 ); } } TCS ; class segmentTree { public : int tree [ N << 2 ], laz [ N << 2 ]; inline void build ( int rt , int l , int r ) { if ( l == r ) { tree [ rt ] = a [ TCS . rnk [ l ]] % mod ; return ; } int mid = ( l + r ) >> 1 ; build ( ls , l , mid ); build ( rs , mid + 1 , r ); tree [ rt ] = ( tree [ ls ] + tree [ rs ]) % mod ; } inline void pushdown ( int rt , int l , int r ) { if ( laz [ rt ]) { int mid = ( l + r ) >> 1 ; laz [ ls ] = ( laz [ ls ] + laz [ rt ]) % mod ; laz [ rs ] = ( laz [ rs ] + laz [ rt ]) % mod ; tree [ ls ] = ( tree [ ls ] + laz [ rt ] * ( mid - l + 1 ) % mod ) % mod ; tree [ rs ] = ( tree [ rs ] + laz [ rt ] * ( r - mid ) % mod ) % mod ; laz [ rt ] = 0 ; } } inline void update ( int rt , int l , int r , int ql , int qr , int val ) { if ( ql <= l && r <= qr ) { laz [ rt ] = ( laz [ rt ] + val ) % mod ; tree [ rt ] = ( tree [ rt ] + ( r - l + 1 ) * val % mod ) % mod ; return ; } pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) update ( ls , l , mid , ql , qr , val ); if ( qr > mid ) update ( rs , mid + 1 , r , ql , qr , val ); tree [ rt ] = ( tree [ ls ] + tree [ rs ]) % mod ; } inline int query ( int rt , int l , int r , int ql , int qr ) { if ( ql <= l && r <= qr ) return tree [ rt ]; pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; int res = 0 ; if ( ql <= mid ) res += query ( ls , l , mid , ql , qr ); if ( qr > mid ) res += query ( rs , mid + 1 , r , ql , qr ); return res % mod ; } } Tree ; int main () { scanf ( \"%d%d%d%d\" , & n , & m , & Root , & mod ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i < n ; i ++ ) { int u , v ; scanf ( \"%d%d\" , & u , & v ); add ( u , v ); add ( v , u ); } TCS . dfs1 ( Root , 0 , 1 ); TCS . dfs2 ( Root , Root ); Tree . build ( 1 , 1 , n ); while ( m -- ) { int op , x , y , val ; scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d%d%d\" , & x , & y , & val ); Tree . updpath ( x , y , val ); } else if ( op == 2 ) { scanf ( \"%d%d\" , & x , & y ); printf ( \"%d \\n \" , TCS . Qpath ( x , y )); } else if ( op == 3 ) { scanf ( \"%d%d\" , & x , & y ); 37 TCS . updson ( x , y ); } else { scanf ( \"%d\" , & x ); printf ( \"%d \\n \" , TCS . Qson ( x )); } } return 0 ; } \u6574\u7406\u4eba\uff1a\u8ba1 18-7 \u725b\u4ed4\u8d85","title":"\u70b9\u5256"},{"location":"Data_Structure/%E7%BA%BF%E6%AE%B5%E6%A0%91lazy/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 ///poj3468 \u9898\u610f\uff1an \u4e2a\u6570\uff0cm \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u533a\u95f4\u52a0\u4e0a\u4e00\u4e2a\u6570\uff0c\u533a\u95f4\u67e5\u8be2\u548c #include <bits/stdc++.h> using namespace std ; #define rep(i, j, k) for (int i = j; i <= k; i++) #define debug puts(\"*\"); const int N = 220 ; int n , cnt , t = 1 ; struct node { int l , r , cnt ; double len ; } tree [ N << 2 ]; struct knode { double x1 , y1 , y2 ; int k ; friend bool operator < ( knode a , knode b ) { return a . x1 < b . x1 ; } } line [ N ]; double raw [ N ], b [ N ], val [ N ]; void discrete () { sort ( raw + 1 , raw + 2 * n + 1 ); // rep(i,1,2*n)cout<<raw[i]<<\" \";puts(\"\"); rep ( i , 1 , 2 * n ) if ( i == 1 || raw [ i ] != raw [ i - 1 ]) b [ ++ cnt ] = raw [ i ]; // rep(i,1,cnt)cout<<b[i]<<\" \"; } int findx ( double x ) { return lower_bound ( b + 1 , b + cnt + 1 , x ) - b ; } void pushup ( int rt , int l , int r ) { if ( tree [ rt ]. cnt ) { tree [ rt ]. len = b [ r + 1 ] - b [ l ]; } else if ( l != r ) { tree [ rt ]. len = tree [ rt << 1 ]. len + tree [ rt << 1 | 1 ]. len ; } else tree [ rt ]. len = 0 ; return ; } void build ( int rt , int l , int r ) { tree [ rt ]. l = l , tree [ rt ]. r = r ; 28 tree [ rt ]. len = 0.0 ; tree [ rt ]. cnt = 0 ; // cout<<l<<\" \"<<r<<endl; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( rt << 1 , l , mid ); build ( rt << 1 | 1 , mid + 1 , r ); } void update ( int rt , int l , int r , int x ) { if ( l <= tree [ rt ]. l && tree [ rt ]. r <= r ) { tree [ rt ]. cnt += x ; pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); return ; } int mid = ( tree [ rt ]. l + tree [ rt ]. r ) >> 1 ; ///2 if ( l <= mid ) update ( rt << 1 , l , r , x ); if ( r > mid ) update ( rt << 1 | 1 , l , r , x ); pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); } int main () { while ( ~ scanf ( \"%d\" , & n )) { if ( ! n ) break ; cnt = 0 ; /// 1 rep ( i , 1 , n ) { double x1 , y1 , x2 , y2 ; scanf ( \"%lf%lf%lf%lf\" , & x1 , & y1 , & x2 , & y2 ); raw [ i * 2 - 1 ] = y1 , raw [ i * 2 ] = y2 ; line [ i * 2 - 1 ]. x1 = x1 , line [ i * 2 - 1 ]. y1 = y1 , line [ i * 2 - 1 ]. y2 = y2 ; line [ i * 2 - 1 ]. k = 1 ; line [ i * 2 ]. x1 = x2 , line [ i * 2 ]. y1 = y1 , line [ i * 2 ]. y2 = y2 ; line [ i * 2 ]. k = - 1 ; } discrete (); sort ( line + 1 , line + 2 * n + 1 ); double ans = 0 ; build ( 1 , 1 , cnt ); rep ( i , 1 , 2 * n ) { ans += tree [ 1 ]. len * ( line [ i ]. x1 - line [ i - 1 ]. x1 ); update ( 1 , findx ( line [ i ]. y1 ), findx ( line [ i ]. y2 ) - 1 , line [ i ]. k ); } printf ( \"Test case #%d \\n Total explored area: %.2lf \\n\\n \" , t ++ , ans ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u6768\u777f","title":"\u7ebf\u6bb5\u6811lazy\u6807\u8bb0"},{"location":"Data_Structure/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 ///HDU 3911 \u9898\u610f\uff1a\u53cd\u8f6c\u64cd\u4f5c\uff1a\u6bcf\u6b21\u53cd\u8f6c\u4e00\u4e2a\u533a\u95f4\u5185 0 1 \u7684\u503c\uff0c\u67e5\u8be2\u64cd\u4f5c\uff1a\u67e5\u8be2\u6700\u957f\u7684 1 \u4ee3\u7801\uff1a #include <bits/stdc++.h> using namespace std ; #define lson rt << 1 #define rson rt << 1 | 1 const int N = 1e5 + 9 ; int a [ N ], n , m ; int tree0 [ N << 2 ], tree1 [ N << 2 ], lazy [ N << 2 ], lmax0 [ N << 2 ]; int lmax1 [ N << 2 ], rmax0 [ N << 2 ], rmax1 [ N << 2 ]; void swp ( int rt ) { swap ( tree0 [ rt ], tree1 [ rt ]); swap ( rmax0 [ rt ], rmax1 [ rt ]); swap ( lmax0 [ rt ], lmax1 [ rt ]); return ; } void pushup ( int rt ) { if ( ! tree0 [ lson ]) lmax1 [ rt ] = lmax1 [ lson ] + lmax1 [ rson ]; else lmax1 [ rt ] = lmax1 [ lson ]; if ( ! tree1 [ lson ]) lmax0 [ rt ] = lmax0 [ lson ] + lmax0 [ rson ]; else lmax0 [ rt ] = lmax0 [ lson ]; if ( ! tree0 [ rson ]) rmax1 [ rt ] = rmax1 [ rson ] + rmax1 [ lson ]; else rmax1 [ rt ] = rmax1 [ rson ]; if ( ! tree1 [ rson ]) rmax0 [ rt ] = rmax0 [ rson ] + rmax0 [ lson ]; else rmax0 [ rt ] = rmax0 [ rson ]; tree0 [ rt ] = max ( rmax0 [ lson ] + lmax0 [ rson ], max ( tree0 [ lson ], tree0 [ rson ])); tree0 [ rt ] = max ( tree0 [ rt ], max ( tree0 [ lson ], tree0 [ rson ])); tree0 [ rt ] = max ( tree0 [ rt ], max ( lmax0 [ rt ], rmax0 [ rt ])); tree1 [ rt ] = max ( rmax1 [ lson ] + lmax1 [ rson ], max ( tree1 [ lson ], tree1 [ rson ])); tree1 [ rt ] = max ( tree1 [ rt ], max ( tree1 [ lson ], tree1 [ rson ])); tree1 [ rt ] = max ( tree1 [ rt ], max ( lmax1 [ rt ], rmax1 [ rt ])); } void pushdown ( int rt ) { if ( lazy [ rt ]) { swp ( lson ); swp ( rson ); lazy [ lson ] ^= 1 ; lazy [ rson ] ^= 1 ; lazy [ rt ] = 0 ; } return ; 30 } void build ( int rt , int l , int r ) { lazy [ rt ] = 0 ; if ( l == r ) { scanf ( \"%d\" , & a [ l ]); if ( a [ l ] == 1 ) { tree0 [ rt ] = 0 ; tree1 [ rt ] = 1 ; lmax0 [ rt ] = 0 ; rmax0 [ rt ] = 0 ; lmax1 [ rt ] = 1 ; rmax1 [ rt ] = 1 ; } else { tree0 [ rt ] = 1 ; tree1 [ rt ] = 0 ; lmax0 [ rt ] = 1 ; rmax0 [ rt ] = 1 ; lmax1 [ rt ] = 0 ; rmax1 [ rt ] = 0 ; } // cout<<l<<endl; return ; } int mid = ( l + r ) >> 1 ; build ( lson , l , mid ); build ( rson , mid + 1 , r ); pushup ( rt ); } void change ( int rt , int l , int r , int x , int y ) { if ( l >= x && r <= y ) { lazy [ rt ] ^= 1 ; swp ( rt ); return ; } int mid = ( l + r ) >> 1 ; pushdown ( rt ); if ( x <= mid ) change ( lson , l , mid , x , y ); if ( y > mid ) change ( rson , mid + 1 , r , x , y ); pushup ( rt ); } int query ( int rt , int l , int r , int x , int y ) { if ( l >= x && r <= y ) { return tree1 [ rt ]; } int ans = 0 ; pushdown ( rt ); int mid = ( l + r ) >> 1 ; if ( x <= mid ) { ans = max ( query ( lson , l , mid , x , y ), ans ); } if ( y > mid ) { ans = max ( query ( rson , mid + 1 , r , x , y ), ans ); } ans = max ( ans , min ( mid - x + 1 , rmax1 [ lson ]) + min ( y - mid , lmax1 [ rson ])); return ans ; 31 } int main () { while ( ~ scanf ( \"%d\" , & n )) { build ( 1 , 1 , n ); scanf ( \"%d\" , & m ); while ( m -- ) { int op , l , r ; scanf ( \"%d%d%d\" , & op , & l , & r ); if ( op == 0 ) { printf ( \"%d \\n \" , query ( 1 , 1 , n , l , r )); } else { change ( 1 , 1 , n , l , r ); } // for(int i=1;i<=4*n;i++){ // printf(\"%d \",tree1[i]); // }puts(\"\"); } } } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u6768\u777f","title":"\u7ebf\u6bb5\u6811\u533a\u95f4\u5408\u5e76"},{"location":"Data_Structure/%E8%8E%AB%E9%98%9F/","text":"1 2 3 BZOJ 2038 \u9898\u610f\uff1a\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 n \u548c m\uff0c\u4e4b\u540e\u7ed9\u51fa n \u4e2a\u6570\u4ee3\u8868 n \u4e2a\u889c\u5b50\u7684\u989c\u8272\uff0cm \u6b21\u8be2\u95ee\uff0c \u6bcf\u6b21\u7ed9\u51fa\u4e00\u4e2a[l, r]\uff0c\u95ee\u533a\u95f4\u5185\u7684\u968f\u673a\u62bd\u53d6\u4e24\u4e2a\u889c\u5b50\u989c\u8272\u76f8\u540c\u7684\u6982\u7387\u4e3a\u591a\u5c11\uff0c\u8f93\u51fa\u6700\u7b80\u5206\u6570 A/B \u7684\u5f62\u5f0f\uff0c\u82e5\u6982\u7387\u4e3a\u96f6\u5219\u8f93\u51fa 0/1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 1e5 + 7 ; const int M = 1e6 + 7 ; const int INF = 1e9 + 8 ; int block ; struct node { int l , r , id ; }; ll gcd ( ll x , ll y ) { return y == 0 ? x : gcd ( y , x % y ); } bool cmp ( node xx , node yy ) //\u5947\u5076\u6392\u5e8f\u4f18\u5316 { if ( xx . l / block == yy . l / block ) { if ( xx . l / block & 1 ) return xx . r < yy . r ; else return xx . r > yy . r ; } return xx . l / block < yy . l / block ; } class Moteam { 45 public : int a [ N ], sum [ N ], n , m ; ll ansx [ N ], ansy [ N ], ans ; node q [ N ]; void Add ( int i ) //\u6dfb\u52a0\u64cd\u4f5c { ans -= sum [ a [ i ]] * sum [ a [ i ]]; sum [ a [ i ]] ++ ; ans += sum [ a [ i ]] * sum [ a [ i ]]; } void Sub ( int i ) { ans -= sum [ a [ i ]] * sum [ a [ i ]]; sum [ a [ i ]] -- ; ans += sum [ a [ i ]] * sum [ a [ i ]]; } void solve () //\u4fee\u6539\u64cd\u4f5c { sort ( q + 1 , q + m + 1 , cmp ); int l = 1 ; int r = 1 ; sum [ a [ 1 ]] ++ ; ans = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( q [ i ]. l == q [ i ]. r ) //\u7279\u5224\u4e00\u4e0b ansx [ q [ i ]. id ] = 0 , ansy [ q [ i ]. id ] = 1 ; while ( l < q [ i ]. l ) Sub ( l ), l ++ ; while ( l > q [ i ]. l ) l -- , Add ( l ); while ( r < q [ i ]. r ) r ++ , Add ( r ); while ( r > q [ i ]. r ) Sub ( r ), r -- ; ll x = ( ans - ( q [ i ]. r - q [ i ]. l + 1 )); ll y = ( ll )( q [ i ]. r - q [ i ]. l + 1 ) * ( ll )( q [ i ]. r - q [ i ]. l ); ll d = gcd ( x , y ); ansx [ q [ i ]. id ] = x / d ; ansy [ q [ i ]. id ] = y / d ; } for ( int i = 1 ; i <= m ; i ++ ) printf ( \"%lld/%lld \\n \" , ansx [ i ], ansy [ i ]); } } mo ; int main () { memset ( mo . sum , 0 , sizeof mo . sum ); scanf ( \"%d %d\" , & mo . n , & mo . m ); for ( int i = 1 ; i <= mo . n ; i ++ ) scanf ( \"%d\" , & mo . a [ i ]); block = sqrt ( mo . n ); for ( int i = 1 ; i <= mo . m ; i ++ ) { scanf ( \"%d %d\" , & mo . q [ i ]. l , & mo . q [ i ]. r ); mo . q [ i ]. id = i ; } mo . solve (); return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u8463\u6587\u777f","title":"\u83ab\u961f\u7b97\u6cd5"},{"location":"Data_Structure/%E8%BE%B9%E5%89%96/","text":"1 2 3 4 5 6 ///\u6d1b\u8c37 P4315 \u9898\u610f\uff1a\u5bf9\u4e8e\u4e00\u9897\u6811\u6709\u5982\u4e0b\u64cd\u4f5c \u64cd\u4f5c 1: Change k w\uff1a\u5c06\u7b2c k \u6761\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u6539\u53d8\u4e3a w \u4e2a\u3002 \u64cd\u4f5c 2: Cover u v w\uff1a\u5c06\u8282\u70b9 u \u4e0e\u8282\u70b9 v \u4e4b\u95f4\u7684\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u90fd\u6539\u53d8\u4e3a w \u4e2a\u3002 \u64cd\u4f5c 3: Add u v w\uff1a\u5c06\u8282\u70b9 u \u4e0e\u8282\u70b9 v \u4e4b\u95f4\u7684\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u90fd\u589e\u52a0 w \u4e2a\u3002 \u64cd\u4f5c 4: Max u v\uff1a\u8be2\u95ee\u8282\u70b9 u \u4e0e\u8282\u70b9 v \u4e4b\u95f4\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u4e2a\u6570\u6700\u591a\u6709\u591a\u5c11\u4e2a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 #include <bits/stdc++.h> #define ls rt << 1 #define rs rt << 1 | 1 using namespace std ; typedef long long ll ; const int N = 1e5 + 5 ; int n , m , t , Root ; int a [ N ], rnk [ N ]; ///a \u7528\u6bcf\u6761\u8fb9\u7684\u4e24\u4e2a\u8282\u70b9\u4e2d\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e2a\u8282\u70b9\u4ee3\u8868\u8fd9\u6761\u8fb9\u7684\u6743\u503c\uff0crnk \u662f dfs \u5e8f\u4e3a i \u7684\u8282\u70b9 struct Edge { int next , to , val ; } edge [ N << 1 ]; ///\u8fb9 int head [ N ], etot ; void add ( int u , int v , int val ) { edge [ etot ] = { head [ u ], v , val }; head [ u ] = etot ++ ; } void init () { ///\u521d\u59cb\u5316 memset ( head , - 1 , sizeof ( head )); etot = 0 ; } class segmentTree { public : int tree [ N << 2 ], laz [ N << 2 ], laz2 [ N << 2 ]; ///laz \u662f\u8d4b\u503c laz\uff0claz2 \u662f\u52a0\u6cd5 laz void build ( int rt , int l , int r ) { laz [ rt ] = - 1 ; laz2 [ rt ] = 0 ; if ( l == r ) { tree [ rt ] = a [ rnk [ l ]]; return ; } int mid = ( l + r ) >> 1 ; build ( ls , l , mid ); build ( rs , mid + 1 , r ); tree [ rt ] = max ( tree [ ls ], tree [ rs ]); } void pushdown ( int rt , int l , int r ) { if ( laz [ rt ] != - 1 ) { laz2 [ ls ] = laz2 [ rs ] = 0 ; tree [ ls ] = laz [ ls ] = laz [ rt ]; tree [ rs ] = laz [ rs ] = laz [ rt ]; laz [ rt ] = - 1 ; } if ( laz2 [ rt ]) { tree [ ls ] += laz2 [ rt ]; tree [ rs ] += laz2 [ rt ]; laz2 [ ls ] += laz2 [ rt ]; laz2 [ rs ] += laz2 [ rt ]; laz2 [ rt ] = 0 ; } } void updateadd ( int rt , int l , int r , int ql , int qr , int val ) { if ( ql > qr ) return ; if ( ql <= l && r <= qr ) { tree [ rt ] += val ; laz2 [ rt ] += val ; return ; } pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) updateadd ( ls , l , mid , ql , qr , val ); if ( qr > mid ) updateadd ( rs , mid + 1 , r , ql , qr , val ); tree [ rt ] = max ( tree [ ls ], tree [ rs ]); } void updatefu ( int rt , int l , int r , int ql , int qr , int val ) { if ( ql > qr ) return ; if ( ql <= l && r <= qr ) { tree [ rt ] = val ; laz [ rt ] = val ; laz2 [ rt ] = 0 ; 39 return ; } pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) updatefu ( ls , l , mid , ql , qr , val ); if ( qr > mid ) updatefu ( rs , mid + 1 , r , ql , qr , val ); tree [ rt ] = max ( tree [ ls ], tree [ rs ]); } inline int query ( int rt , int l , int r , int ql , int qr ) { if ( ql > qr ) return 0 ; if ( ql <= l && r <= qr ) return tree [ rt ]; pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; int res = 0 ; if ( ql <= mid ) res = max ( res , query ( ls , l , mid , ql , qr )); if ( qr > mid ) res = max ( res , query ( rs , mid + 1 , r , ql , qr )); return res ; } } Tree ; class TreeChainSubdivision { public : int son [ N ], tid [ N ], fa [ N ], dep [ N ], siz [ N ], top [ N ], dfscnt = 0 ; ///son \u91cd\u513f\u5b50\u7f16\u53f7,tid \u662f dfs \u5e8f,fa \u7236\u4eb2\u8282\u70b9,dep \u6df1\u5ea6\u4ece 1 \u5f00\u59cb\u7684 ///siz \u5b50\u6811\u5927\u5c0f,top \u5f53\u524d\u94fe\u9876\u7aef\u8282\u70b9,dfscnt \u662f dfs \u5e8f, ///\u591a\u7ec4\u8f93\u5165\u65f6 son \u8981\u521d\u59cb\u5316\uff01\uff01\uff01 void dfs1 ( int x , int f , int deep ) { dep [ x ] = deep ; siz [ x ] = 1 ; fa [ x ] = f ; int maxson = - 1 ; for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == f ) continue ; a [ to ] = edge [ i ]. val ; dfs1 ( to , x , deep + 1 ); siz [ x ] += siz [ to ]; if ( siz [ to ] > maxson ) son [ x ] = to , maxson = siz [ to ]; } } void dfs2 ( int x , int topf ) { tid [ x ] = ++ dfscnt ; rnk [ dfscnt ] = x ; top [ x ] = topf ; if ( ! son [ x ]) return ; dfs2 ( son [ x ], topf ); 40 for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa [ x ] || to == son [ x ]) continue ; dfs2 ( to , to ); } } void updpathadd ( int x , int y , int val ) { while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); Tree . updateadd ( 1 , 1 , n , tid [ top [ x ]], tid [ x ], val ); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); Tree . updateadd ( 1 , 1 , n , tid [ x ] + 1 , tid [ y ], val ); } void updpathfu ( int x , int y , int val ) { while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); Tree . updatefu ( 1 , 1 , n , tid [ top [ x ]], tid [ x ], val ); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); Tree . updatefu ( 1 , 1 , n , tid [ x ] + 1 , tid [ y ], val ); } int Qpath ( int x , int y ) { int ans = 0 ; while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); ans = max ( ans , Tree . query ( 1 , 1 , n , tid [ top [ x ]], tid [ x ])); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); ans = max ( ans , Tree . query ( 1 , 1 , n , tid [ x ] + 1 , tid [ y ])); return ans ; } } TCS ; int main () { init (); scanf ( \"%d\" , & n ); int u , v , k , val ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & val ); add ( u , v , val ); add ( v , u , val ); } 41 Root = 1 ; TCS . dfs1 ( Root , 0 , 1 ); TCS . dfs2 ( Root , Root ); Tree . build ( 1 , 1 , n ); char op [ 10 ]; while ( ~ scanf ( \"%s\" , op )) { if ( op [ 1 ] == 'h' ) { scanf ( \"%d%d\" , & k , & val ); k -- ; u = edge [ k << 1 ]. to ; v = edge [ k << 1 | 1 ]. to ; int now = TCS . dep [ u ] > TCS . dep [ v ] ? u : v ; Tree . updatefu ( 1 , 1 , n , TCS . tid [ now ], TCS . tid [ now ], val ); } else if ( op [ 1 ] == 'o' ) { scanf ( \"%d%d%d\" , & u , & v , & val ); TCS . updpathfu ( u , v , val ); } else if ( op [ 1 ] == 'd' ) { scanf ( \"%d%d%d\" , & u , & v , & val ); TCS . updpathadd ( u , v , val ); } else if ( op [ 1 ] == 'a' ) { scanf ( \"%d%d\" , & u , & v ); printf ( \"%d \\n \" , TCS . Qpath ( u , v )); } else break ; } return 0 ; } \u6574\u7406\u4eba\uff1a\u8ba1 18-7 \u725b\u4ed4\u8d85","title":"\u8fb9\u5256"},{"location":"Geometry/","text":"","title":"Index"},{"location":"Geometry/%E5%87%B8%E5%8C%85%E7%9A%84%E6%B1%82%E5%8F%96/","text":"poj 1912; \u9898\u610f\uff1a\u7ed9\u5b9a\u5e73\u9762\u4e0a n \u4e2a\u70b9\uff0c\u4e4b\u540e\u7ed9\u5b9a\u82e5\u5e72\u76f4\u7ebf\uff0c\u8be2\u95ee\u6240\u6709\u70b9\u65f6\u5019\u5728\u76f4\u7ebf\u7684\u4e00\u4fa7\uff1b \u601d\u8def\uff1a \u9996\u5148\u6c42\u53d6\u51f8\u5305\uff0c\u4e4b\u540e\u5c06\u51f8\u5305\u4e0a\u7684\u6bcf\u4e00\u6761\u8fb9\u7684\u503e\u659c\u89d2\u6c42\u51fa\uff0c\u5bf9\u503e\u659c\u89d2\u4e8c\u5206\uff0c\u627e\u51fa\u503e\u659c \u89d2\u6700\u63a5\u8fd1\u7ed9\u5b9a\u76f4\u7ebf\u503e\u659c\u89d2\u7684\u8fb9\u6240\u5bf9\u5e94\u7684\u70b9\uff0c\u5c06\u76f4\u7ebf\u65cb\u8f6c 180\u00b0\u540e\u5728\u6c42\u51fa\u5bf9\u5e94\u70b9\uff0c\u5224\u5b9a\u6240\u6c42\u4e24 \u70b9\u662f\u5426\u5728\u76f4\u7ebf\u4e24\u4fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 struct Line { Point p ; Vector v ; double ang ; Line () {} Line ( Point p , Vector v ) : p ( p ), v ( v ) { ang = atan2 ( v . y , v . x ); } Point point ( double t ) { return p + v * t ; } //\u6c42\u53d6\u76f4\u7ebf\u4e0a\u7684\u67d0\u4e00\u4e2a\u70b9 bool operator < ( Line & l ) { return ang < l . ang ; } //\u76f4\u7ebf\u9ed8\u8ba4\u4ee5\u503e\u659c\u89d2\u6392\u5e8f int Onleft ( Point P ) { return dcmp ( v ^ ( P - p )); } //\u5224\u65ad\u4e00\u4e2a\u70b9\u662f\u5426\u5728\u76f4\u7ebf\u7684\u5de6 \u4fa7 Point operator & ( Line & l ) //\u6c42\u53d6\u4e24\u76f4\u7ebf\u7684\u4ea4\u70b9 { Vector u = p - l . p ; double t = ( l . v ^ u ) / ( v ^ l . v ); return p + v * t ; } }; Point p [ N ], sta [ N ]; int n , top ; double af [ N ]; //\u7528\u4e8e\u8bb0\u5f55\u51f8\u5305\u6bcf\u4e00\u6761\u8fb9\u7684\u503e\u659c\u89d2 Line l ; bool cmp ( Point a , Point b ) //\u6781\u89d2\u6392\u5e8f { Vector v = a - p [ 0 ], w = b - p [ 0 ]; //\u4ee5\u67d0\u4e00\u70b9\u4e3a\u57fa\u51c6\u6c42\u51fa\u5176\u4ed6\u6240\u6709\u70b9\u76f8\u5bf9\u4e8e\u5b83\u7684\u6781\u89d2 83 if ( dcmp ( v ^ w ) < 0 ) return false ; else if ( ! dcmp ( v ^ w ) && dcmp ( sqr ( v ) - sqr ( w )) > 0 ) return false ; //\u6781\u89d2\u76f8\u540c\u4ee5\u5411\u91cf\u6a21\u957f \u6392\u5e8f return true ; } void graham () //\u51f8\u5305 { sort ( p + 1 , p + n , cmp ); n = unique ( p , p + n ) - p ; int t = n - 1 ; while ( t && ! (( p [ n - 1 ] - p [ 0 ]) ^ ( p [ t ] - p [ 0 ]))) t -- ; if ( ! t ) //\u5f53\u51f8\u5305\u9000\u5316\u4e3a\u4e00\u4e2a\u70b9\u6216\u8005\u4e00\u6761\u76f4\u7ebf\u65f6\u7684\u60c5\u51b5 { sta [ 0 ] = p [ 0 ]; top = 1 ; if ( n > 1 ) sta [ 1 ] = p [ n - 1 ], top = 2 ; return ; } reverse ( p + t + 1 , p + n ); //\u4e3a\u6c42\u53d6\u6240\u6709\u5728\u51f8\u5305\u8fb9\u754c\u4e0a\u7684\u70b9 sta [ top ++ ] = p [ 0 ]; sta [ top ++ ] = p [ 1 ]; p [ n ++ ] = p [ 0 ]; for ( int i = 2 ; i < n ; i ++ ) { while ( top > 1 && (( sta [ top - 1 ] - sta [ top - 2 ]) ^ ( p [ i ] - sta [ top - 2 ])) <= 0 ) top -- ; \u786e\u5b9a\u6bcf \u4e00\u4e2a\u89d2\u90fd\u4e0d\u4e3a\u4f18\u89d2 sta [ top ++ ] = p [ i ]; } top -- ; for ( int i = 0 ; i < top ; i ++ ) af [ i ] = atan2 ( sta [ i + 1 ]. y - sta [ i ]. y , sta [ i + 1 ]. x - sta [ i ]. x ); //\u6c42\u53d6\u6240\u6709\u8fb9\u7684\u503e\u659c\u89d2 } int main () { scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lf %lf\" , & p [ i ]. x , & p [ i ]. y ); if ( p [ i ] < p [ 0 ]) swap ( p [ i ], p [ 0 ]); } if ( n > 1 ) graham (); double a , b , c , d ; while ( ~ scanf ( \"%lf %lf %lf %lf\" , & a , & b , & c , & d )) { if ( n < 2 ) { puts ( \"GOOD\" ); 84 continue ; } l = Line ( Point ( a , b ), Vector ( c - a , d - b )); double l1 = atan2 ( l . v . y , l . v . x ), l2 = atan2 ( - l . v . y , - l . v . x ); int p1 = lower_bound ( af , af + top , l1 ) - af ; int p2 = lower_bound ( af , af + top , l2 ) - af ; if ( l . Onleft ( sta [ p1 ]) * l . Onleft ( sta [ p2 ]) < 0 ) puts ( \"BAD\" ); else puts ( \"GOOD\" ); } } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u51f8\u5305\u7684\u6c42\u53d6"},{"location":"Geometry/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/","text":"poj3525\uff1b \u9898\u610f\u7ed9\u51fa\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\uff0c\u6c42\u53d6\u5728\u8be5\u51f8\u591a\u8fb9\u5f62\u5185\u6700\u5927\u7684\u5706\u7684\u534a\u5f84\u4e3a\u591a\u5c11 \u601d\u8def\uff1a \u6bcf\u6b21\u5c06\u51f8\u591a\u8fb9\u7684\u6bcf\u4e00\u6761\u8fb9\u5411\u5185\u90e8\u79fb\u52a8\u4e00\u5b9a\u8ddd\u79bb\uff0c\u76f4\u5230\u51f8\u591a\u8fb9\u9762\u79ef\u6070\u597d\u4e3a\u96f6\u65f6\u8be5\u8ddd\u79bb\u8fb9 \u662f\u6240\u6c42\u5706\u7684\u534a\u5f84 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 int HAI ( Line * L , int n ) { sort ( L , L + n ); //\u76f4\u7ebf\u5411\u6309\u7167\u503e\u659c\u89d2\u6392\u5e8f int first , last ; Point * p = new Point [ n ]; //\u5229\u7528\u53cc\u7aef\u961f\u5217\u5b58\u53d6\u534a\u5e73\u9762\u4ea4\u7684\u4ea4\u70b9\uff0c\u4ee5\u53ca\u534a\u5e73\u9762 Line * l = new Line [ n ]; l [ first = last = 0 ] = L [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { while ( first < last && ! L [ i ]. Onleft ( p [ last - 1 ])) last -- ; while ( first < last && ! L [ i ]. Onleft ( p [ first ])) first ++ ; l [ ++ last ] = L [ i ]; if ( ! dcmp ( l [ last ]. v ^ l [ last - 1 ]. v )) //\u82e5\u5b58\u5728\u4e24\u4e2a\u503e\u659c\u89d2\u76f8\u7b49\u7684\u534a\u5e73\u9762\uff0c\u9009\u62e9\u8ddd\u79bb\u76f8\u4ea4 \u533a\u57df\u66f4\u8fd1\u7684\u4e00\u4e2a { last -- ; if ( l [ last ]. Onleft ( L [ i ]. p )) l [ last ] = L [ i ]; } if ( first < last ) p [ last - 1 ] = l [ last - 1 ] & l [ last ]; } while ( first < last && ! l [ first ]. Onleft ( p [ last - 1 ])) last -- ; if ( last - first <= 1 ) return 0 ; p [ last ] = l [ last ] & l [ first ]; return last - first + 1 ; } 85 int n ; Point p [ N ]; Vector dir [ N ], nor [ N ]; Line line [ N ]; int main () { while ( scanf ( \"%d\" , & n ), n ) { for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lf %lf\" , & p [ i ]. x , & p [ i ]. y ); p [ n ] = p [ 0 ]; for ( int i = 0 ; i < n ; i ++ ) dir [ i ] = p [ i + 1 ] - p [ i ], nor [ i ] = normal ( dir [ i ]); double l = 0.0 , r = INF ; while ( dcmp ( r - l ) > 0 ) { double mid = ( l + r ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) line [ i ] = Line ( p [ i ] + nor [ i ] * mid , dir [ i ]); if ( HAI ( line , n )) l = mid ; else r = mid ; } printf ( \"%.6f \\n \" , l ); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u534a\u5e73\u9762\u4ea4"},{"location":"Geometry/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Aizu CGL_4_B; \u9898\u610f\uff1a\u7ed9\u5b9a\u5e73\u9762 n \u4e2a\u70b9\uff0c\u6c42\u53d6\u8ddd\u79bb\u6700\u5927\u7684\u70b9\u5bf9\uff1b double diame () { int i , j , k ; double res , t ; graham (); sta [ top ] = sta [ 0 ], res = 0.0 , j = 1 ; for ( i = 0 ; i < top ; i ++ ) { while ( dcmp ( fabs (( sta [ i ] - sta [ j ]) ^ ( sta [ i + 1 ] - sta [ j ])) - fabs (( sta [ i ] - sta [ j + 1 ]) ^ ( sta [ i + 1 ] - sta [ j + 1 ]))) < 0 ) //\u5bfb\u627e\u8ddd\u79bb\u56fa\u5b9a\u76f4\u7ebf\u8ddd\u79bb\u6700\u5927\u7684\u70b9 j = ( j + 1 ) % top ; t = sqr ( sta [ i ] - sta [ j ]); 86 if ( dcmp ( t - res ) > 0 ) res = t ; } return sqrt ( res ); } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u65cb\u8f6c\u5361\u58f3"},{"location":"Geometry/%E7%82%B9%E7%A7%AF%E5%8F%89%E7%A7%AF%E7%9A%84%E8%BF%90%E7%94%A8/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //poj2318 \u9898\u610f: \u5728\u4e00\u4e2a\u77e9\u5f62\u76d2\u5b50\u5185\u7528 n \u5757\u9694\u677f\u5c06\u77e9\u5f62\u5206\u6210\u82e5\u4e2a\u4e2a\u533a\u57df(\u9694\u677f\u4e0d\u76f8\u4ea4), \u7ed9\u5b9a m \u4e2a\u70b9\uff0c\u95ee\uff08 n + 1 \uff09\u4e2a\u533a\u57df\u5185\u5206\u522b\u6709\u591a\u5c11\u4e2a\u70b9\uff1b \u601d\u8def\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\u4e8c\u5206\u6c42\u51fa\u5b83\u6240\u5728\u7684\u533a\u57df #include <iostream> #include <cmath> #include <cstdio> #include <vector> #include <algorithm> #include <cstring> #define mem(a) memset(a, 0, sizeof a) using namespace std ; const int N = 1e5 + 7 ; const double eps = 1e-6 ; //\u63a7\u5236\u7cbe\u5ea6 int dcmp ( double x ) { if ( fabs ( x ) < eps ) return 0 ; else return x < 0 ? - 1 : 1 ; } struct Point { double x ; double y ; Point ( double x = 0 , double y = 0 ) : x ( x ), y ( y ) {} }; typedef Point Vector ; double operator * ( const Vector & v , const Vector & w ) { return v . x * w . x + v . y * w . y ; } //\u70b9\u79ef double operator ^ ( const Vector & v , const Vector & w ) { return v . x * w . y - v . y * w . x ; } //\u53c9\u79ef double sqr ( Vector v ) { return v * v ; } //\u5411\u91cf\u6a21\u7684\u5e73\u65b9 double length ( Vector v ) { return sqrt ( v * v ); } \u5411\u91cf\u7684\u6a21\u957f Vector operator - ( const Vector & v , const Vector & w ) { return Vector ( v . x - w . x , v . y - w . y ); } //\u5411\u91cf\u51cf\u6cd5 Vector operator + ( const Vector & v , const Vector & w ) { return Vector ( v . x + w . x , v . y + w . y ); } //\u5411\u91cf\u52a0\u6cd5 Vector operator * ( const Vector & v , double k ) { return Vector ( v . x * k , v . y * k ); } //\u5411\u91cf\u7684\u6570\u4e58 81 Vector rotate ( Vector v , double rad ) { return Vector ( v . x * cos ( rad ) - v . y * sin ( rad ), v . x * sin ( rad ) + v . y * cos ( rad )); } // \u5c06\u5411\u91cf\u9006\u65f6\u9488\u65cb\u8f6c rad Vector normal ( Vector v ) { return Vector ( - v . y / length ( v ), v . x / length ( v )); } //\u5411\u91cf\u7684\u5355\u4f4d\u6cd5\u5411\u91cf bool OnSeg ( Point O , Point A , Point B ) { return ! dcmp (( A - O ) ^ ( B - O )) && dcmp (( A - O ) * ( B - O )) <= 0 ; } //\u5224\u5b9a\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a bool operator == ( const Vector & A , const Vector & B ) { return ! dcmp ( A . x - B . x ) && ! dcmp ( A . y - B . y ); } //\u76f8\u91cf\u76f8\u7b49 bool operator < ( const Vector & v , const Vector & w ) { return v . x == w . x ? v . y < w . y : v . x < w . x ; } Point segs [ N ][ 2 ]; int n , m , res [ N ]; int find ( Point P ) { int l = 1 , r = n + 1 ; while ( l < r ) { int mid = l + r >> 1 ; Vector v = segs [ mid ][ 0 ] - segs [ mid ][ 1 ], w = P - segs [ mid ][ 1 ]; if (( v ^ w ) > 0 ) r = mid ; else l = mid + 1 ; } return l - 1 ; } int main () { bool flag = 0 ; while ( scanf ( \"%d\" , & n ), n ) { int x1 , x2 , y1 , y2 ; scanf ( \"%d%d%d%d%d\" , & m , & x1 , & y1 , & x2 , & y2 ); segs [ 0 ][ 0 ] = Point ( x1 , y1 ), segs [ 0 ][ 1 ] = Point ( x1 , y2 ); segs [ n + 1 ][ 0 ] = Point ( x2 , y1 ), segs [ n + 1 ][ 1 ] = Point ( x2 , y2 ); for ( int i = 1 ; i <= n ; i ++ ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); segs [ i ][ 0 ] = Point ( a , y1 ); segs [ i ][ 1 ] = Point ( b , y2 ); } mem ( res ); for ( int i = 0 ; i < m ; i ++ ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); 82 res [ find ( Point ( a , b ))] ++ ; } if ( ! flag ) flag = 1 ; else puts ( \"\" ); for ( int i = 0 ; i <= n ; i ++ ) printf ( \"%d: %d \\n \" , i , res [ i ]); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u70b9\u79ef\u53c9\u79ef\u7684\u8fd0\u7528"},{"location":"Graph/","text":"","title":"Index"},{"location":"Graph/Dinic/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 ///\u6d1b\u8c37 P3376 typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; 60 const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; const int base = 100 ; struct edge { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; class Dinic { public : int S , T , n , m , cnt ; int head [ N ], d [ N ], cur [ N ]; edge e [ M ]; void addedge ( int u , int v , int cap ) { e [ ++ cnt ] = edge ( v , head [ u ], cap ); head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 , u , v , cap ; i <= m ; i ++ ) { read ( u ); read ( v ); read ( cap ); addedge ( u , v , cap ); addedge ( v , u , 0 ); } } // \u627e\u589e\u5e7f\u8def bool bfs () { mem ( d ); queue < int > q ; 61 q . push ( S ); d [ S ] = 1 ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] || e [ i ]. cap <= 0 ) continue ; d [ v ] = d [ u ] + 1 ; q . push ( v ); } } for ( int i = 0 ; i <= n ; i ++ ) cur [ i ] = head [ i ]; return d [ T ]; } int dfs ( int u , int flow ) { if ( u == T ) return flow ; for ( int & i = cur [ u ], v ; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] != d [ u ] + 1 || e [ i ]. cap <= 0 ) continue ; int delta = dfs ( v , min ( flow , e [ i ]. cap )); if ( delta <= 0 ) continue ; e [ i ]. cap -= delta ; e [ i ^ 1 ]. cap += delta ; return delta ; } return 0 ; } int get_maxFlow () { int maxFlow = 0 , tmp ; while ( bfs ()) while ( tmp = dfs ( S , INF )) maxFlow += tmp ; return maxFlow ; 62 } }; Dinic ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); printf ( \"%d \\n \" , ways . get_maxFlow ()); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"Dinic+\u5f53\u524d\u5f27\u4f18\u5316"},{"location":"Graph/EK/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 ///\u6d1b\u8c37 P3376 typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; struct edge { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; class EK { public : int S , T , n , m , cnt ; int head [ N ], vis [ N ]; int pre [ N ], flow [ N ]; edge e [ M ]; void addedge ( int u , int v , int cap ) 58 { e [ ++ cnt ] = edge ( v , head [ u ], cap ); head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); mem ( vis ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 , u , v , cap ; i <= m ; i ++ ) { read ( u ); read ( v ); read ( cap ); addedge ( u , v , cap ); addedge ( v , u , 0 ); } } // \u627e\u589e\u5e7f\u8def bool bfs () { mem ( vis ); queue < int > q ; q . push ( S ); vis [ S ] = 1 ; flow [ S ] = INF ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( vis [ v ] || e [ i ]. cap <= 0 ) continue ; flow [ v ] = min ( flow [ u ], e [ i ]. cap ); pre [ v ] = i ; q . push ( v ); vis [ v ] = 1 ; if ( v == T ) return 1 ; } } return 0 ; 59 } int update () { int u = T ; while ( u != S ) { int i = pre [ u ]; e [ i ]. cap -= flow [ T ]; e [ i ^ 1 ]. cap += flow [ T ]; u = e [ i ^ 1 ]. to ; } return flow [ T ]; } int get_maxFlow () { int maxFlow = 0 ; while ( bfs ()) maxFlow += update (); return maxFlow ; } }; EK ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); printf ( \"%d \\n \" , ways . get_maxFlow ()); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"EK \u7b97\u6cd5"},{"location":"Graph/ISAP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 //\u6d1b\u8c37 P3376 typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; const int base = 100 ; int n , m , S , T ; struct edge { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; class ISAP { public : int S , T , n , m , cnt ; int head [ N ], d [ N ], cur [ N ], gap [ N ]; edge e [ M ]; void addedge ( int u , int v , int cap ) { e [ ++ cnt ] = edge ( v , head [ u ], cap ); 63 head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 , u , v , cap ; i <= m ; i ++ ) { read ( u ); read ( v ); read ( cap ); addedge ( u , v , cap ); addedge ( v , u , 0 ); } } // \u627e\u589e\u5e7f\u8def void bfs () { queue < int > q ; for ( int i = 1 ; i <= n ; i ++ ) { cur [ i ] = head [ i ]; d [ i ] = gap [ i ] = 0 ; } q . push ( T ); d [ T ] = gap [ 1 ] = 1 ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ]) continue ; d [ v ] = d [ u ] + 1 ; ++ gap [ d [ v ]]; q . push ( v ); } 64 } } int dfs ( int u , int flow ) { if ( u == T ) return flow ; int delta = 0 , v , temp ; for ( int & i = cur [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] + 1 != d [ u ]) continue ; temp = dfs ( v , min ( flow - delta , e [ i ]. cap )); if ( temp ) { e [ i ]. cap -= temp ; e [ i ^ 1 ]. cap += temp ; delta += temp ; } if ( flow == delta ) return flow ; } if ( ! ( -- gap [ d [ u ]])) d [ S ] = n + 1 ; ++ gap [ ++ d [ u ]]; cur [ u ] = head [ u ]; return delta ; } int get_maxFlow () { bfs (); int maxFlow = 0 ; while ( d [ S ] <= n ) maxFlow += dfs ( S , INF ); return maxFlow ; } }; ISAP ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); 65 printf ( \"%d \\n \" , ways . get_maxFlow ()); } return 0 ; } \u4f8b\u9898\uff1a \u7f51\u7edc\u6d41 24 \u9898 \u661f\u9645\u8f6c\u79fb Loj 6015 \u9898\u610f\uff1a \u73b0\u6709 n \u4e2a\u592a\u7a7a\u7ad9\u4f4d\u4e8e\u5730\u7403\u4e0e\u6708\u7403\u4e4b\u95f4\uff0c\u4e14\u6709 m \u8258\u516c\u5171\u4ea4\u901a\u592a\u7a7a\u8239\u5728\u5176\u95f4\u6765\u56de \u7a7f\u68ad\u3002\u6bcf\u4e2a\u592a\u7a7a\u7ad9\u53ef\u5bb9\u7eb3\u65e0\u9650\u591a\u7684\u4eba\uff0c\u800c\u6bcf\u8258\u592a\u7a7a\u8239 i \u53ea\u53ef\u5bb9\u7eb3 Hi \u4e2a\u4eba\u3002\u6bcf\u8258\u592a\u7a7a\u8239\u5c06 \u5468\u671f\u6027\u5730\u505c\u9760\u4e00\u7cfb\u5217\u7684\u592a\u7a7a\u7ad9\uff0c\u4f8b\u5982\uff1a1,3,4 \u8868\u793a\u8be5\u592a\u7a7a\u8239\u5c06\u5468\u671f\u6027\u5730\u505c\u9760\u592a\u7a7a\u7ad9 134134134\u22ef \u6bcf\u4e00\u8258\u592a\u7a7a\u8239\u4ece\u4e00\u4e2a\u592a\u7a7a\u7ad9\u9a76\u5f80\u4efb\u4e00\u592a\u7a7a\u7ad9\u8017\u65f6\u5747\u4e3a 1\u3002\u4eba\u4eec\u53ea\u80fd\u5728\u592a\u7a7a\u8239\u505c \u9760\u592a\u7a7a\u7ad9\uff08\u6216\u6708\u7403\u3001\u5730\u7403\uff09\u65f6\u4e0a\u3001\u4e0b\u8239\u3002 \u521d\u59cb\u65f6\u6240\u6709\u4eba\u5168\u5728\u5730\u7403\u4e0a\uff0c\u592a\u7a7a\u8239\u5168\u5728\u521d\u59cb\u7ad9\u3002 \u8bd5\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\uff0c\u627e\u51fa\u8ba9\u6240\u6709\u4eba\u5c3d\u5feb\u5730\u5168\u90e8\u8f6c\u79fb\u5230\u6708\u7403\u4e0a\u7684\u8fd0\u8f93\u65b9\u6848\u3002 \u5206\u6790\uff1a \u8fd9\u4e2a\u9898\u5176\u5b9e\u548c\u201c\u9b54\u672f\u7403\u201d\u8fd9\u4e2a\u9898\u7c7b\u4f3c\u3002\u9898\u610f\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e9b\u4eba\u8981\u4ece A ---> B \uff0c\u7a7a\u95f4 \u7ad9\u4e3a\u4e2d\u8f6c\u70b9\uff0c\u901a\u8fc7\u98de\u8239\u8f6c\u79fb\uff0c\u8fd9\u4e9b\u98de\u8239\u6bcf\u4e00\u5929\u51fa\u73b0\u5728\u56fa\u5b9a\u7a7a\u95f4\u7ad9\uff0c\u4e5f\u5373\u662f\u8bf4\u5929\u6570\u4e0d\u4e00\u5b9a\u7684\u65f6 \u5019\uff0c\u6574\u4e2a\u8fd0\u8f93\u56fe\u5c31\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u800c\u6bcf\u4e00\u5929\u4e4b\u95f4\u53c8\u662f\u6709\u5173\u7cfb\u7684\u3002 \u5c31\u597d\u50cf\uff0c\u6bcf\u4e00\u5929\u7684\u7a7a\u95f4\u7ad9\u662f\u4e0d \u4e00\u6837\u7684\uff08\u56e0\u4e3a\u98de\u8239\u98de\u884c\u7ebf\u8def\u4e0d\u4e00\u6837\u4e86\uff09\uff0c\u6240\u4ee5\u8003\u8651\u5230 \u5730\u7403\uff080 \u53f7\u70b9\uff09\u3001n \u4e2a\u7a7a\u95f4\u7ad9\u548c\u6708\u4eae\uff08n + 1 \u53f7\u70b9\uff09\u5171 n + 2 \u4e2a\u70b9\uff0c\u6bcf\u4e00\u5929\u5206\u88c2\u4e00\u6b21\uff08\u5373\u62e5\u6709\u4e00\u4e2a\u65b0\u7684\u72b6\u6001\uff09\uff0c\u6709\u56e0\u4e3a\u5171\u7ecf\u5386 t \u5929\uff0c \u5b8c\u6210\u8fd0\u8f93\uff0c\u6545 \u5c06\u8981\u5206\u88c2\u51fa t * (n + 2) \u4e2a\u70b9\u3010\u5373\u662f\u8bf4\u5c06\u6bcf\u4e00\u5929\u7684\u8fd9 n + 2 \u4e2a\u70b9\u770b\u6210\u4e00\u4e2a\u65b0\u7684 \u70b9\u3011\uff0c\u679a\u4e3e\u6bcf\u4e00\u5929 day\uff0c\u4ee4 yesterday = (n + 2) * (day \u2013 1)\uff0ctoday = (n + 2) * day\uff1b \u5219\u6bcf\u4e00\u4e2a \u70b9 i\u2019 = yesterday + i \uff08\u4ee3\u8868\u6628\u5929\u5bf9\u5e94\u7684\u70b9\uff09, i = today + i \uff08\u4ee3\u8868\u4eca\u5929\u7684\u70b9\uff09\uff1b\u6545 i\u2019--->i \uff0c\u5bb9 \u91cf\u4e3a INF\uff0c (n + 1) + today ---> T \uff0c\u5bb9\u91cf\u4e3a INF; \u5728\u4ece\u6bcf\u4e00\u4e2a\u98de\u8239\u524d\u4e00\u5929\u6240\u5728\u7684\u592a\u7a7a\u7ad9\u8fde\u5411\u540e\u4e00\u5929\u7684\u592a\u7a7a\u7ad9\uff0c\u6d41\u91cf\u4e3a\u98de\u8239\u53ef\u5bb9\u7eb3\u4eba \u6570\uff1b \u5728\u6700\u5f00\u59cb\u7684\u65f6\u5019 \u94fe\u63a5\u4e00\u6761\uff0c S ----> 0 \uff0c\u5bb9\u91cf\u4e3a INF \u7684\u8fb9 \u8dd1\u6700\u5927\u6d41\u76f4\u5230\u4e0d\u5c0f\u4e8e\u603b\u4eba\u6570\u5373\u53ef\u3002\uff08\u6bcf\u4e00\u5929\u7684\u6700\u5927\u6d41\u5e94\u7d2f\u52a0\u8d77\u6765\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 #pragma GCC optimize(2) #include <bits/stdc++.h> #define read(a) scanf(\"%d\", &a) #define readl(a) scanf(\"%lld\", &a) #define reads(a) scanf(\"%s\", a) #define readc(a) scanf(\"%c\", &a) #define pb push_back #define mem(a) memset(a, 0, sizeof(a)) #define Buff ios::sync_with_stdio(false) typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; const int N = 1e5 + 7 ; const int M = 1e6 + 7 ; const int _N = 102 ; const int base = 100 ; int n , m , S , T ; struct edge 66 { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; int pre [ _N ], station [ _N ][ _N ], r [ _N ], H [ _N ]; int head [ N ], d [ N ], cur [ N ], gap [ N ]; edge e [ M ]; class ISAP { public : int S , T , n , m , cnt , K ; void addedge ( int u , int v , int cap ) { e [ ++ cnt ] = edge ( v , head [ u ], cap ); head [ u ] = cnt ; e [ ++ cnt ] = edge ( u , head [ v ], 0 ); head [ v ] = cnt ; // printf(\"%d --- %d, %d\\n\", u, v, cap); } // \u5efa\u56fe void buildGraph () { // \u521d\u59cb\u5316\u90e8\u5206 read ( n ); read ( m ); read ( K ); mem ( head ); cnt = 1 ; S = N - 2 ; T = N - 1 ; for ( int i = 1 ; i <= m ; i ++ ) { read ( H [ i ]); read ( r [ i ]); for ( int j = 1 ; j <= r [ i ]; j ++ ) read ( station [ i ][ j ]); pre [ i ] = 1 ; } n += 2 ; addedge ( S , 0 , INF ); int ans = 0 ; for ( int day = 1 ; day <= 30 ; day ++ ) 67 { int today = n * day , yesterday = n * ( day - 1 ), now ; for ( int i = 0 ; i < n ; i ++ ) addedge ( yesterday + i , today + i , INF ); addedge ( today + n - 1 , T , INF ); for ( int i = 1 ; i <= m ; i ++ ) { now = pre [ i ] + 1 ; if ( now > r [ i ]) now = 1 ; addedge ( station [ i ][ pre [ i ]] + yesterday , station [ i ][ now ] + today , H [ i ]); pre [ i ] = now ; } ans += get_maxFlow (); if ( ans >= K ) { printf ( \"%d \\n \" , day ); return ; } } printf ( \"%d \\n \" , 0 ); } // \u627e\u589e\u5e7f\u8def void bfs () { queue < int > q ; for ( int i = 0 ; i <= T ; i ++ ) { cur [ i ] = head [ i ]; d [ i ] = gap [ i ] = 0 ; } q . push ( T ); d [ T ] = gap [ 1 ] = 1 ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ]) continue ; 68 d [ v ] = d [ u ] + 1 ; ++ gap [ d [ v ]]; q . push ( v ); } } } int dfs ( int u , int flow ) { if ( u == T ) return flow ; int delta = 0 , v , temp ; for ( int & i = cur [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] + 1 != d [ u ]) continue ; temp = dfs ( v , min ( flow - delta , e [ i ]. cap )); if ( temp ) { e [ i ]. cap -= temp ; e [ i ^ 1 ]. cap += temp ; delta += temp ; } if ( flow == delta ) return flow ; } if ( ! ( -- gap [ d [ u ]])) d [ S ] = T + 1 ; ++ gap [ ++ d [ u ]]; cur [ u ] = head [ u ]; return delta ; } int get_maxFlow () { bfs (); int maxFlow = 0 ; while ( d [ S ] <= T ) maxFlow += dfs ( S , INF ); return maxFlow ; } }; 69 ISAP ways ; signed main () { ways . buildGraph (); return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"ISAP\u7b97\u6cd5"},{"location":"Graph/KM%E7%AE%97%E6%B3%95/","text":"///HDU2255 \u6c42\u6700\u4f18\u5339\u914d \u9898\u610f\uff1a\u6709 N \u5bb6\u8001\u767e\u59d3\u548c N \u95f4\u623f\u5b50\uff0c\u8981\u7ed9\u6bcf\u5bb6\u5206\u914d\u4e00\u95f4\u623f\uff0c\u6bcf\u4e2a\u6751 \u6c11\u5bf9\u4e0d\u540c\u7684\u623f\u5b50\u51fa\u4ef7\u4e0d\u540c\uff0c\u73b0\u5728\u6751\u957f\u8981\u8ba9\u5229\u76ca\u6700\u5927\u5316\uff0c\u95ee\u5e94\u600e\u4e48\u5206\u914d\u624d\u80fd\u8ba9\u6751\u6c11\u51fa\u7684\u94b1\u6570\u603b \u548c\u6700\u5927\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <cstdio> #include <cstring> #include <algorithm> using namespace std ; int mp [ 303 ][ 303 ]; //\u8bb0\u5f55\u6751\u6c11\u5bf9\u5404\u4e2a\u623f\u5b50\u51fa\u4ef7\u60c5\u51b5 int lin [ 303 ]; //\u6807\u8bb0\u623f\u5b50\u6240\u5339\u914d\u5230\u7684\u6751\u6c11 int viy [ 303 ]; //\u6807\u8bb0\u623f\u5b50\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7 int vix [ 303 ]; //\u6807\u8bb0\u6751\u6c11\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7 int x [ 303 ]; //\u8bb0\u5f55\u6751\u6c11\u7684\u70b9\u6743 int y [ 303 ]; //\u8bb0\u5f55\u623f\u5b50\u7684\u70b9\u6743 int n ; int lack , t ; //lack \u8bb0\u5f55\u5355\u6b21\u8981\u6539\u53d8\u7684\u70b9\u6743\u5927\u5c0f int dfs ( int u ) { vix [ u ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! viy [ i ]) { 56 t = x [ u ] + y [ i ] - mp [ u ][ i ]; if ( t == 0 ) //t \u4e3a\u96f6\u4ee3\u8868 u \u6751\u6c11\u53ef\u4ee5\u548c i \u623f\u5b50\u5339\u914d { viy [ i ] = 1 ; if ( dfs ( lin [ i ]) || ! lin [ i ]) //i\u623f\u5b50\u6ca1\u5339\u914d\u8fc7\u6216i\u623f\u5b50\u5339\u914d\u5230\u7684\u6751\u6c11\u53ef\u4ee5\u4e0e\u5176\u5b83\u623f \u5b50\u5339\u914d { lin [ i ] = u ; return 1 ; } } else if ( lack > t ) lack = t ; } } return 0 ; } void KM () { memset ( y , 0 , sizeof ( y )); memset ( x , 0 , sizeof ( x )); memset ( lin , 0 , sizeof ( lin )); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) x [ i ] = max ( x [ i ], mp [ i ][ j ]); //x[i]\u8bb0\u5f55 i \u6751\u6c11\u6240\u6709\u51fa\u4ef7\u4e2d\u6700\u5927\u7684\u503c for ( int i = 1 ; i <= n ; i ++ ) { while ( 1 ) { memset ( vix , 0 , sizeof ( vix )); memset ( viy , 0 , sizeof ( viy )); lack = 1e9 + 7 ; if ( dfs ( i )) //i \u6751\u6c11\u5339\u914d\u6210\u529f break ; for ( int i = 1 ; i <= n ; i ++ ) { if ( vix [ i ]) x [ i ] -= lack ; //\u6751\u6c11\u70b9\u6743\u51cf\u5c0f if ( viy [ i ]) y [ i ] += lack ; //\u623f\u5b50\u70b9\u6743\u589e\u5927 } } } } int main () { 57 while ( ~ scanf ( \"%d\" , & n )) { memset ( mp , 0 , sizeof ( mp )); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) { scanf ( \"%d\" , & mp [ i ][ j ]); } KM (); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += mp [ lin [ i ]][ i ]; //\u6c42\u548c } printf ( \"%d \\n \" , ans ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4f73\u59ae","title":"KM \u7b97\u6cd5"},{"location":"Graph/SPFA%E8%B4%B9%E7%94%A8%E6%B5%81/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 //\u6d1b\u8c37 P3381 typedef long long ll ; using namespace std ; const int INF = 1e18 + 7 ; const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; const int base = 100 ; ll dis [ N ]; struct edge { int to , nex ; ll cap , cost ; edge ( int to = 0 , int nex = 0 , ll cap = 0 , ll cost = 0 ) : to ( to ), nex ( nex ), cap ( cap ), cost ( cost ) {} }; struct cmp { bool operator ()( int a , int b ) { return dis [ a ] > dis [ b ]; } }; class MCMF // MinCostMaxFlow { public : int S , T , n , m , cnt ; int head [ N ], Inq [ N ], pre [ N ]; ll flow [ N ]; edge e [ M ]; void addedge ( int u , int v , ll cap , ll cost ) { 70 e [ ++ cnt ] = edge ( v , head [ u ], cap , cost ); head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 ; i <= m ; i ++ ) { int u , v ; ll cap , cost ; read ( u ); read ( v ); readl ( cap ); readl ( cost ); addedge ( u , v , cap , cost ); addedge ( v , u , 0ll , - cost ); } } // \u627e\u589e\u5e7f\u8def bool SPFA () { priority_queue < int , vector < int > , cmp > q ; for ( int i = 0 ; i <= n ; i ++ ) { dis [ i ] = INF ; Inq [ i ] = 0 ; } dis [ S ] = 0 ; Inq [ S ] = 1 ; flow [ S ] = INF ; // q.push(make_pair(-dis[S], S)); q . push ( S ); int u , v ; ll cost ; // pair<ll, int> tmp; while ( q . size ()) { u = q . top (); q . pop (); Inq [ u ] = 0 ; // u = tmp.second; cost = -tmp.first; for ( int i = head [ u ]; i ; i = e [ i ]. nex ) 71 { v = e [ i ]. to ; // cout << \"u = \" << u << \" , v = \" << v << \"\\n\"; if ( ! e [ i ]. cap ) continue ; cost = dis [ u ] + e [ i ]. cost ; if ( dis [ v ] > cost ) { dis [ v ] = cost ; flow [ v ] = min ( flow [ u ], e [ i ]. cap ); pre [ v ] = i ; if ( ! Inq [ v ]) { q . push ( v ); Inq [ v ] = 1 ; } } } } return dis [ T ] != INF ; } void update () { int u = T ; while ( u != S ) { int i = pre [ u ]; e [ i ]. cap -= flow [ T ]; e [ i ^ 1 ]. cap += flow [ T ]; u = e [ i ^ 1 ]. to ; } } void get_MCMF () { ll maxFlow = 0 ; ll minCost = 0ll ; while ( SPFA ()) { update (); maxFlow += flow [ T ]; minCost += flow [ T ] * dis [ T ]; } printf ( \"%lld %lld \\n \" , maxFlow , minCost ); } 72 }; MCMF ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); ways . get_MCMF (); // printf(\"%lld %lld\\n\", tmp.second, tmp.first); } return 0 ; } \u4f8b\u9898\uff1a \u7f51\u7edc\u6d41 24 \u9898 \u9910\u5dfe\u8ba1\u5212 LOJ 6008 \u9898\u610f\uff1a \u4e00\u4e2a\u9910\u5385\u5728\u76f8\u7ee7\u7684 N \u5929\u91cc,\u6bcf\u5929\u9700\u7528\u7684\u9910\u5dfe\u6570\u4e0d\u5c3d\u76f8\u540c\u3002\u5047\u8bbe\u7b2c i \u5929\u9700\u8981 ri \u5757\u9910\u5dfe ( i=1,2,...,N)\u3002\u9910\u5385\u53ef\u4ee5\u8d2d\u4e70\u65b0\u7684\u9910\u5dfe,\u6bcf\u5757\u9910\u5dfe\u7684\u8d39\u7528\u4e3a p \u5206;\u6216\u8005\u628a\u65e7\u9910\u5dfe\u9001\u5230\u5feb\u6d17\u90e8,\u6d17\u4e00 \u5757\u9700 m \u5929,\u5176\u8d39\u7528\u4e3a f \u5206;\u6216\u8005\u9001\u5230\u6162\u6d17\u90e8,\u6d17\u4e00\u5757\u9700 n(n>m),\u5176\u8d39\u7528\u4e3a s \u5206(s < f). \u6bcf\u5929\u7ed3\u675f \u65f6,\u9910\u5385\u5fc5\u987b\u51b3\u5b9a\u5c06\u591a\u5c11\u5757\u810f\u7684\u9910\u5dfe\u9001\u5230\u5feb\u6d17\u90e8,\u591a\u5c11\u5757\u9910\u5dfe\u9001\u5230\u6162\u6d17\u90e8,\u4ee5\u53ca\u591a\u5c11\u5757\u4fdd\u5b58\u8d77 \u6765\u5ef6\u671f\u9001\u6d17\u3002\u4f46\u662f\u6bcf\u5929\u6d17\u597d\u7684\u9910\u5dfe\u548c\u8d2d\u4e70\u7684\u65b0\u9910\u5dfe\u6570\u4e4b\u548c,\u8981\u6ee1\u8db3\u5f53\u5929\u7684\u9700\u6c42\u91cf\u3002\u8bd5\u8bbe\u8ba1\u4e00 \u4e2a\u7b97\u6cd5\u4e3a\u9910\u5385\u5408\u7406\u5730\u5b89\u6392\u597d N \u5929\u4e2d\u9910\u5dfe\u4f7f\u7528\u8ba1\u5212,\u4f7f\u603b\u7684\u82b1\u8d39\u6700\u5c0f\u3002\u7f16\u7a0b\u627e\u51fa\u4e00\u4e2a\u6700\u4f73\u9910\u5dfe \u4f7f\u7528\u8ba1\u5212\u3002 \u5206\u6790\uff1a \u6211\u4eec\u4e0d\u59a8\u5148\u8ba9\u6bcf\u5929\u5f00\u59cb\u65f6\u5f97\u5230\u7684 r[i]\u6761\u5e72\u51c0\u7684\u9910\u5dfe\uff08\u5de6\u8fb9\u4e00\u5217\u7684\u8282\u70b9\uff09\u6d41\u5411 t\uff0c\u7136\u540e\u518d \u5728\u6bcf\u5929\u7ed3\u675f\u65f6\u4ece s \u8865\u56de r[i]\u6761\u810f\u7684\u9910\u5dfe\uff08\u4ece s \u5411\u53f3\u8fb9\u4e00\u5217\u7684\u8282\u70b9\u8fde r[i],0 \u7684\u8fb9\uff09\uff0c\u5f97\u5230\u65b0\u56fe\u7684 \u94fe\u63a5\u65b9\u5f0f\uff1a 1 2 3 4 5 6 7 s -> i (r,p) \u6bcf\u5929\u65e9\u6668\u53ef\u4ee5\u4e70\u6700\u591a r \u6761\u65b0\u9910\u5dfe \u4e00\u6761 p \u5206 s -> i' (r,0) \u6bcf\u5929\u7528\u5269\u4e0b r \u6761\u810f\u9910\u5dfe \u6ca1\u6709\u4ee3\u4ef7 i -> t (r,0) \u6bcf\u5929\u8981\u7528 r \u6761\u5e72\u51c0\u9910\u5dfe \u6ca1\u6709\u4ee3\u4ef7 i' -> i+m (inf,f)\u810f\u6bdb\u5dfe\u9001\u5230\u5feb\u6d17\u5e97 \u6d17\u5e72\u51c0\u9001\u56de\u6765\u662f\u7b2c i+m \u5929\u6bcf\u6761\u82b1\u8d39\u4ee3\u4ef7 f \u5206 i' ->i+n (inf,s)\u810f\u6bdb\u5dfe\u9001\u5230\u6162\u6d17\u5e97 \u6d17\u5e72\u51c0\u9001\u56de\u6765\u662f\u7b2c i+n \u5929 \u6bcf\u6761\u82b1\u8d39\u4ee3\u4ef7 s \u5206 i' -> (i+1)' (inf,s) \u6bcf\u6761\u810f\u6bdb\u5dfe\u7559\u5230\u7b2c\u4e8c\u5929\u518d\u5904\u7406 \u6ca1\u6709\u4ee3\u4ef7 \u6700\u540e\u8dd1\u4e00\u6b21\u6700\u5c0f\u8d39\u7528\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #pragma GCC optimize(2) #include <bits/stdc++.h> #define read(a) scanf(\"%d\", &a) #define readl(a) scanf(\"%lld\", &a) #define reads(a) scanf(\"%s\", a) #define readc(a) scanf(\"%c\", &a) #define pb push_back #define mem(a) memset(a, 0, sizeof(a)) #define Buff ios::sync_with_stdio(false) 73 typedef long long ll ; using namespace std ; const ll INF = 1e16 + 7 ; const int N = 2e5 + 7 ; const int M = 1e6 + 7 ; ll dis [ N ], flow [ N ]; int head [ N ], cnt , Inq [ N ], pre [ N ]; int S , T , n , d1 , d2 ; ll p , f , s ; struct edge { int to , nex ; ll w , cost ; edge ( int _to = 0 , ll _w = 0 , ll _cost = 0 , int _nex = 0 ) { to = _to ; nex = _nex ; w = _w ; cost = _cost ; } } e [ M ]; void addedge ( int u , int v , ll w , ll cost ) { e [ ++ cnt ] = edge ( v , w , cost , head [ u ]); head [ u ] = cnt ; e [ ++ cnt ] = edge ( u , 0ll , - cost , head [ v ]); head [ v ] = cnt ; } queue < int > q ; bool SPAF () { while ( q . size ()) q . pop (); for ( int i = 0 ; i < N ; i ++ ) { dis [ i ] = INF ; Inq [ i ] = 0 ; } q . push ( S ); dis [ S ] = 0 ; Inq [ S ] = 1 ; flow [ S ] = INF ; int u , v ; ll cost ; while ( q . size ()) { u = q . front (); q . pop (); Inq [ u ] = 0 ; for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { if ( ! e [ i ]. w ) continue ; v = e [ i ]. to ; cost = dis [ u ] + e [ i ]. cost ; if ( dis [ v ] > cost ) 74 { dis [ v ] = cost ; flow [ v ] = min ( flow [ u ], e [ i ]. w ); pre [ v ] = i ; if ( ! Inq [ v ]) { q . push ( v ); Inq [ v ] = 1 ; } } } } return dis [ T ] != INF ; } ll maxFlow , minCost ; void update () { int u = T , i ; while ( u != S ) { i = pre [ u ]; e [ i ]. w -= flow [ T ]; e [ i ^ 1 ]. w += flow [ T ]; u = e [ i ^ 1 ]. to ; } maxFlow += flow [ T ]; minCost += flow [ T ] * dis [ T ]; } void EK () { maxFlow = minCost = 0ll ; while ( SPAF ()) update (); printf ( \"%lld \\n \" , minCost ); } void buildGraph () { read ( n ); readl ( p ); read ( d1 ); readl ( f ); read ( d2 ); readl ( s ); mem ( head ); cnt = 1 ; S = 0 ; T = n << 1 | 1 ; for ( int i = 1 ; i <= n ; i ++ ) 75 { ll r ; readl ( r ); addedge ( S , i , r , p ); addedge ( S , i + n , r , 0ll ); addedge ( i , T , r , 0ll ); if ( i + 1 <= n ) addedge ( i + n , i + 1 + n , INF , 0ll ); if ( i + d1 <= n ) addedge ( i + n , i + d1 , INF , f ); if ( i + d2 <= n ) addedge ( i + n , i + d2 , INF , s ); } } signed main () { buildGraph (); EK (); return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"SPFA \u8d39\u7528\u6d41"},{"location":"Graph/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/","text":"///POJ1274 \u6c42\u6700\u5927\u5339\u914d \u9898\u610f\uff1a\u6709 N \u6761\u725b\u548c M \u4e2a\u725b\u68da\uff0c\u6bcf\u6761\u725b\u90fd\u6709\u81ea\u5df1\u559c\u6b22\u7684\u51e0\u4e2a\u725b\u68da\uff0c\u95ee \u6700\u591a\u53ef\u4ee5\u8ba9\u591a\u5c11\u6761\u725b\u5446\u5728\u81ea\u5df1\u559c\u6b22\u7684\u725b\u68da\uff08\u725b\u68da\u548c\u725b\u4e00\u5bf9\u4e00\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <cstdio> #include <cstring> using namespace std ; typedef long long ll ; const int N = 1e5 + 10 ; const int mod = 1e9 + 7 ; int d [ 205 ][ 205 ]; //d \u6570\u7ec4\u6807\u8bb0\u6709\u54ea\u4e9b\u8fb9 int lin [ 205 ]; //lin \u6570\u7ec4\u6807\u8bb0\u725b\u68da\u5339\u914d\u5230\u4e86\u54ea\u5934\u725b int vi [ 205 ]; //vi \u6570\u7ec4\u6807\u8bb0\u725b\u68da\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7 int n , m ; int fin ( int x ) { for ( int i = 1 ; i <= m ; i ++ ) { if ( d [ i ][ x ] && vi [ i ] == 0 ) { vi [ i ] = 1 ; if ( lin [ i ] == 0 || fin ( lin [ i ]) == 1 ) //i \u53f7\u725b\u68da\u8fd8\u6ca1\u6709\u5339\u914d\u725b\u6216\u53ef\u4ee5\u4e3a\u5b83\u6240\u5339\u914d\u7684\u725b\u627e\u4e00 \u4e2a\u65b0\u7684\u6ee1\u610f\u7684\u725b\u68da { lin [ i ] = x ; return 1 ; } } } return 0 ; } int main () { while ( ~ scanf ( \"%d%d\" , & n , & m )) { memset ( d , 0 , sizeof ( d )); memset ( lin , 0 , sizeof ( lin )); int c , u ; 55 for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & c ); while ( c -- ) { scanf ( \"%d\" , & u ); d [ i ][ u ] = 1 ; //\u8fde\u8fb9 } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { memset ( vi , 0 , sizeof ( vi )); //vi \u6570\u7ec4\u6bcf\u6b21\u90fd\u8981\u6e05 if ( fin ( i ) == 1 ) //i \u53f7\u725b\u627e\u5230\u53ef\u4ee5\u4e0e\u5b83\u5339\u914d\u7684\u725b\u68da cnt ++ ; } printf ( \"%d \\n \" , cnt ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4f73\u59ae","title":"\u5308\u7259\u5229\u7b97\u6cd5"},{"location":"Graph/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","text":"","title":"\u62d3\u6251\u6392\u5e8f"},{"location":"Graph/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","text":"","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"Math/","text":"","title":"Index"},{"location":"Others/","text":"","title":"Index"},{"location":"Others/Time/","text":"1. \u641c\u7d22 \u00b6 n\u4e2a\u70b9/\u72b6\u6001,m\u6761\u8fb9 DFS BFS \u53cc\u5411\u641c\u7d22 \u8bb0\u5fc6\u5316\u641c\u7d22 \u6781\u5927\u6781\u5c0f\u641c\u7d22 \u542f\u53d1\u5f0f\u641c\u7d22 \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u5907\u6ce8 \u4e0d\u7a33\u5b9a \u4e0e\u542f\u53d1\u51fd\u6570\u6709\u5173 2. \u52a8\u6001\u89c4\u5212 \u00b6 \u72b6\u538bDP \u6811\u5f62DP \u533a\u95f4DP \u6570\u4f4dDP \u6982\u7387DP \u65f6\u95f4\u590d\u6742\u5ea6 O(N^2*2^n) O(N^2*2^n) O(N) O(N) O(N^3) O(N^3) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u7a7a\u95f4\u590d\u6742\u5ea6 O(2^n) O(2^n) O(N) O(N) O(N^2) O(N^2) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u5907\u6ce8 \u90fd\u662f\u6570\u7ec4\u5927\u5c0f \u90fd\u662f\u6570\u7ec4\u5927\u5c0f 3. \u6570\u636e\u7ed3\u6784 \u00b6 \u4e00\u7ef4\u6811\u72b6\u6570\u7ec4 \u6811\u5f62DP ST\u8868 RMQ \u7ebf\u6bb5\u6811 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) O(\\log N * \\log M) O(\\log N * \\log M) O(1) O(1) O(N\\log N) O(N\\log N) O(\\log N) O(\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) O(N\\log N) O(N\\log N) O(N) O(N) O(N) O(N) \u5907\u6ce8 N*M\u7684\u77e9\u9635 \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u7a7a\u95f44N\uff0c\u9884\u5904\u7406\u4e3a\u7a7a\u95f4\u5927\u5c0f \u6811\u94fe\u5256\u5206-\u70b9\u5256 \u6811\u94fe\u5256\u5206-\u8fb9\u5256 \u5206\u5757\u7b97\u6cd5 \u83ab\u961f\u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(10*N) O(10*N) O(10*N) O(10*N) O(n) O(n) O(n) O(n) \u5907\u6ce8 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u70b9\u5206\u6cbb caldis() \u6c42\u91cd\u5fc3 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84 4. \u56fe\u8bba \u00b6 \u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u77e9\u9635\uff09 \u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u8868\uff09 KM \u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N^{3}) O(N^{3}) O(N*M) O(N*M) O(N^{3}) O(N^{3}) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N^{2}) O(N^{2}) O(M+N) O(M+N) O(N^{2}) O(N^{2}) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84 \u7f51\u7edc\u6d41-EK \u7f51\u7edc\u6d41-Dinic \u7f51\u7edc\u6d41-ISAP \u8d39\u7528\u6d41-SPFA \u65f6\u95f4\u590d\u6742\u5ea6 O(N*M*M) O(N*M*M) O(N*N*M) O(N*N*M) O(N*N*M) O(N*N*M) O(V+E+\\log V) O(V+E+\\log V) \u7a7a\u95f4\u590d\u6742\u5ea6 O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) \u5907\u6ce8 N \u4e3a\u8282\u70b9\u6570\uff0c M \u4e3a\u8fb9\u6570 \u6700\u5927\u6d41\u8dd1\u6700\u5927\u5339 \u914d \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n*sqrt(m)) \u6240\u6709\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f \u6700\u5927\u4e0a\u754c\uff0c\u5e73\u5e38\u90fd\u8fbe\u4e0d \u5230 5. \u5b57\u7b26\u4e32 \u00b6 \u5b57\u5178\u6811 AC \u81ea\u52a8\u673a \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N*K) O(N*K) O(N*K) O(N*K) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6 6. \u8ba1\u7b97\u51e0\u4f55 \u00b6 Graham \u534a\u5e73\u9762\u4ea4 \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\log N) O(N \\log N) O(N \\log N) O(N \\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6","title":"\u65f6\u95f4/\u7a7a\u95f4\u590d\u6742\u5ea6"},{"location":"Others/Time/#1","text":"n\u4e2a\u70b9/\u72b6\u6001,m\u6761\u8fb9 DFS BFS \u53cc\u5411\u641c\u7d22 \u8bb0\u5fc6\u5316\u641c\u7d22 \u6781\u5927\u6781\u5c0f\u641c\u7d22 \u542f\u53d1\u5f0f\u641c\u7d22 \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u5907\u6ce8 \u4e0d\u7a33\u5b9a \u4e0e\u542f\u53d1\u51fd\u6570\u6709\u5173","title":"1. \u641c\u7d22"},{"location":"Others/Time/#2","text":"\u72b6\u538bDP \u6811\u5f62DP \u533a\u95f4DP \u6570\u4f4dDP \u6982\u7387DP \u65f6\u95f4\u590d\u6742\u5ea6 O(N^2*2^n) O(N^2*2^n) O(N) O(N) O(N^3) O(N^3) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u7a7a\u95f4\u590d\u6742\u5ea6 O(2^n) O(2^n) O(N) O(N) O(N^2) O(N^2) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u5907\u6ce8 \u90fd\u662f\u6570\u7ec4\u5927\u5c0f \u90fd\u662f\u6570\u7ec4\u5927\u5c0f","title":"2. \u52a8\u6001\u89c4\u5212"},{"location":"Others/Time/#3","text":"\u4e00\u7ef4\u6811\u72b6\u6570\u7ec4 \u6811\u5f62DP ST\u8868 RMQ \u7ebf\u6bb5\u6811 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) O(\\log N * \\log M) O(\\log N * \\log M) O(1) O(1) O(N\\log N) O(N\\log N) O(\\log N) O(\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) O(N\\log N) O(N\\log N) O(N) O(N) O(N) O(N) \u5907\u6ce8 N*M\u7684\u77e9\u9635 \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u7a7a\u95f44N\uff0c\u9884\u5904\u7406\u4e3a\u7a7a\u95f4\u5927\u5c0f \u6811\u94fe\u5256\u5206-\u70b9\u5256 \u6811\u94fe\u5256\u5206-\u8fb9\u5256 \u5206\u5757\u7b97\u6cd5 \u83ab\u961f\u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(10*N) O(10*N) O(10*N) O(10*N) O(n) O(n) O(n) O(n) \u5907\u6ce8 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u70b9\u5206\u6cbb caldis() \u6c42\u91cd\u5fc3 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84","title":"3. \u6570\u636e\u7ed3\u6784"},{"location":"Others/Time/#4","text":"\u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u77e9\u9635\uff09 \u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u8868\uff09 KM \u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N^{3}) O(N^{3}) O(N*M) O(N*M) O(N^{3}) O(N^{3}) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N^{2}) O(N^{2}) O(M+N) O(M+N) O(N^{2}) O(N^{2}) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84 \u7f51\u7edc\u6d41-EK \u7f51\u7edc\u6d41-Dinic \u7f51\u7edc\u6d41-ISAP \u8d39\u7528\u6d41-SPFA \u65f6\u95f4\u590d\u6742\u5ea6 O(N*M*M) O(N*M*M) O(N*N*M) O(N*N*M) O(N*N*M) O(N*N*M) O(V+E+\\log V) O(V+E+\\log V) \u7a7a\u95f4\u590d\u6742\u5ea6 O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) \u5907\u6ce8 N \u4e3a\u8282\u70b9\u6570\uff0c M \u4e3a\u8fb9\u6570 \u6700\u5927\u6d41\u8dd1\u6700\u5927\u5339 \u914d \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n*sqrt(m)) \u6240\u6709\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f \u6700\u5927\u4e0a\u754c\uff0c\u5e73\u5e38\u90fd\u8fbe\u4e0d \u5230","title":"4. \u56fe\u8bba"},{"location":"Others/Time/#5","text":"\u5b57\u5178\u6811 AC \u81ea\u52a8\u673a \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N*K) O(N*K) O(N*K) O(N*K) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6","title":"5. \u5b57\u7b26\u4e32"},{"location":"Others/Time/#6","text":"Graham \u534a\u5e73\u9762\u4ea4 \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\log N) O(N \\log N) O(N \\log N) O(N \\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6","title":"6. \u8ba1\u7b97\u51e0\u4f55"},{"location":"Others/exem/","text":"\u4e00\u3001\u641c\u7d22 \u00b6 1.1 \u6df1\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahrbust 1743 1.2 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahdu 2612 1.3 \u53cc\u5411\u641c\u7d22\uff1a 1.4 \u8bb0\u5fc6\u5316\u641c\u7d22\uff1ahdoj1078 1.5 \u6781\u5927\u6781\u5c0f\u641c\u7d22\uff1apoj1568 1.6 \u542f\u53d1\u5f0f\u641c\u7d22\uff1apoj1077 \u4e8c\u3001\u52a8\u6001\u89c4\u5212 \u00b6 2.1 \u72b6\u538b Dp\uff1ahdu 5418 2.2 \u6811\u5f62 Dp\uff1aP1352 2.3 \u533a\u95f4 Dp\uff1anoi1995 2.4 \u6570\u4f4d Dp\uff1ahttps: // loj.ac/problems/tag/104 2.5 \u6982\u7387&\u671f\u671b Dp\uff1ahttps: // vjudge.net/contest/76505 \u4e09\u3001\u6570\u636e\u7ed3\u6784 \u00b6 3.1 \u4e00\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj3468 3.2 \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj2155 3.3 ST \u8868\uff1a\u6d1b\u8c37 p3865 3.4 Rmq\uff1apoj3264 3.5 \u7ebf\u6bb5\u6811\uff1aPoj3468, HDU3911, HDU1542 3.6.1 \u6811\u94fe\u5256\u5206-\u70b9\u5256\uff1a\u6d1b\u8c37 P3384\uff0cHYSBZ 4196\uff0cHYSBZ 3531\uff0cHYSBZ 2243 3.6.2 \u6811\u94fe\u5256\u5206-\u8fb9\u5256\uff1a\u6d1b\u8c37 P4315\uff0cHYSBZ 2157 3.7 \u5206\u5757\u7b97\u6cd5\uff1aPOJ 3468 3.8 \u83ab\u961f\u7b97\u6cd5\uff1aZOJ 2038 3.9 \u70b9\u5206\u6cbb\uff1aPOJ 1655\uff0cPOJ 2114\uff0cPOJ 1741\uff0cHDU 4812\uff0cHYSBZ 2152\uff0cHDU 5977\uff0c POJ 1987 \u56db\u3001\u56fe\u8bba \u00b6 4.1.1 \u5308\u7259\u5229\u7b97\u6cd5\uff1aPOJ1274\u3001POJ1469\u3001POJ3041\u3001POJ1325\u3001POJ1466\u3001POJ2226\u3001 HDU1281 4.1.2 KM \u7b97\u6cd5\uff1aHDU2255 4.2 \u6700\u5927\u6d41\uff1a\u6d1b\u8c37 P3376\u3001LOJ 6015 4.3 \u8d39\u7528\u6d41\uff1a\u6d1b\u8c37 P3381\u3001LOJ 6008 \u4e94\u3001\u5b57\u7b26\u4e32 \u00b6 5.1 \u5b57\u5178\u6811\uff1ahdu1251 5.2 AC \u81ea\u52a8\u673a\uff1ahdu2222 \u516d\u3001\u8ba1\u7b97\u51e0\u4f55 \u00b6 6.1 \u70b9\u79ef\u53c9\u79ef\u7684\u5e94\u7528\uff1apoj2318 6.2 Graham\uff1apoj 1912 6.3 \u534a\u5e73\u9762\u4ea4\uff1apoj3525 6.4 \u65cb\u8f6c\u5361\u58f3\uff1aAizu CGL_4_B","title":"\u4e60\u9898"},{"location":"Others/exem/#_1","text":"1.1 \u6df1\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahrbust 1743 1.2 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahdu 2612 1.3 \u53cc\u5411\u641c\u7d22\uff1a 1.4 \u8bb0\u5fc6\u5316\u641c\u7d22\uff1ahdoj1078 1.5 \u6781\u5927\u6781\u5c0f\u641c\u7d22\uff1apoj1568 1.6 \u542f\u53d1\u5f0f\u641c\u7d22\uff1apoj1077","title":"\u4e00\u3001\u641c\u7d22"},{"location":"Others/exem/#_2","text":"2.1 \u72b6\u538b Dp\uff1ahdu 5418 2.2 \u6811\u5f62 Dp\uff1aP1352 2.3 \u533a\u95f4 Dp\uff1anoi1995 2.4 \u6570\u4f4d Dp\uff1ahttps: // loj.ac/problems/tag/104 2.5 \u6982\u7387&\u671f\u671b Dp\uff1ahttps: // vjudge.net/contest/76505","title":"\u4e8c\u3001\u52a8\u6001\u89c4\u5212"},{"location":"Others/exem/#_3","text":"3.1 \u4e00\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj3468 3.2 \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj2155 3.3 ST \u8868\uff1a\u6d1b\u8c37 p3865 3.4 Rmq\uff1apoj3264 3.5 \u7ebf\u6bb5\u6811\uff1aPoj3468, HDU3911, HDU1542 3.6.1 \u6811\u94fe\u5256\u5206-\u70b9\u5256\uff1a\u6d1b\u8c37 P3384\uff0cHYSBZ 4196\uff0cHYSBZ 3531\uff0cHYSBZ 2243 3.6.2 \u6811\u94fe\u5256\u5206-\u8fb9\u5256\uff1a\u6d1b\u8c37 P4315\uff0cHYSBZ 2157 3.7 \u5206\u5757\u7b97\u6cd5\uff1aPOJ 3468 3.8 \u83ab\u961f\u7b97\u6cd5\uff1aZOJ 2038 3.9 \u70b9\u5206\u6cbb\uff1aPOJ 1655\uff0cPOJ 2114\uff0cPOJ 1741\uff0cHDU 4812\uff0cHYSBZ 2152\uff0cHDU 5977\uff0c POJ 1987","title":"\u4e09\u3001\u6570\u636e\u7ed3\u6784"},{"location":"Others/exem/#_4","text":"4.1.1 \u5308\u7259\u5229\u7b97\u6cd5\uff1aPOJ1274\u3001POJ1469\u3001POJ3041\u3001POJ1325\u3001POJ1466\u3001POJ2226\u3001 HDU1281 4.1.2 KM \u7b97\u6cd5\uff1aHDU2255 4.2 \u6700\u5927\u6d41\uff1a\u6d1b\u8c37 P3376\u3001LOJ 6015 4.3 \u8d39\u7528\u6d41\uff1a\u6d1b\u8c37 P3381\u3001LOJ 6008","title":"\u56db\u3001\u56fe\u8bba"},{"location":"Others/exem/#_5","text":"5.1 \u5b57\u5178\u6811\uff1ahdu1251 5.2 AC \u81ea\u52a8\u673a\uff1ahdu2222","title":"\u4e94\u3001\u5b57\u7b26\u4e32"},{"location":"Others/exem/#_6","text":"6.1 \u70b9\u79ef\u53c9\u79ef\u7684\u5e94\u7528\uff1apoj2318 6.2 Graham\uff1apoj 1912 6.3 \u534a\u5e73\u9762\u4ea4\uff1apoj3525 6.4 \u65cb\u8f6c\u5361\u58f3\uff1aAizu CGL_4_B","title":"\u516d\u3001\u8ba1\u7b97\u51e0\u4f55"},{"location":"Search/","text":"","title":"Index"},{"location":"Search/BFS/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // bfs \u67e5\u627e \u4ece s \u70b9 \u80fd\u5426\u5230\u8fbe t \u70b9 class Bfs { public : bool vis [ N ]; queue < int > q ; void bfs ( int s , int t ) 3 { while ( ! q . emtpy ()) q . pop (); memset ( vis , true , sizeof ( vis )); vis [ s ] = false ; q . push ( s ); while ( ! q . empty ()) { int z = q . front (); q . pop (); if ( z == t ) return true ; // \u641c\u7d22 z \u70b9\u80fd\u591f\u5230\u8fbe\u7684\u6240\u6709\u70b9\uff0c\u5165\u961f\uff0c\u5e76\u4e14\u6807\u8bb0 } return false ; } }; \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22"},{"location":"Search/DFS/","text":"\u9898\u76ee\u94fe\u63a5\uff1a hrbust 1743 Word Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // hrbust 1743 \u9898\u610f: n*m \u5b57\u7b26\u77e9\u9635\uff0cq \u6b21\u67e5\u8be2\u67d0\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u662f\u77e9\u9635\u7684\u4e00\u6761\u8def\u5f84 #include <stdio.h> #include <string.h> #define N 55 char a [ N ][ N ]; char str [ N ]; int len ; // \u5b58 str \u5b57\u7b26\u4e32\u957f\u5ea6 bool vis [ N ][ N ]; //\u6bcf\u4e2a\u70b9\u53ea\u80fd\u8d70\u4e00\u6b21 int n , m ; class Dfs { public : int dx [ 10 ] = { 0 , 0 , - 1 , 1 }; // dx,dy \u7ec4\u6210\u4e0a\u4e0b\u5de6\u53f3 int dy [ 10 ] = { 1 , - 1 , 0 , 0 }; bool dfs ( int x , int y , int z ) { if ( z == len ) return true ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx > 0 && yy > 0 && xx <= n && yy <= m && a [ xx ][ yy ] == str [ z ] && vis [ xx ][ yy ]) { vis [ xx ][ yy ] = false ; if ( dfs ( xx , yy , z + 1 )) return true ; vis [ xx ][ yy ] = true ; } } return false ; } } dfs ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { 2 int q ; scanf ( \"%d %d %d\" , & n , & m , & q ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int qq = 0 ; qq < q ; qq ++ ) { scanf ( \"%s\" , str ); len = strlen ( str ); memset ( vis , true , sizeof ( vis )); int zt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { vis [ i ][ j ] = false ; if ( a [ i ][ j ] == str [ 0 ] && dfs . dfs ( i , j , 1 )) { zt = 1 ; break ; } vis [ i ][ j ] = true ; } if ( zt ) break ; } if ( zt ) printf ( \"Yes \\n \" ); else printf ( \"No \\n \" ); } printf ( \" \\n \" ); } } \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22"},{"location":"Search/DeSearch/","text":"// \u5bf9\u4e8e\u5355\u5411\u641c\u7d22\u6709 2^n 2^n \u53ef\u80fd\u7684\u60c5\u51b5\uff0c\u82e5\u4ece\u8d77\u59cb\u70b9\u548c\u7ec8\u70b9\u540c\u65f6\u641c\uff0c\u53ef\u4ee5\u53d8\u6210 2 \u4e2a 2^{(n/2)} 2^{(n/2)} \u79cd\u53ef\u80fd\uff0c\u7136\u540e\u8fdb\u884c\u5408\u5e76\u3002\u4f8b\u5982\uff1a\u6bcf\u6b21\u64cd\u4f5c\u53ef\u4ee5\u9009\u62e9*a \u6216\u8005+b\uff0c\u95ee\u6570\u5b57\u4ece n \u5f00\u59cb\u64cd\u4f5c 40 \u6b21 \u53d8\u6210 m \u7684\u53ef\u80fd\u6027\u6709\u591a\u5c11\u79cd\u3002\u53ef\u4ee5\u9009\u62e9\u6b63\u5411\u53cd\u5411\u540c\u65f6\u6c42\u51fa 2^{20} 2^{20} \u4e2a\u7b54\u6848\uff0c\u7136\u540e\u8fdb\u884c\u5408\u5e76\u3002 \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u53cc\u5411\u641c\u7d22"},{"location":"Search/Memory_Search/","text":"// \u4e00\u822c\u6765\u8bf4\u641c\u7d22\u7684\u7ed3\u679c\u6570\u91cf\u6709\u9650\uff0c\u56e0\u6b64\u5728\u641c\u7d22\u65f6\uff0c\u4f1a\u628a\u641c\u5230\u7684\u7ed3\u679c\u4e5f\u8bb0\u5f55\u5230\u4e00\u4e2a\u6570\u7ec4\uff0c \u4e0b\u6b21\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u3002 \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u8bb0\u5fc6\u5316\u641c\u7d22"},{"location":"Search/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //poj 1077 A* \u89e3\u51b3\u516b\u6570\u7801\u95ee\u9898\uff083*3 \u7684\u68cb\u76d8\uff0c\u6709 8 \u4e2a\u6807\u53f7\u662f 1-8 \u7684\u68cb\u5b50\uff0c\u4e00\u4e2a\u7a7a\u683c\u3002\u6bcf 7 \u6b21\u53ef\u4ee5\u628a\u4e00\u4e2a\u4e0e\u7a7a\u683c\u76f8\u90bb\u7684\u68cb\u5b50\u79fb\u52a8\u5230\u7a7a\u683c\u4e0a\uff0c\u7ed9\u51fa\u4e00\u4e2a\u76ee\u6807\u68cb\u76d8\uff0c\u95ee\u6700\u5c11\u79fb\u52a8\u6b21\u6570\uff09 #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <iostream> #include <string> #include <queue> using namespace std ; const int maxn = 15 , maxs = 362885 ; class AStar { public : const int nxt [ 4 ][ 2 ] = {{ - 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 }}; const char dir [ 4 ] = { 'u' , 'd' , 'l' , 'r' }; int bit [ maxn ], fact [ maxn ]; AStar () { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 9 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; } inline int ask ( int x ) { int ret = 0 ; while ( x ) ret += bit [ x ], x -= x & - x ; return ret ; } inline void add ( int x , int d ) { while ( x <= 9 ) bit [ x ] += d , x += x & - x ; } struct Node { int i , x , y ; string s , ans ; bool operator < ( const Node & rhs ) const { return x + y > rhs . x + rhs . y ; 8 } } st ; int vis [ maxs ]; priority_queue < Node > q ; inline int cantor ( string s ) { memset ( bit , 0 , sizeof ( bit )); for ( int i = 0 ; i < 9 ; ++ i ) if ( s [ i ] == 'x' ) s [ i ] = '0' ; int ans = 1 ; for ( int i = 8 ; i >= 0 ; -- i ) { ans += ask ( s [ i ] - '0' ) * fact [ 8 - i ]; add ( s [ i ] - '0' + 1 , 1 ); } return ans ; } inline int diff ( string s ) { int ans = 0 ; for ( int i = 0 ; i < 9 ; ++ i ) { int x = i / 3 , y = i % 3 ; if ( s [ i ] == 'x' ) ans += abs ( x - 2 ) + abs ( y - 2 ); else { int j = s [ i ] - '1' ; ans += abs ( x - j / 3 ) + abs ( y - j % 3 ); } } return ans ; } inline string bfs ( string s ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( s [ i ] == 'x' ) st . i = i ; st . x = 0 , st . y = diff ( s ); st . s = s , st . ans = \"\" ; vis [ cantor ( st . s )] = 1 ; 9 q . push ( st ); while ( ! q . empty ()) { Node u = q . top (), v ; q . pop (); if ( u . s == \"12345678x\" ) return u . ans ; int x = u . i / 3 , y = u . i % 3 ; for ( int i = 0 ; i < 4 ; ++ i ) { int nx = x + nxt [ i ][ 0 ], ny = y + nxt [ i ][ 1 ]; if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue ; v . i = 3 * nx + ny ; v . s = u . s ; swap ( v . s [ u . i ], v . s [ v . i ]); if ( vis [ cantor ( v . s )]) continue ; vis [ cantor ( v . s )] = 1 ; v . x = u . x + 1 , v . y = diff ( v . s ); v . ans = u . ans + dir [ i ]; q . push ( v ); } } return \"unsolvable\" ; } } a_star ; int main () { char in [ 2 ]; string s = \"\" ; for ( int i = 1 ; i <= 9 ; ++ i ) { scanf ( \"%s\" , in ); s += in [ 0 ]; } int cnt = 0 ; for ( int i = 8 ; i >= 0 ; -- i ) if ( s [ i ] != 'x' ) cnt += a_star . ask ( s [ i ] - '0' ), a_star . add ( s [ i ] - '0' , 1 ); if ( cnt & 1 ) printf ( \"unsolvable\" ); else cout << a_star . bfs ( s ); return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // IDA* \u89e3\u51b3\u516b\u6570\u7801\u95ee\u9898 #include <stdio.h> #include <math.h> #include <string.h> #include <algorithm> #define INF 40000 using namespace std ; int f [ 10 ]; class IDAStar { public : int dx [ 10 ] = { 0 , 0 , 1 , - 1 }; int dy [ 10 ] = { 1 , - 1 , 0 , 0 }; char dxy [ 10 ] = \"rldu\" ; char ans [ 1005 ]; int hh () //\u4f30\u503c\u51fd\u6570=\u6bcf\u4e00\u4e2a\u90fd\u76f4\u63a5\u8d70\u5230\u81ea\u5df1\u4f4d\u7f6e\u7684\u6b65\u6570 { int i , j , sum = 0 ; for ( i = 0 ; i < 9 ; i ++ ) { if ( f [ i ]) sum += abs ( i / 3 - ( f [ i ] - 1 ) / 3 ) + abs ( i % 3 - ( f [ i ] - 1 ) % 3 ); } return sum ; } int minn ; bool dfs ( int x , int g , int depth ) //x \u4ee3\u8868'x'\u7684\u4f4d\u7f6e g \u4ee3\u8868\u73b0\u5728\u8d70\u4e86\u591a\u5c11 depth \u4ee3\u8868\u672c\u6b21\u6700 \u591a\u8d70\u591a\u5c11 { int h = hh (); minn = min ( minn , h ); //\u627e\u5230\u8fd9\u6b21\u79bb\u7ec8\u70b9\u6700\u8fd1\u7684\u8ddd\u79bb\u662f\u591a\u5c11\uff0c\u4f46\u5b9e\u9645\u8ddd\u79bb\u4e00\u5b9a\u662f>=\u4f30\u8ba1 \u8ddd\u79bb if ( h == 0 ) { ans [ g ] = '\\0' ; printf ( \"%s \\n \" , ans ); return true ; } if ( g + h > depth ) return false ; int xx , yy ; int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { xx = x / 3 + dx [ i ]; 11 yy = x % 3 + dy [ i ]; if ( xx >= 0 && yy >= 0 && xx < 3 && yy < 3 ) { if ( g ) { if ( i == 0 && ans [ g - 1 ] == 'l' ) continue ; //\u8fd9\u6b21\u5f80\u4e0a\uff0c\u4e0a\u6b21\u5f80\u4e0b\u80af\u5b9a\u662f\u4e0d\u53ef\u4ee5\u7684 if ( i == 1 && ans [ g - 1 ] == 'r' ) continue ; if ( i == 2 && ans [ g - 1 ] == 'u' ) continue ; if ( i == 3 && ans [ g - 1 ] == 'd' ) continue ; } ans [ g ] = dxy [ i ]; f [ x ] = f [ xx * 3 + yy ]; f [ xx * 3 + yy ] = 0 ; if ( dfs ( xx * 3 + yy , g + 1 , depth )) return true ; f [ xx * 3 + yy ] = f [ x ]; f [ x ] = 0 ; } } return false ; } void IDA_star ( int x ) { int depth = hh (); while ( 1 ) { minn = INF ; if ( dfs ( x , 0 , depth )) { break ; } depth += minn ; } } bool pan () { int i , j , k = 0 ; for ( i = 0 ; i < 9 ; i ++ ) { if ( f [ i ] == 0 ) continue ; for ( j = 0 ; j < i ; j ++ ) 12 { if ( f [ j ] > f [ i ]) k ++ ; } } if ( k % 2 ) return true ; return false ; } } ida_star ; char a [ 105 ]; int main () { while ( gets ( a )) { int i , j , a1 = strlen ( a ), k = 0 , x , y ; for ( i = 0 ; i < a1 ; i ++ ) { if ( a [ i ] != ' ' ) { if ( a [ i ] == 'x' ) { x = k / 3 ; y = k % 3 ; f [ k ] = 0 ; k ++ ; } else f [ k ++ ] = a [ i ] - '0' ; } } if ( ida_star . pan ()) printf ( \"unsolvable \\n \" ); else ida_star . IDA_star ( x * 3 + y ); } } // 1 2 3 4 5 6 7 8 x \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u542f\u53d1\u5f0f\u641c\u7d22"},{"location":"Search/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E6%90%9C%E7%B4%A2-alpha-beta%E5%89%AA%E6%9E%9D/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 // \u66b4\u529b\u641c\u7d22\uff0c\u4f46\u5bf9\u4e8e\u67d0\u4e9b\u7279\u5b9a\u60c5\u51b5\u53ef\u4ee5\u901a\u8fc7 alphat-beta \u503c\u76f4\u63a5\u4f18\u5316\u6389 #include <stdio.h> #include <math.h> #include <algorithm> using namespace std ; char a [ 10 ][ 10 ]; 4 class MinimaxSearch { public : int xx , yy ; int Evaluate () //\u5224\u65ad 1 \u662f x \u80dc\u5229 -1 \u662f o \u80dc\u5229 0 \u662f\u6ca1\u6709\u80dc\u5229 { int i , j , z , zz , zt , zzt ; for ( i = 0 ; i < 4 ; i ++ ) { z = 0 , zz = 0 , zt = 0 , zzt = 0 ; for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == 'x' ) z ++ ; else if ( a [ i ][ j ] == 'o' ) zz ++ ; if ( a [ j ][ i ] == 'x' ) zt ++ ; else if ( a [ j ][ i ] == 'o' ) zzt ++ ; } if ( z == 4 || zt == 4 ) return 1 ; if ( zz == 4 || zzt == 4 ) return - 1 ; } zt = 0 , zzt = 0 , z = 0 , zz = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { if ( a [ i ][ i ] == 'x' ) z ++ ; if ( a [ i ][ i ] == 'o' ) zz ++ ; if ( a [ i ][ 3 - i ] == 'x' ) zt ++ ; if ( a [ i ][ 3 - i ] == 'o' ) zzt ++ ; } if ( z == 4 || zt == 4 ) return 1 ; if ( zz == 4 || zzt == 4 ) return - 1 ; return 0 ; } int Max ( int depth , int upalpha , int upbeta ) { 5 int alpha = upalpha , beta = upbeta ; int val ; int flag = Evaluate (); if ( flag || depth == 0 ) //\u5df2\u7ecf\u6709\u4e00\u65b9\u80dc\u5229\uff0c\u6216\u8005\u5168\u4e0b\u5b8c return flag ; int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == '.' ) { a [ i ][ j ] = 'x' ; val = Min ( depth - 1 , alpha , beta ); a [ i ][ j ] = '.' ; alpha = max ( alpha , val ); if ( alpha >= beta ) { xx = i , yy = j ; return alpha ; } } } } return alpha ; } int Min ( int depth , int upalpha , int upbeta ) { int alpha = upalpha , beta = upbeta ; int val ; int flag = Evaluate (); if ( flag || depth == 0 ) //\u5df2\u7ecf\u6709\u4e00\u65b9\u80dc\u5229\uff0c\u6216\u8005\u5168\u4e0b\u5b8c return flag ; int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == '.' ) { a [ i ][ j ] = 'o' ; val = Max ( depth - 1 , alpha , beta ); a [ i ][ j ] = '.' ; beta = min ( beta , val ); if ( beta <= alpha ) return beta ; 6 } } } return beta ; } } miniMax ; int main () { char c ; while ( scanf ( \"%c\" , & c ) != EOF ) { if ( c == '$' ) break ; int i , j ; int sum = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { scanf ( \"%s\" , a [ i ]); for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == '.' ) sum ++ ; } } if ( sum > 11 ) //\u521a\u4e0b\u56db\u4e2a\u5b50\u65f6\u4e0d\u53ef\u80fd\u6709\u51b3\u80dc\u70b9\uff0c\u6ca1\u6709\u8fd9\u4e2a\u4e00\u76f4 TLE { printf ( \"##### \\n \" ); getchar (); continue ; } int z = miniMax . Max ( sum , - 1 , 1 ); if ( z == 1 ) printf ( \"(%d,%d) \\n \" , miniMax . xx , miniMax . yy ); else printf ( \"##### \\n \" ); getchar (); } } \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u6781\u5927\u6781\u5c0f\u5316\u641c\u7d22"},{"location":"String/","text":"","title":"Index"},{"location":"String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 /* hdu2222 \u9898\u610f\uff1a\u6bcf\u7ec4\u6570\u636e\u6709 n \u4e2a\u6a21\u5f0f\u4e32\uff0c\u8be2\u95ee\u5728\u6587\u672c\u4e32\u4e2d\u51fa\u73b0\u4e86\u591a\u5c11\u6a21\u5f0f\u4e32 */ #include <bits/stdc++.h> using namespace std ; const int maxn = 1e6 ; // \u8bf7\u5f00\u6210 \u6a21\u5f0f\u4e32\u957f\u5ea6*\u6a21\u5f0f\u4e32\u6570\u91cf const int ch_size = 26 ; // \u8bf7\u5f00\u6210\u5b57\u7b26\u96c6\u5927\u5c0f class Ac_automaton { public : int trie [ maxn ][ ch_size ]; int vis [ maxn ], fail [ maxn ]; int tot ; void init () { memset ( vis , 0 , sizeof vis ); memset ( trie , 0 , sizeof trie ); tot = 0 ; } void insert ( char * str ) { int len = strlen ( str ); int pos = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; if ( ! trie [ pos ][ c ]) trie [ pos ][ c ] = ++ tot ; pos = trie [ pos ][ c ]; } vis [ pos ] ++ ; } void build () { queue < int > q ; for ( int i = 0 ; i < ch_size ; i ++ ) { 78 if ( trie [ 0 ][ i ]) { fail [ trie [ 0 ][ i ]] = 0 ; q . push ( trie [ 0 ][ i ]); } } while ( ! q . empty ()) { int pos = q . front (); q . pop (); for ( int i = 0 ; i < ch_size ; i ++ ) { if ( trie [ pos ][ i ]) { fail [ trie [ pos ][ i ]] = trie [ fail [ pos ]][ i ]; q . push ( trie [ pos ][ i ]); } else { trie [ pos ][ i ] = trie [ fail [ pos ]][ i ]; } } } } int query ( char * str ) { int len = strlen ( str ); int pos = 0 , ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; pos = trie [ pos ][ c ]; for ( int j = pos ; j && vis [ j ] != - 1 ; j = fail [ j ]) { ans += vis [ j ]; vis [ j ] = - 1 ; } } return ans ; } }; Ac_automaton ac ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ac . init (); char str [ maxn ]; int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%s\" , str ); 79 ac . insert ( str ); } ac . build (); scanf ( \"%s\" , str ); printf ( \"%d \\n \" , ac . query ( str )); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4e1c\u741b","title":"AC\u81ea\u52a8\u673a"},{"location":"String/%E5%AD%97%E5%85%B8%E6%A0%91/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* hdu1251 \u9898\u610f\uff1a\u7ed9\u51fa\u4e00\u4e9b\u6a21\u5f0f\u4e32\uff0c\u7136\u540e\u6709\u4e00\u4e9b\u63d0\u95ee\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u63d0\u95ee\uff0c\u7ed9\u51fa\u4ee5\u8be5\u5b57\u7b26\u4e32\u4e3a\u524d\u7f00\u7684\u6a21\u5f0f\u4e32 \u7684\u6570\u91cf. */ #include <bits/stdc++.h> using namespace std ; const int maxn = 1e6 + 7 ; //\u8bf7\u5f00\u5230\u6a21\u5f0f\u4e32\u957f\u5ea6*\u6a21\u5f0f\u4e32\u6570\u91cf const int ch_size = 26 ; //\u8bf7\u5f00\u6210\u5b57\u7b26\u96c6\u5927\u5c0f class Trie { public : int trie [ maxn ][ ch_size ]; int vis [ maxn ], tot ; void init () { memset ( trie , 0 , sizeof trie ); memset ( vis , 0 , sizeof vis ); tot = 0 ; } void insert ( char * str ) { int len = strlen ( str ); int pos = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; if ( ! trie [ pos ][ c ]) trie [ pos ][ c ] = ++ tot ; pos = trie [ pos ][ c ]; vis [ pos ] ++ ; } //vis[pos]++; } int query ( char * str ) { int len = strlen ( str ); int pos = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; if ( ! trie [ pos ][ c ]) return 0 ; pos = trie [ pos ][ c ]; } return vis [ pos ]; } }; 77 Trie tr ; int main () { char str [ maxn ]; while ( cin . getline ( str , maxn ) && strlen ( str )) { tr . insert ( str ); } while ( ~ scanf ( \"%s\" , str )) { cout << tr . query ( str ) << endl ; } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4e1c\u741b","title":"\u5b57\u5178\u6811"}]}