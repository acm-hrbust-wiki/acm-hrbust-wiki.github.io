{"config":{"lang":["jp"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230 Hrbust_ACM\u2018s Wiki\uff01 \u00b6 Let\u2019s Go !!! \u00b6 \u7f16\u5199\u4eba\u5458 \u00b6 \u7ec4\u7ec7\u7f16\u5199\uff1a \u5510\u8fdc\u65b0 \u5185\u5bb9\u5ba1\u6838\uff1a \u5218\u660e\u8f89 \u5185\u5bb9\u7f16\u64b0\uff1a \u8ba1 16-1 \u5218\u660e\u8f89\uff0c\u8ba1 18-9 \u80e1\u5c0f\u6587\uff0c\u8ba1 18-8 \u97a0\u6c38\u5168 \uff0c\u8ba1 18-5 \u738b\u4e1c\u741b \u8ba1 18-8 \u6768\u777f\uff0c\u8ba1 18-7 \u725b\u4ed4\u8d85 \uff0c\u7f51\u7edc 18-2 \u5434\u56fd\u5e86\uff0c\u7f51\u7edc 18-3 \u8463\u6587\u777f \u8ba1 18-5 \u738b\u4f73\u59ae\uff0c \u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd\uff0c\u7f51\u7edc 18-3 \u51af\u7d2b\u541b\uff0c\u8ba1 18-8 \u8499\u665f\u7ef4 Wiki\u7ef4\u62a4\uff1a \u9c81\u660e\u7ff0 \u66f4\u65b0\u65e5\u5fd7 \u00b6 \u5f53\u524d\u7248\u672c\u7f16\u53f7 - 20200515 20200515\u66f4\u65b0 \u589e\u52a0\u4e86\u57fa\u7840\u7b97\u6cd5\u90e8\u5206\u5185\u5bb9\u3001\u52a0\u8f7d\u4e86\u641c\u7d22\u63d2\u4ef6\u3001\u6700\u540e\u66f4\u65b0\u65f6\u95f4\u63d2\u4ef6 20200501\u66f4\u65b0 \u66f4\u65b0\u4e86\u7f51\u7ad9\u4e3b\u9898\uff0c\u5b8c\u6210\u641c\u7d22\u3001DP\u3001\u6570\u636e\u7ed3\u6784\u3001\u56fe\u8bba\u3001\u5b57\u7b26\u4e32\u3001\u9644\u5f55\u7684\u90e8\u5206\u5185\u5bb9\u3002","title":"Getting Started"},{"location":"#hrbust_acms-wiki","text":"","title":"\u6b22\u8fce\u6765\u5230 Hrbust_ACM\u2018s Wiki\uff01"},{"location":"#lets-go","text":"","title":"Let\u2019s Go !!!"},{"location":"#_1","text":"\u7ec4\u7ec7\u7f16\u5199\uff1a \u5510\u8fdc\u65b0 \u5185\u5bb9\u5ba1\u6838\uff1a \u5218\u660e\u8f89 \u5185\u5bb9\u7f16\u64b0\uff1a \u8ba1 16-1 \u5218\u660e\u8f89\uff0c\u8ba1 18-9 \u80e1\u5c0f\u6587\uff0c\u8ba1 18-8 \u97a0\u6c38\u5168 \uff0c\u8ba1 18-5 \u738b\u4e1c\u741b \u8ba1 18-8 \u6768\u777f\uff0c\u8ba1 18-7 \u725b\u4ed4\u8d85 \uff0c\u7f51\u7edc 18-2 \u5434\u56fd\u5e86\uff0c\u7f51\u7edc 18-3 \u8463\u6587\u777f \u8ba1 18-5 \u738b\u4f73\u59ae\uff0c \u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd\uff0c\u7f51\u7edc 18-3 \u51af\u7d2b\u541b\uff0c\u8ba1 18-8 \u8499\u665f\u7ef4 Wiki\u7ef4\u62a4\uff1a \u9c81\u660e\u7ff0","title":"\u7f16\u5199\u4eba\u5458"},{"location":"#_2","text":"\u5f53\u524d\u7248\u672c\u7f16\u53f7 - 20200515 20200515\u66f4\u65b0 \u589e\u52a0\u4e86\u57fa\u7840\u7b97\u6cd5\u90e8\u5206\u5185\u5bb9\u3001\u52a0\u8f7d\u4e86\u641c\u7d22\u63d2\u4ef6\u3001\u6700\u540e\u66f4\u65b0\u65f6\u95f4\u63d2\u4ef6 20200501\u66f4\u65b0 \u66f4\u65b0\u4e86\u7f51\u7ad9\u4e3b\u9898\uff0c\u5b8c\u6210\u641c\u7d22\u3001DP\u3001\u6570\u636e\u7ed3\u6784\u3001\u56fe\u8bba\u3001\u5b57\u7b26\u4e32\u3001\u9644\u5f55\u7684\u90e8\u5206\u5185\u5bb9\u3002","title":"\u66f4\u65b0\u65e5\u5fd7"},{"location":"faq/","text":"\u4f9d\u8d56\u73af\u5883 \u00b6 \u535a\u5ba2\u6846\u67b6\u57fa\u4e8epython\uff0c \u4f7f\u7528pip\u5b89\u88c5\u76f8\u5173\u5b89\u88c5\u5305 1 2 3 4 Python 3.0 - 3.7 . x # mkdocs\u8fd8\u672a\u652f\u6301Python 3.8.0 mkdocs >= 1 # \u535a\u5ba2\u6846\u67b6 mkdocs - material # mkdocs\u4e3b\u9898 pymdown - extensions # markdown\u6269\u5c55 \u535a\u5ba2\u7ed3\u6784 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 -.git : - # git\u914d\u7f6e\u6587\u4ef6\u5939\uff0c\u52ff\u52a8 -docs : - _static - Base - Data_Structure - ... # docs\u6587\u4ef6\u5939\u5b58\u653emarkdown\u6587\u4ef6\uff0c\u65e2\u535a\u5ba2\u5185\u5bb9 -site : - xxxx.html - ... # - mkdocs build\u547d\u4ee4\u540e\u751f\u6210\u7684\u9759\u6001\u6587\u4ef6\uff0c\u7531html\u7ec4\u6210\u3002 - CNAME # DNS\u57df\u540d\u914d\u7f6e\u6587\u4ef6\uff0c\u82e5\u4e22\u5931\u4f1a\u9020\u6210\u57df\u540d\u65e0\u6cd5\u89e3\u6790 - mkdocs.yml # mkdocs\u914d\u7f6e\u6587\u4ef6\uff0c\u6587\u7ae0\u76ee\u5f55 - README.md # GitHub\u4ed3\u5e93\u4ecb\u7ecd\u6587\u4ef6 Git\u547d\u4ee4\u7b80\u4ecb \u00b6 \u9700\u8981\u5b89\u88c5git\u73af\u5883\uff0c \u4e0b\u8f7dGit \u6709\u547d\u4ee4\u884c\u548cGUI\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff0c\u63a8\u8350\u4e24\u79cd\u7ed3\u5408\u4f7f\u7528 \u4e0b\u8f7dGitHub Desktop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 start a working area ( see also: git help tutorial ) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change ( see also: git help everyday ) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state ( see also: git help revisions ) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate ( see also: git help workflows ) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects \u5e38\u7528\u7684\u547d\u4ee4\u53ea\u6709\u51e0\u6761\u719f\u6089\u5373\u53ef\uff0c\u6211\u4eec\u4e00\u822c\u5728GUI\u4e2d\u64cd\u4f5c git clone url git add -A git commit -m \u201c\u672c\u6b21\u63d0\u4ea4\u7684\u8bf4\u660e\u201d git push MkDocs\u547d\u4ee4 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 MkDocs - Project documentation with Markdown . Options : -V , - -version Show the version and exit . -q , - -quiet Silence warnings -v , - -verbose Enable verbose output -h , - -help Show this message and exit . Commands : build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development server \u5e38\u7528\u64cd\u4f5c\u6d41\u7a0b\uff0c\u5728\u4efb\u4e00\u7ec8\u7aef\u4e0b \u8fdb\u5165wiki\u7684\u6839\u76ee\u5f55\u4f7f\u7528mkdocs serve \u542f\u52a8\u672c\u5730\u670d\u52a1\uff0c\u6b64\u65f6\u53ef\u4ee5\u5728 127.0.0.1:8000 \u4f7f\u7528\u6d4f\u89c8\u5668\u8bbf\u95ee \u672c\u5730\u6587\u4ef6\u4fee\u6539\u540e\uff0c\u65e0\u9700\u91cd\u542f\u670d\u52a1\uff0c\u4fdd\u5b58\u540e\u6d4f\u89c8\u5668\u81ea\u52a8\u5237\u65b0 \u4fee\u6539\u5b8c\u6210\u540e\u4f7f\u7528 mkdocs build \u751f\u6210\u9759\u6001\u6587\u4ef6 /site \u6587\u4ef6\u5939 \u65e0\u9700\u4f7f\u7528gh-deploy\u548cnew\u547d\u4ee4 \u53c2\u4e0e\u7f16\u5199 \u00b6 > \u6211\u662f\u840c\u65b0 \u00b6 \u53c2\u4e0eWiki\u7684\u7f16\u5199 \u9700\u8981 \u4e00\u4e2a GitHub \u8d26\u53f7\uff0c \u4e0d\u9700\u8981 \u9ad8\u8d85\u7684 GitHub \u6280\u5de7\u3002 \u7ef4\u4fee\u4e2d\u3002\u3002\u3002 > \u6211\u662f\u5927\u4f6c \u00b6 \u88ab\u8feb\u6210\u4e3a\u5927\u4f6c\uff0c\u63d0\u4ea4\u4f60\u5b9d\u8d35\u7684\u7b2c\u4e00\u6b21 PR\uff08Pull Requests\uff09 \u5427 PR\u4e94\u6b65\u8d70\u6d41\u7a0b fork\u672c\u9879\u76ee\u5230\u81ea\u5df1\u7684\u4ed3\u5e93 \u6210\u529f\u540e\uff1a\uff08\u6ce8\u610f\u8fd9\u91cc\u5df2\u7ecf\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\u4e86\uff0c\u7528\u6237\u540drelifes\uff0c\u5e76\u4e14\u56fe\u6807\u53d8\u6210\u4e86\u53c9\u5b50\uff09 clone\u5230\u672c\u5730\u8fdb\u884c\u4fee\u6539\uff0c\u7531\u4e8e\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\uff0c\u6240\u4ee5\u60f3\u600e\u4e48\u6539\u90fd\u884c \u8fd9\u91cc\u67094\u79cd\u65b9\u5f0f\u514b\u9686\u4e0b\u6765 git clone https://github.com/username/wiki.git git clone git@github.com:username/wiki.git \u4f7f\u7528Destop\u5ba2\u6237\u7aef\u514b\u9686 \u76f4\u63a5\u4e0b\u8f7d\u9879\u76ee\u7684\u6e90\u7801\u538b\u7f29\u5305","title":"\u5982\u4f55\u4f7f\u7528"},{"location":"faq/#_1","text":"\u535a\u5ba2\u6846\u67b6\u57fa\u4e8epython\uff0c \u4f7f\u7528pip\u5b89\u88c5\u76f8\u5173\u5b89\u88c5\u5305 1 2 3 4 Python 3.0 - 3.7 . x # mkdocs\u8fd8\u672a\u652f\u6301Python 3.8.0 mkdocs >= 1 # \u535a\u5ba2\u6846\u67b6 mkdocs - material # mkdocs\u4e3b\u9898 pymdown - extensions # markdown\u6269\u5c55","title":"\u4f9d\u8d56\u73af\u5883"},{"location":"faq/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 -.git : - # git\u914d\u7f6e\u6587\u4ef6\u5939\uff0c\u52ff\u52a8 -docs : - _static - Base - Data_Structure - ... # docs\u6587\u4ef6\u5939\u5b58\u653emarkdown\u6587\u4ef6\uff0c\u65e2\u535a\u5ba2\u5185\u5bb9 -site : - xxxx.html - ... # - mkdocs build\u547d\u4ee4\u540e\u751f\u6210\u7684\u9759\u6001\u6587\u4ef6\uff0c\u7531html\u7ec4\u6210\u3002 - CNAME # DNS\u57df\u540d\u914d\u7f6e\u6587\u4ef6\uff0c\u82e5\u4e22\u5931\u4f1a\u9020\u6210\u57df\u540d\u65e0\u6cd5\u89e3\u6790 - mkdocs.yml # mkdocs\u914d\u7f6e\u6587\u4ef6\uff0c\u6587\u7ae0\u76ee\u5f55 - README.md # GitHub\u4ed3\u5e93\u4ecb\u7ecd\u6587\u4ef6","title":"\u535a\u5ba2\u7ed3\u6784"},{"location":"faq/#git","text":"\u9700\u8981\u5b89\u88c5git\u73af\u5883\uff0c \u4e0b\u8f7dGit \u6709\u547d\u4ee4\u884c\u548cGUI\u4e24\u79cd\u64cd\u4f5c\u65b9\u5f0f\uff0c\u63a8\u8350\u4e24\u79cd\u7ed3\u5408\u4f7f\u7528 \u4e0b\u8f7dGitHub Desktop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 start a working area ( see also: git help tutorial ) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change ( see also: git help everyday ) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index examine the history and state ( see also: git help revisions ) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPG collaborate ( see also: git help workflows ) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects \u5e38\u7528\u7684\u547d\u4ee4\u53ea\u6709\u51e0\u6761\u719f\u6089\u5373\u53ef\uff0c\u6211\u4eec\u4e00\u822c\u5728GUI\u4e2d\u64cd\u4f5c git clone url git add -A git commit -m \u201c\u672c\u6b21\u63d0\u4ea4\u7684\u8bf4\u660e\u201d git push","title":"Git\u547d\u4ee4\u7b80\u4ecb"},{"location":"faq/#mkdocs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 MkDocs - Project documentation with Markdown . Options : -V , - -version Show the version and exit . -q , - -quiet Silence warnings -v , - -verbose Enable verbose output -h , - -help Show this message and exit . Commands : build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development server \u5e38\u7528\u64cd\u4f5c\u6d41\u7a0b\uff0c\u5728\u4efb\u4e00\u7ec8\u7aef\u4e0b \u8fdb\u5165wiki\u7684\u6839\u76ee\u5f55\u4f7f\u7528mkdocs serve \u542f\u52a8\u672c\u5730\u670d\u52a1\uff0c\u6b64\u65f6\u53ef\u4ee5\u5728 127.0.0.1:8000 \u4f7f\u7528\u6d4f\u89c8\u5668\u8bbf\u95ee \u672c\u5730\u6587\u4ef6\u4fee\u6539\u540e\uff0c\u65e0\u9700\u91cd\u542f\u670d\u52a1\uff0c\u4fdd\u5b58\u540e\u6d4f\u89c8\u5668\u81ea\u52a8\u5237\u65b0 \u4fee\u6539\u5b8c\u6210\u540e\u4f7f\u7528 mkdocs build \u751f\u6210\u9759\u6001\u6587\u4ef6 /site \u6587\u4ef6\u5939 \u65e0\u9700\u4f7f\u7528gh-deploy\u548cnew\u547d\u4ee4","title":"MkDocs\u547d\u4ee4"},{"location":"faq/#_3","text":"","title":"\u53c2\u4e0e\u7f16\u5199"},{"location":"faq/#_4","text":"\u53c2\u4e0eWiki\u7684\u7f16\u5199 \u9700\u8981 \u4e00\u4e2a GitHub \u8d26\u53f7\uff0c \u4e0d\u9700\u8981 \u9ad8\u8d85\u7684 GitHub \u6280\u5de7\u3002 \u7ef4\u4fee\u4e2d\u3002\u3002\u3002","title":"&gt; \u6211\u662f\u840c\u65b0"},{"location":"faq/#_5","text":"\u88ab\u8feb\u6210\u4e3a\u5927\u4f6c\uff0c\u63d0\u4ea4\u4f60\u5b9d\u8d35\u7684\u7b2c\u4e00\u6b21 PR\uff08Pull Requests\uff09 \u5427 PR\u4e94\u6b65\u8d70\u6d41\u7a0b fork\u672c\u9879\u76ee\u5230\u81ea\u5df1\u7684\u4ed3\u5e93 \u6210\u529f\u540e\uff1a\uff08\u6ce8\u610f\u8fd9\u91cc\u5df2\u7ecf\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\u4e86\uff0c\u7528\u6237\u540drelifes\uff0c\u5e76\u4e14\u56fe\u6807\u53d8\u6210\u4e86\u53c9\u5b50\uff09 clone\u5230\u672c\u5730\u8fdb\u884c\u4fee\u6539\uff0c\u7531\u4e8e\u662f\u81ea\u5df1\u7684\u4ed3\u5e93\uff0c\u6240\u4ee5\u60f3\u600e\u4e48\u6539\u90fd\u884c \u8fd9\u91cc\u67094\u79cd\u65b9\u5f0f\u514b\u9686\u4e0b\u6765 git clone https://github.com/username/wiki.git git clone git@github.com:username/wiki.git \u4f7f\u7528Destop\u5ba2\u6237\u7aef\u514b\u9686 \u76f4\u63a5\u4e0b\u8f7d\u9879\u76ee\u7684\u6e90\u7801\u538b\u7f29\u5305","title":"&gt; \u6211\u662f\u5927\u4f6c"},{"location":"home/","text":"\u4e00\uff1a\u5173\u4e8e\u672c\u7ad9 \u00b6 Info \u535a\u5ba2\u6846\u67b6 : MkDocs \u4e3b\u9898 : Material for MkDocs \u7f16\u5199\u6587\u672c \uff1amarkdown \u4e8c\uff1a\u7f16\u5199\u8bf4\u660e \u00b6 \u63a8\u8350\u4f7f\u7528 Typora \u6765\u7f16\u5199markdown\u6587\u4ef6 \u535a\u5ba2\u67b6\u6784\u652f\u6301 LaTeX \u6570\u5b66\u516c\u5f0f\u548cmarkdown\u6269\u5c55 \u4f8b\u5982\u4f60\u6240\u89c1\u5230\u7684 f_{i,j,k} f_{i,j,k} , f(i,j,k) f(i,j,k) \u652f\u6301\u4ee3\u7801\u9ad8\u4eae\u4e0e\u590d\u5236 C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <bits/stdc++.h> using namespace std ; int main () { vector < int > v ; for ( int i = 1 ; i <= 10 ; i ++ ) v . push_back ( i ); for ( auto x : v ) cout << x << \" \" ; printf ( \"Hello World \\n \" ); return 0 ; } python 1 2 3 4 5 6 def blogs_with_type ( request , blog_type_pk ): context = {} blog_type = get_object_or_404 ( BlogType , pk = blog_type_pk ) context [ 'blogs' ] = Blog . objects . filter ( blog_type = blog_type ) context [ 'blog_type' ] = blog_type return render ( request , 'blogs_with_type.html' , context ) \u4e09\uff1a\u7f16\u8f91\u4fee\u6539 \u00b6 \u719f\u6089GitHub\u7684\u540c\u5b66\u53ef\u4ee5\u76f4\u63a5\u63d0\u4ea4PR \u4e0d\u719f\u6089\u7684\u5c06\u5199\u597d\u7684\u6587\u6863\u53d1\u5230 QQ: 1486176948\uff0c \u63a8\u8350\u63d0\u4ea4markdown\u6587\u6863\u3002","title":"Wiki\u4ecb\u7ecd"},{"location":"home/#_1","text":"Info \u535a\u5ba2\u6846\u67b6 : MkDocs \u4e3b\u9898 : Material for MkDocs \u7f16\u5199\u6587\u672c \uff1amarkdown","title":"\u4e00\uff1a\u5173\u4e8e\u672c\u7ad9"},{"location":"home/#_2","text":"\u63a8\u8350\u4f7f\u7528 Typora \u6765\u7f16\u5199markdown\u6587\u4ef6 \u535a\u5ba2\u67b6\u6784\u652f\u6301 LaTeX \u6570\u5b66\u516c\u5f0f\u548cmarkdown\u6269\u5c55 \u4f8b\u5982\u4f60\u6240\u89c1\u5230\u7684 f_{i,j,k} f_{i,j,k} , f(i,j,k) f(i,j,k) \u652f\u6301\u4ee3\u7801\u9ad8\u4eae\u4e0e\u590d\u5236 C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <bits/stdc++.h> using namespace std ; int main () { vector < int > v ; for ( int i = 1 ; i <= 10 ; i ++ ) v . push_back ( i ); for ( auto x : v ) cout << x << \" \" ; printf ( \"Hello World \\n \" ); return 0 ; } python 1 2 3 4 5 6 def blogs_with_type ( request , blog_type_pk ): context = {} blog_type = get_object_or_404 ( BlogType , pk = blog_type_pk ) context [ 'blogs' ] = Blog . objects . filter ( blog_type = blog_type ) context [ 'blog_type' ] = blog_type return render ( request , 'blogs_with_type.html' , context )","title":"\u4e8c\uff1a\u7f16\u5199\u8bf4\u660e"},{"location":"home/#_3","text":"\u719f\u6089GitHub\u7684\u540c\u5b66\u53ef\u4ee5\u76f4\u63a5\u63d0\u4ea4PR \u4e0d\u719f\u6089\u7684\u5c06\u5199\u597d\u7684\u6587\u6863\u53d1\u5230 QQ: 1486176948\uff0c \u63a8\u8350\u63d0\u4ea4markdown\u6587\u6863\u3002","title":"\u4e09\uff1a\u7f16\u8f91\u4fee\u6539"},{"location":"DP/%E5%8C%BA%E9%97%B4DP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //n \u5806\u77f3\u5b50\u6392\u6210\u2f00\u5217\uff0c\u6bcf\u5806\u77f3\u5b50\u6709\u4e00\u4e2a\u91cd\u91cf w[i] //\u6bcf\u6b21\u5408\u5e76\u53ef\u4ee5\u5408\u5e76\u76f8\u90bb\u7684\u4e24\u5806\u77f3\u5b50\uff0c\u2f00\u6b21\u5408\u5e76\u7684\u4ee3\u4ef7\u4e3a\u4e24\u5806\u2f6f\u2f26\u7684\u91cd\u91cf\u548c w[i]+w[i+1]\u3002 //\u95ee\u5b89\u6392\u600e\u6837\u7684\u5408\u5e76\u987a\u5e8f\uff0c\u80fd\u591f\u4f7f\u5f97\u603b\u5408\u5e76\u4ee3\u4ef7\u8fbe\u5230\u6700\u5927 long long w [ maxn ], n ; class IntervalDp { public : long long dp [ maxn ][ maxn ], sum [ maxn ]; //dp[i][j]\u8868\u793a\u628a\u7b2c i \u5806\u5230\u7b2c j \u5806\u7684\u77f3\u5b50\u5408\u5e76\u5728\u2f00\u8d77\u7684\u6700\u4f18\u503c //sum[i]\u4e3a\u524d i \u5806\u77f3\u5b50\u7684\u548c long long solve ( LL * w , LL n ) { //\u63a5\u53e3 for ( int i = 1 ; i <= n ; i ++ ){ sum [ i ] = sum [ i - 1 ] + w [ i ]; } for ( int len = 2 ; len <= n ; len ++ ){ for ( int i = 1 ; i <= n - len + 1 ; i ++ ){ int j = i + len - 1 ; for ( int k = i ; k <= j - 1 ; k ++ ){ dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k ] + dp [ k + 1 ][ j ] + sum [ j ] - sum [ i - 1 ]); } } } return dp [ 1 ][ n ]; } }; \u6574\u7406\u4eba \u8ba118-8 \u97a0\u6c38\u5168","title":"\u533a\u95f4 DP"},{"location":"DP/%E6%95%B0%E4%BD%8DDP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //(\u4e00\u5b9a\u8981\u628a dp \u65b9\u7a0b\u6240\u8868\u793a\u7684\u72b6\u6001\u8bbe\u597d\u518d\u8f6c\u79fb) //hdu2089 \u9898\u610f\uff1a\u533a\u95f4\u5185\u4e0d\u5305\u542b 62 \u548c 4 \u7684\u4e2a\u6570 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 25 ; int n , m ; class DigitDp { public : int dp [ N ][ 2 ], a [ N ]; ///dp[i][j]\u4ee3\u8868\u679a\u4e3e\u5230\u7b2c i \u4f4d\u524d\u4e00\u4f4d\u662f j \u7684\u65b9\u6848\u6570 int dfs ( int now , int pre , int limit ) { if ( ! now ) return 1 ; ///\u679a\u4e3e\u5230\u6700\u540e\u4e00\u4f4d\u540e\u5c31\u8981\u68c0\u67e5\u72b6\u6001\u8fd9\u91cc\u56e0\u4e3a\u679a\u4e3e\u7684\u8fc7\u7a0b \u4e2d\u5c31\u628a\u72b6\u6001\u68c0\u67e5\u5b8c\u4e86\u76f4\u63a5\u8fd4\u56de 1 if ( ! limit && ~ dp [ now ][ pre ]) ///\u5982\u679c\u5f53\u524d\u4f4d\u7684\u503c\u6ca1\u8fbe\u5230\u6700\u9ad8\u4e14\u6b21\u72b6\u6001\u5df2\u7ecf \u8bbf\u95ee\u8fc7 return dp [ now ][ pre ]; int up = limit ? a [ now ] : 9 , ans = 0 ; ///\u6839\u636e limit \u662f\u5426\u662f 1 \u51b3\u5b9a\u4e0b\u4e00\u4f4d\u6700\u591a 17 \u679a\u4e3e\u5230\u591a\u5c11 for ( int i = 0 ; i <= up ; i ++ ) { if (( pre && i == 2 ) || ( i == 4 )) ///\u5982\u679c\u524d\u4e00\u4f4d\u662f 6 \u4e14\u5f53\u524d\u4f4d\u662f 2 \u6216\u8005\u5f53 \u524d\u4f4d\u662f 4 \u76f4\u63a5\u8df3\u8fc7 continue ; ans += dfs ( now - 1 , i == 6 , i == up && limit ); ///\u7edf\u8ba1\u5f53\u524d\u72b6\u6001\u7684\u7b54\u6848 \u4e5f\u5c31\u662f dp \u7684\u8fc7\u7a0b } if ( ! limit ) ///\u5f53\u524d\u4f4d\u503c\u672a\u8fbe\u5230\u6700\u9ad8\u624d\u80fd\u8bb0\u5fc6\u5316 dp [ now ][ pre ] = ans ; return ans ; } int solve ( int num ) { ///\u62c6\u6570\u5b57 int cnt = 0 ; while ( num ) { a [ ++ cnt ] = num % 10 ; num /= 10 ; } memset ( dp , - 1 , sizeof dp ); ///\u521d\u59cb\u5316-1 \u7684\u539f\u56e0\u5c31\u662f\u56e0\u4e3a\u6709\u4e9b\u72b6\u6001\u7684\u65b9\u6848 \u6570\u53ef\u80fd\u662f 0 return dfs ( cnt , 0 , 1 ); } } dp ; int main () { while ( scanf ( \"%d%d\" , & n , & m ) && n + m ) { printf ( \"%d \\n \" , dp . solve ( m ) - dp . solve ( n - 1 )); } } \u6574\u7406\u4eba \u7f51\u7edc 18-2 \u5434\u56fd\u5e86","title":"\u6570\u4f4d DP"},{"location":"DP/%E6%9C%9F%E6%9C%9BDP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ( \u4e00\u822c\u662f\u6b63\u63a8 ) ///CF148D \u539f\u6765\u888b\u5b50\u91cc\u6709 w \u53ea\u767d\u9f20\u548c b \u53ea\u9ed1\u9f20 \u9f99\u548c\u738b\u5983\u8f6e\u6d41\u4ece\u888b\u5b50\u91cc\u6293\u8001\u9f20\u3002\u8c01\u5148\u6293\u5230\u767d \u8272\u8001\u5e08\u8c01\u5c31\u8d62\u3002 \u738b\u5983\u6bcf\u6b21\u6293\u4e00\u53ea\u8001\u9f20\uff0c\u9f99\u6bcf\u6b21\u6293\u5b8c\u4e00\u53ea\u8001\u9f20\u4e4b\u540e\u4f1a\u6709\u4e00\u53ea\u8001\u9f20 \u8dd1\u51fa\u6765\u3002 \u6bcf\u6b21\u6293\u8001\u9f20\u548c\u8dd1\u51fa\u6765\u7684\u8001\u9f20\u90fd\u662f\u968f\u673a\u7684\u3002 \u5982\u679c\u4e24\u4e2a\u4eba\u90fd\u6ca1\u6709\u6293\u5230\u767d\u8272 \u8001\u9f20\u5219\u9f99\u8d62\u3002\u738b\u5983\u5148\u6293\u3002 \u95ee\u738b\u5983\u8d62\u7684\u6982\u7387\u3002 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 1005 ; const int mod = 1e9 + 7 ; int w , b ; class Pdp { public : double dp [ maxn ][ maxn ]; ///\u8bbe dp[i][j]\u8868\u793a\u73b0\u5728\u8f6e\u5230\u738b\u5983\u6293\u65f6\u6709 i \u53ea\u767d\u9f20\uff0cj \u53ea \u9ed1\u9f20\uff0c\u738b\u5983\u8d62\u7684\u6982\u7387 void init () { ///\u521d\u59cb\u5316 for ( int i = 1 ; i <= w ; i ++ ) ///\u56e0\u4e3a\u90fd\u662f\u767d\u8272\u8001\u9f20\uff0c\u6293\u4e00\u6b21\u80af\u5b9a\u8d62\u4e86\u3002 dp [ i ][ 0 ] = 1 ; for ( int i = 0 ; i <= b ; i ++ ) ///\u56e0\u4e3a\u6ca1\u6709\u767d\u8272\u8001\u9f20\u4e86 dp [ 0 ][ i ] = 0 ; } void solve () { ///\u63a8\u51fa\u9012\u63a8\u516c\u5f0f for ( int i = 1 ; i <= w ; i ++ ) { for ( int j = 1 ; j <= b ; j ++ ) { if ( i + j == 0 ) continue ; dp [ i ][ j ] += i * 1.0 / ( i + j ); ///\u767d if ( j >= 3 ) dp [ i ][ j ] += ( j * 1.0 ) / ( i + j ) * ( j - 1 ) * 1.0 / ( i + j - 1 ) * ( j - 2 ) / ( i + j - 2 ) * dp [ i ][ j - 3 ]; ///\u9ed1\u9ed1\u9ed1 if ( j >= 2 ) dp [ i ][ j ] += ( j * 1.0 ) / ( i + j ) * ( j - 1 ) * 1.0 / ( i + j - 1 ) * ( i ) * 1.0 / ( i + j - 2 ) * dp [ i - 1 ][ j - 2 ]; ///\u9ed1\u9ed1\u767d } } } void printans () { ///\u8f93\u51fa\u7b54\u6848 printf ( \"%.10f \\n \" , dp [ w ][ b ]); } } dp ; int main () { while ( ~ scanf ( \"%d%d\" , & w , & b )) { dp . init (); dp . solve (); dp . printans (); } } \u6574\u7406\u4eba \u7f51\u7edc 18-2 \u5434\u56fd\u5e86","title":"\u671f\u671b DP"},{"location":"DP/%E6%A0%91%E5%BD%A2DP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ///\u6c42\u6811\u7684\u91cd\u5fc3 class TreeRoot { public : int sz [ maxn ], f [ maxn ], vis [ maxn ], root ; //sz[i] i \u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u5927\u5c0f // f[i] i \u8282\u70b9\u4e3a\u6839\u7684\u6700\u5927\u5b50\u6811\u5927\u5c0f //root \u91cd\u5fc3 n \u6811\u7684\u8282\u70b9\u6570\u91cf void solve ( int u ) { sz [ u ] = 1 ; f [ u ] = 0 ; vis [ u ] = 1 ; for ( int i = head [ u ]; i != - 1 ; i = edge [ i ]. next ) { int v = edge [ i ]. to ; if ( vis [ v ]) continue ; solve ( v ); sz [ u ] += sz [ v ]; f [ u ] = max ( f [ u ], sz [ v ]); 15 } f [ u ] = max ( f [ u ], n - sz [ u ]); if ( f [ root ] > f [ u ] || root == 0 ) root = u ; } int get_root ( int x ) { //\u63a5\u53e3 root = 0 ; memset ( vis , 0 , sizeof vis ); solve ( x ); return root ; } }; //\u6c42\u6811\u7684\u6700\u5927\u72ec\u7acb\u96c6 vector < int > G [ maxn ]; class TreeNum { public : int sz [ maxn ], dp [ maxn ][ 2 ], vis [ maxn ]; ///\u5b50\u6811\u5927\u5c0f\uff0cdp[i][0/1]\u8282\u70b9 i \u9009/\u4e0d\u9009\u7684\u5b50\u6811\u6700\u4f18\u89e3\uff0c\u91cd\u590d\u70b9\u4e0d\u8bbf\u95ee void dfs ( int x ) { vis [ x ] = 1 ; dp [ x ][ 0 ] = 0 ; dp [ x ][ 1 ] = 1 ; for ( int i = 0 ; i < G [ x ]. size (); i ++ ) { int y = G [ x ][ i ]; if ( vis [ y ]) continue ; dfs ( y ); dp [ x ][ 0 ] += max ( dp [ y ][ 0 ], dp [ y ][ 1 ]); dp [ x ][ 1 ] += dp [ y ][ 0 ]; } } int get_num ( int x ) { //\u63a5\u53e3 memset ( vis , 0 , sizeof vis ); solve ( x ); return max ( dp [ x ][ 0 ], dp [ x ][ 1 ]); } }; \u6574\u7406\u4eba \u8ba118-8 \u97a0\u6c38\u5168","title":"\u6811\u5f62 DP"},{"location":"DP/%E6%A6%82%E7%8E%87DP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // (\u4e00\u822c\u662f\u9006\u63a8)19 // ///POJ2096 \u4e00\u4e2a\u8f6f\u4ef6\u6709 s \u4e2a\u5b50\u7cfb\u7edf\uff0c\u4f1a\u4ea7\u751f n \u79cd bug // \u67d0\u4eba\u4e00\u5929\u53d1\u73b0\u4e00\u4e2a bug, // \u8fd9\u4e2a bug \u5c5e\u4e8e\u4e00\u4e2a\u5b50\u7cfb\u7edf\uff0c\u5c5e\u4e8e\u4e00\u4e2a\u5206\u7c7b // \u6bcf\u4e2a bug \u5c5e\u4e8e\u67d0\u4e2a\u5b50\u7cfb\u7edf\u7684\u6982\u7387\u662f 1 / // s, // \u5c5e\u4e8e\u67d0\u79cd\u5206\u7c7b\u7684\u6982\u7387\u662f 1 / n // \u95ee\u53d1\u73b0 n \u79cd bug, // \u6bcf\u4e2a\u5b50\u7cfb\u7edf\u90fd\u53d1\u73b0 bug \u7684\u5929\u6570\u7684\u671f\u671b\u3002 const int N = 1005 ; const int mod = 1e9 + 7 ; int n , m ; class Edp { public : double dp [ N ][ N ]; ///dp[i][j]\u8868\u793a\u5df2\u7ecf\u627e\u5230 i \u79cd bug,j \u4e2a\u7cfb\u7edf\u7684 bug\uff0c\u8fbe\u5230\u76ee\u6807\u72b6 \u6001\u7684\u5929\u6570\u7684\u671f\u671b void init () { ///\u521d\u59cb\u5316 dp [ n ][ m ] = 0 ; ///dp[n][m]=0; } void solve () { ///\u63a8\u5bfc\u51fa\u9012\u63a8\u65b9\u7a0b\uff0c\u6bcf\u4e00\u79cd\u72b6\u6001\u7684\u6982\u7387\u4e0d\u8981\u7b97\u9519(\u8981\u7528 double) for ( int i = n ; i >= 0 ; i -- ) { for ( int j = m ; j >= 0 ; j -- ) { if ( i == n && j == m ) continue ; double p1 = ( i * j ) * 1.0 / ( n * m ); double p2 = (( n - i ) * j ) * 1.0 / ( n * m ); double p3 = ( i * ( m - j )) * 1.0 / ( n * m ); double p4 = (( n - i ) * ( m - j )) * 1.0 / ( n * m ); dp [ i ][ j ] = ( dp [ i + 1 ][ j ] * p2 + dp [ i ][ j + 1 ] * p3 + dp [ i + 1 ][ j + 1 ] * p4 + 1.0 ) / ( 1 - p1 ); } } } void printans () { ///\u8f93\u51fa printf ( \"%.4f \\n \" , dp [ 0 ][ 0 ]); ///\u8981\u6c42\u7684\u7b54\u6848 } } dp ; \u6574\u7406\u4eba \u7f51\u7edc 18-2 \u5434\u56fd\u5e86","title":"\u6982\u7387 DP"},{"location":"DP/%E7%8A%B6%E5%8E%8BDP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ///hdu5418 \u9898\u610f\uff1an \u4e2a\u57ce\u5e02\uff0cm \u6761\u65e0\u5411\u8fb9\uff0c\u95ee\u4ece 1 \u53f7\u57ce\u5e02\u7ecf\u8fc7\u6240\u6709\u57ce\u5e02\u5728\u56de\u5230 1 \u53f7\u57ce\u5e02\u7684 \u6700\u5c11\u82b1\u8d39 #include <bits/stdc++.h> using namespace std ; const int maxn = 2e6 + 6 ; const int N = 20 ; ///\u57ce\u5e02\u70b9\u6570 const int inf = 0x3f3f3f3f ; const int mod = 1e9 + 7 ; int n , m ; ///\u57ce\u5e02\u6570\u91cf\uff0c\u8fb9\u6570\u91cf int a [ N ][ N ]; ///\u90bb\u63a5\u77e9\u9635\u5b58\u56fe class State { public : int dp [ N ][( 1 << N ) + 10 ]; ///dp[i][S] \u4e3a\u5f53\u524d\u5728 i \u8d70\u8fc7\u7684\u96c6\u5408\u4e3a S \u7684\u82b1\u8d39, int solve () { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ][ j ] = min ( a [ i ][ j ], a [ i ][ k ] + a [ k ][ j ]); } } } ///floyd \u6c42\u4e24\u70b9\u95f4\u6700\u77ed\u8ddd\u79bb memset ( dp , inf , sizeof dp ); dp [ 0 ][ 1 ] = 0 ; int limit = 1 << n ; for ( int S = 0 ; S < limit ; S ++ ) { for ( int i = 0 ; i < n ; i ++ ) if (( 1 << i ) & S ) { ///\u8d77\u70b9 for ( int j = 0 ; j < n ; j ++ ) if ( ! (( 1 << j ) & S )) { ///\u7ec8\u70b9 dp [ j ][ S | ( 1 << j )] = min ( dp [ j ][ S | ( 1 << j )], dp [ i ][ S ] + a [ i ][ j ]); } } } int ans = inf ; 14 for ( int i = 0 ; i < n ; i ++ ) { ans = min ( ans , dp [ i ][ limit - 1 ] + a [ 0 ][ i ]); } return ans ; } } zdp ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) a [ i ][ j ] = ( i == j ? 0 : inf ); } for ( int i = 1 ; i <= m ; i ++ ) { int u , v , w ; scanf ( \"%d%d%d\" , & u , & v , & w ); u -- ; v -- ; ///\u8fb9\u4ece 0 \u5f00\u59cb\u8ba1\u6570\uff0c\u65b9\u4fbf\u8f6c\u79fb a [ u ][ v ] = min ( a [ u ][ v ], w ); ///\u907f\u514d\u6709\u91cd\u8fb9 a [ v ][ u ] = a [ u ][ v ]; } printf ( \"%d \\n \" , zdp . solve ()); } } \u6574\u7406\u4eba \u8ba118-8 \u97a0\u6c38\u5168","title":"\u72b6\u6001\u538b\u7f29DP"},{"location":"Data_Structure/","text":"","title":"Index"},{"location":"Data_Structure/RMQ/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 //poj3264 \u9759\u6001\u533a\u95f4\u6700\u5927\u503c\u51cf\u6700\u5c0f\u503c #include <map> #include <cmath> #include <vector> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; #define LL long long const int maxn = 1e5 + 7 ; const int mod = 99991 ; const int INF = 0x3f3f3f3f ; int MIN [ maxn << 2 ], MAX [ maxn << 2 ]; class RMQ { public : #define lson l, m, rt << 1 #define rson m + 1, r, rt << 1 | 1 void push_up ( int rt ) { MIN [ rt ] = min ( MIN [ rt << 1 ], MIN [ rt << 1 | 1 ]); MAX [ rt ] = max ( MAX [ rt << 1 ], MAX [ rt << 1 | 1 ]); } void build ( int l , int r , int rt ) { if ( l == r ) { scanf ( \"%d\" , & MIN [ rt ]); MAX [ rt ] = MIN [ rt ]; return ; } int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); push_up ( rt ); } int query_min ( int L , int R , int l , int r , int rt ) { 26 if ( L <= l && r <= R ) { return MIN [ rt ]; } int IMIN = INF ; int m = ( l + r ) >> 1 ; if ( L <= m ) IMIN = min ( IMIN , query_min ( L , R , lson )); if ( R > m ) IMIN = min ( IMIN , query_min ( L , R , rson )); return IMIN ; } int query_max ( int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return MAX [ rt ]; } int IMAX = 0 ; int m = ( l + r ) >> 1 ; if ( L <= m ) IMAX = max ( IMAX , query_max ( L , R , lson )); if ( R > m ) IMAX = max ( IMAX , query_max ( L , R , rson )); return IMAX ; } } rmq ; int main () { int n , q ; while ( ~ scanf ( \"%d%d\" , & n , & q )) { rmq . build ( 1 , n , 1 ); while ( q -- ) { int l , r ; scanf ( \"%d%d\" , & l , & r ); printf ( \"%d \\n \" , rmq . query_max ( l , r , 1 , n , 1 ) - rmq . query_min ( l , r , 1 , n , 1 )); } } return 0 ; } \u6ce8\uff1a\u8fd9\u662f\u57fa\u4e8e\u7ebf\u6bb5\u6811\u5b9e\u73b0 RMQ\uff0c\u5b83\u652f\u6301\u52a8\u6001 RMQ \u95ee\u9898\u7684\u6c42\u89e3\uff0c\u81f3\u4e8e\u533a\u95f4\u4fee\u6539\u7684\u4ee3\u7801\uff0c\u8bf7\u8be6 \u89c1\u7ebf\u6bb5\u6811\u6a21\u677f\u3002 \u6574\u7406\u4eba\uff1a\u8ba1 18-9 \u80e1\u5c0f\u6587","title":"RMQ"},{"location":"Data_Structure/ST/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //\u6d1b\u8c37 p3865 \u9898\u610f\uff1a\u67e5\u8be2\u9759\u6001\u533a\u95f4\u6700\u5927\u503c #include <cmath> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> 24 using namespace std ; #define LL long long const int maxn = 1e5 + 7 ; int dp [ maxn ][ 30 ]; int a [ maxn ]; class ST { public : void init_ST ( int n ) { memset ( dp , 0 , sizeof ( dp )); for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ][ 0 ] = a [ i ]; } for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; i ++ ) { dp [ i ][ j ] = max ( dp [ i ][ j - 1 ], dp [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } int query ( int l , int r ) { int k = log ( r - l + 1.0 ) / log ( 2.0 ); return max ( dp [ l ][ k ], dp [ r - ( 1 << k ) + 1 ][ k ]); } } st ; int main () { int n , m ; while ( ~ scanf ( \"%d%d\" , & n , & m )) { for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); } st . init_ST ( n ); while ( m -- ) { int l , r ; scanf ( \"%d%d\" , & l , & r ); printf ( \"%d \\n \" , st . query ( l , r )); } } return 0 ; } \u6574\u7406\u4eba \u8ba118-9 \u80e1\u5c0f\u6587","title":"ST\u8868"},{"location":"Data_Structure/%E5%88%86%E5%9D%97/","text":"1 2 HDU3468 \u9898\u610f\uff1an \u4e2a\u6570\uff0cq \u6b21\u8be2\u95ee\u5417\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa\u4e00\u4e2a\u5b57\u6bcd s\uff0c\u82e5 s = \u2018C\u2019\uff0c\u5219\u7ed9\u51fa\u4e00\u7ec4 x\uff0c y\uff0cz \u5c06[x, y]\u4e2d\u6240\u6709\u6570\u52a0\u4e0a z\u3002\u82e5 s = \u2018Q\u2019\uff0c\u5219\u7ed9\u51fa\u4e00\u7ec4 x\uff0cy\uff0c\u95ee[x, y]\u7684\u533a\u95f4\u548c\u662f\u591a\u5c11\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> using namespace std ; const int N = 1e5 + 7 ; typedef long long ll ; 42 class Block { public : int pos [ N ], L [ N ], R [ N ], block , num , n , m ; ll add [ N ], a [ N ], sum [ N ]; void build () //\u521d\u59cb\u5316 { block = sqrt ( n ); num = block ; if ( n % block ) num ++ ; //num \u8868\u793a\u5757\u7684\u4e2a\u6570\uff0cblock \u8868\u793a\u5757\u7684\u5927\u5c0f\u3002 for ( int i = 1 ; i <= num ; i ++ ) { L [ i ] = ( i - 1 ) * block + 1 ; //\u8be5\u5757\u5de6\u7aef\u70b9\u4f4d\u7f6e R [ i ] = i * block ; //\u8be5\u5757\u53f3\u7aef\u70b9\u4f4d\u7f6e } R [ num ] = n ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = L [ i ]; j <= R [ i ]; j ++ ) { pos [ j ] = i ; //\u7b2c\u51e0\u4e2a\u5757 sum [ i ] += a [ j ]; //\u5757\u7684\u533a\u95f4\u548c add [ j ] = 0 ; //\u589e\u91cf\u6807\u8bb0 } } } void change ( int l , int r , ll d ) //\u4fee\u6539\u64cd\u4f5c { int p = pos [ l ]; int q = pos [ r ]; if ( p == q ) { for ( int i = l ; i <= r ; i ++ ) a [ i ] += d ; sum [ p ] += ( r - l + 1 ) * d ; } else { for ( int i = p + 1 ; i <= q - 1 ; i ++ ) add [ i ] += d ; for ( int i = l ; i <= R [ p ]; i ++ ) a [ i ] += d ; sum [ p ] += ( R [ p ] - l + 1 ) * d ; for ( int i = L [ q ]; i <= r ; i ++ ) 43 a [ i ] += d ; sum [ q ] += ( r - L [ q ] + 1 ) * d ; } } ll ask ( int l , int r ) //\u67e5\u8be2\u64cd\u4f5c { int p = pos [ l ]; int q = pos [ r ]; ll ans = 0 ; if ( p == q ) { for ( int i = l ; i <= r ; i ++ ) ans += a [ i ]; ans += ( r - l + 1 ) * add [ p ]; } else { for ( int i = p + 1 ; i <= q - 1 ; i ++ ) ans += sum [ i ] + add [ i ] * ( R [ i ] - L [ i ] + 1 ); for ( int i = l ; i <= R [ p ]; i ++ ) ans += a [ i ]; ans += add [ p ] * ( R [ p ] - l + 1 ); for ( int i = L [ q ]; i <= r ; i ++ ) ans += a [ i ]; ans += add [ q ] * ( r - L [ q ] + 1 ); } return ans ; } } q ; int main () { scanf ( \"%d %d\" , & q . n , & q . m ); for ( int i = 1 ; i <= q . n ; i ++ ) scanf ( \"%lld\" , & q . a [ i ]); q . build (); while ( q . m -- ) { char c ; int x , y ; ll z ; scanf ( \" %c\" , & c ); if ( c == 'Q' ) { scanf ( \"%d %d\" , & x , & y ); printf ( \"%lld \\n \" , q . ask ( x , y )); 44 } else { scanf ( \"%d %d %lld\" , & x , & y , & z ); q . change ( x , y , z ); } } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u8463\u6587\u777f","title":"\u5206\u5757\u7b97\u6cd5"},{"location":"Data_Structure/%E6%89%AB%E6%8F%8F%E7%BA%BF/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include <bits/stdc++.h> using namespace std ; #define rep(i, j, k) for (int i = j; i <= k; i++) #define debug puts(\"*\"); const int N = 220 ; int n , cnt , t = 1 ; struct node { int l , r , cnt ; double len ; } tree [ N << 2 ]; struct knode { double x1 , y1 , y2 ; int k ; friend bool operator < ( knode a , knode b ) { return a . x1 < b . x1 ; } } line [ N ]; double raw [ N ], b [ N ], val [ N ]; void discrete () { sort ( raw + 1 , raw + 2 * n + 1 ); // rep(i,1,2*n)cout<<raw[i]<<\" \";puts(\"\"); rep ( i , 1 , 2 * n ) if ( i == 1 || raw [ i ] != raw [ i - 1 ]) b [ ++ cnt ] = raw [ i ]; // rep(i,1,cnt)cout<<b[i]<<\" \"; } int findx ( double x ) { return lower_bound ( b + 1 , b + cnt + 1 , x ) - b ; } void pushup ( int rt , int l , int r ) { if ( tree [ rt ]. cnt ) { tree [ rt ]. len = b [ r + 1 ] - b [ l ]; } else if ( l != r ) { tree [ rt ]. len = tree [ rt << 1 ]. len + tree [ rt << 1 | 1 ]. len ; } else tree [ rt ]. len = 0 ; return ; } void build ( int rt , int l , int r ) { tree [ rt ]. l = l , tree [ rt ]. r = r ; tree [ rt ]. len = 0.0 ; tree [ rt ]. cnt = 0 ; // cout<<l<<\" \"<<r<<endl; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( rt << 1 , l , mid ); build ( rt << 1 | 1 , mid + 1 , r ); } void update ( int rt , int l , int r , int x ) { if ( l <= tree [ rt ]. l && tree [ rt ]. r <= r ) { tree [ rt ]. cnt += x ; pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); return ; } int mid = ( tree [ rt ]. l + tree [ rt ]. r ) >> 1 ; ///2 if ( l <= mid ) update ( rt << 1 , l , r , x ); if ( r > mid ) update ( rt << 1 | 1 , l , r , x ); pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); } int main () { while ( ~ scanf ( \"%d\" , & n )) { if ( ! n ) break ; cnt = 0 ; /// 1 rep ( i , 1 , n ) { double x1 , y1 , x2 , y2 ; scanf ( \"%lf%lf%lf%lf\" , & x1 , & y1 , & x2 , & y2 ); raw [ i * 2 - 1 ] = y1 , raw [ i * 2 ] = y2 ; line [ i * 2 - 1 ]. x1 = x1 , line [ i * 2 - 1 ]. y1 = y1 , line [ i * 2 - 1 ]. y2 = y2 ; line [ i * 2 - 1 ]. k = 1 ; line [ i * 2 ]. x1 = x2 , line [ i * 2 ]. y1 = y1 , line [ i * 2 ]. y2 = y2 ; line [ i * 2 ]. k = - 1 ; } discrete (); sort ( line + 1 , line + 2 * n + 1 ); double ans = 0 ; build ( 1 , 1 , cnt ); rep ( i , 1 , 2 * n ) { ans += tree [ 1 ]. len * ( line [ i ]. x1 - line [ i - 1 ]. x1 ); update ( 1 , findx ( line [ i ]. y1 ), findx ( line [ i ]. y2 ) - 1 , line [ i ]. k ); } printf ( \"Test case #%d \\n Total explored area: %.2lf \\n\\n \" , t ++ , ans ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u6768\u777f","title":"\u626b\u63cf\u7ebf"},{"location":"Data_Structure/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%841/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 //\u6d1b\u8c37 p3368 \u533a\u95f4\u66f4\u65b0\uff0c\u5355\u70b9\u67e5\u8be2 #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; #define LL long long const int maxn = 5e5 + 7 ; LL C [ maxn ]; int n , m ; class BITree { public : int lowbit ( int x ) { return x & ( - x ); } void update ( int x , LL y ) { for ( int i = x ; i <= n ; i += lowbit ( i )) { C [ i ] += y ; } } LL query ( int x ) { LL ans = 0 ; for ( int i = x ; i > 0 ; i -= lowbit ( i )) { ans += C [ i ]; } return ans ; } } bitree ; int main () { while ( ~ scanf ( \"%d%d\" , & n , & m )) { memset ( C , 0 , sizeof ( C )); LL temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { LL x ; scanf ( \"%lld\" , & x ); bitree . update ( i , x - temp ); temp = x ; } while ( m -- ) { int opt ; scanf ( \"%d\" , & opt ); if ( opt == 1 ) { int x , y ; LL k ; scanf ( \"%d%d%lld\" , & x , & y , & k ); bitree . update ( x , k ); bitree . update ( y + 1 , - k ); } else { int x ; scanf ( \"%d\" , & x ); printf ( \"%lld \\n \" , bitree . query ( x )); } } } return 0 ; } \u6574\u7406\u4eba \u8ba118-9 \u80e1\u5c0f\u6587","title":"\u4e00\u7ef4\u6811\u72b6\u6570\u7ec4"},{"location":"Data_Structure/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%842/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 //hdu1892 \u5355\u70b9\u66f4\u65b0\uff0c\u533a\u95f4\u6c42\u548c #include <map> #include <cmath> #include <vector> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; #define LL long long const int maxn = 1010 ; const int mod = 99991 ; 22 const int INF = 0x3f3f3f3f ; int c [ maxn ][ maxn ]; class BITree_2 { public : int lowbit ( int x ) { return x & ( - x ); } void update ( int x , int y , int val ) { for ( int i = x ; i <= 1001 ; i += lowbit ( i )) { for ( int j = y ; j <= 1001 ; j += lowbit ( j )) { c [ i ][ j ] += val ; } } } int query ( int x , int y ) { int ans = 0 ; for ( int i = x ; i > 0 ; i -= lowbit ( i )) { for ( int j = y ; j > 0 ; j -= lowbit ( j )) { ans += c [ i ][ j ]; } } return ans ; } } bitree_2 ; int main () { int T ; scanf ( \"%d\" , & T ); int cas = 1 ; while ( T -- ) { int Q ; scanf ( \"%d\" , & Q ); printf ( \"Case %d: \\n \" , cas ++ ); memset ( c , 0 , sizeof ( c )); while ( Q -- ) { char c ; scanf ( \" %c\" , & c ); if ( c == 'S' ) { int x1 , y1 , x2 , y2 ; scanf ( \"%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 ); x1 ++ , y1 ++ , x2 ++ , y2 ++ ; 23 if ( x1 > x2 ) swap ( x1 , x2 ); if ( y1 > y2 ) swap ( y1 , y2 ); printf ( \"%d \\n \" , bitree_2 . query ( x2 , y2 ) - bitree_2 . query ( x2 , y1 - 1 ) - bitree_2 . query ( x1 - 1 , y2 ) + bitree_2 . query ( x1 - 1 , y1 - 1 ) + ( x2 - x1 + 1 ) * ( y2 - y1 + 1 )); } else if ( c == 'A' ) { int x , y , val ; scanf ( \"%d%d%d\" , & x , & y , & val ); x ++ , y ++ ; bitree_2 . update ( x , y , val ); } else if ( c == 'D' ) { int x , y , val ; scanf ( \"%d%d%d\" , & x , & y , & val ); x ++ , y ++ ; int temp = bitree_2 . query ( x , y ) - bitree_2 . query ( x , y - 1 ) - bitree_2 . query ( x - 1 , y ) + bitree_2 . query ( x - 1 , y - 1 ); temp ++ ; temp = min ( temp , val ); bitree_2 . update ( x , y , - temp ); } else { int x1 , y1 , x2 , y2 , val ; scanf ( \"%d%d%d%d%d\" , & x1 , & y1 , & x2 , & y2 , & val ); x1 ++ , y1 ++ , x2 ++ , y2 ++ ; int temp = bitree_2 . query ( x1 , y1 ) - bitree_2 . query ( x1 , y1 - 1 ) - bitree_2 . query ( x1 - 1 , y1 ) + bitree_2 . query ( x1 - 1 , y1 - 1 ); temp ++ ; temp = min ( temp , val ); bitree_2 . update ( x1 , y1 , - temp ); bitree_2 . update ( x2 , y2 , temp ); } } } return 0 ; } \u6574\u7406\u4eba \u8ba118-9 \u80e1\u5c0f\u6587","title":"\u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/","text":"\u4f8b\u4e00\u3001\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728. \u00b6 ///\u6d1b\u8c37 P3806 \u7ed9\u5b9a\u4e00\u9897 n \u4e2a\u7ed3\u70b9\u7684\u65e0\u6839\u6811,\u6709 m \u6b21\u8be2\u95ee,\u6bcf\u6b21\u8be2\u95ee\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728. \u601d\u60f3: \u7528\u6876\u8bb0\u5f55\u8def\u5f84,\u5224\u65ad\u662f\u5426\u5b58\u5728\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9 \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle() \u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans[] \u6570\u7ec4 \u6a21\u5757\u8bf4\u660e: 1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570 Root.getroot() \u00b6 \u8f93\u5165 : \u4f7f\u7528 Root.getroot(u,fa,sum) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9, sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927\u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt 2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis() \u00b6 \u8f93\u5165\uff1a\u4f7f\u7528 CalDis.caldis(int u,int fa) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa : \u5f97\u5230 di[] \u6570\u7ec4, dis[] \u6570\u7ec4\u5927\u5c0f\u4e3a tp ,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[] \u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6 3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle() \u00b6 \u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans[] \u6570\u7ec4,,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f 4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz() \u00b6 \u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9 5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve() \u00b6 \u8f93\u5165 : \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans[] \u6570\u7ec4,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K [ amn ]; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; 48 calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > ( int ) 1e7 ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 bool jg [( int ) 1e7 + 1 ]; int ans [ amn ]; class SovleDis { public : CalDis cd ; queue < int > bk ; void sovle ( int u ) { jg [ 0 ] = 1 ; bk . push ( 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; 49 if ( vis [ v ]) continue ; cd . init ( v , w ); cd . caldis ( v , u ); for ( int j = 1 ; j <= cd . tp ; j ++ ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( K [ k ] >= cd . di [ j ]) ans [ k ] += jg [ K [ k ] - cd . di [ j ]]; } } for ( int j = 1 ; j <= cd . tp ; j ++ ) { jg [ cd . di [ j ]] = 1 ; bk . push ( cd . di [ j ]); } } while ( bk . size ()) { jg [ bk . front ()] = 0 ; bk . pop (); } } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; s . sovle ( u ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ]) continue ; rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d%d\" , & n , & m ); 50 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d\" , & K [ i ]); } df . sovle (); for ( int i = 1 ; i <= m ; i ++ ) { if ( ans [ i ]) printf ( \"AYE \\n \" ); else printf ( \"NAY \\n \" ); } } \u4f8b\u4e8c\u3001\u6811\u4e0a\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e K \u7684\u70b9\u5bf9\u6570\u91cf \u00b6 ///\u6d1b\u8c37 P4178 \u7ed9\u5b9a\u4e00\u68f5 n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u6761\u8fb9\u6709\u8fb9\u6743\uff0c\u6c42\u51fa\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6570\u91cf\u3002 \u601d\u60f3: \u7528\u5bb9\u65a5\u548c\u53cc\u6307\u9488\u8bb0\u5f55\u8def\u5f84,\u8ba1\u7b97\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6709\u591a\u5c11\u4e2a. \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle()\u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans \u6a21\u5757\u8bf4\u660e: 1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570 Root.getroot() \u00b6 \u8f93\u5165: \u4f7f\u7528 Root.getroot(u,fa,sum),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3au\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927 \u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt 2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis() \u00b6 \u8f93\u5165: \u4f7f\u7528 CalDis.caldis(int u,int fa),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230 di[]\u6570\u7ec4,di[]\u6570\u7ec4\u5927\u5c0f\u4e3a tp,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[]\u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6 3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle() \u00b6 \u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u,int fa,int w),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,w \u4e3a fa \u5230 u \u7684 \u8fb9\u6743 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f 4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz() \u00b6 \u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u),u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9 5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve() \u00b6 \u8f93\u5165: \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K ; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } 52 maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > K ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 int ans ; class SovleDis { public : CalDis cd ; int sovle ( int u , int fa , int w ) { cd . init ( u , w ); cd . caldis ( u , fa ); sort ( cd . di + 1 , cd . di + 1 + cd . tp ); int l = 1 , r = cd . tp , ans = 0 ; while ( l < r ) { if ( cd . di [ l ] + cd . di [ r ] <= K ) { ans += r - l ; l ++ ; } else r -- ; 53 } return ans ; } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; ans += s . sovle ( u , - 1 , 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ]) continue ; ans -= s . sovle ( v , u , w ); rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } ans = 0 ; scanf ( \"%d\" , & K ); df . sovle (); printf ( \"%d \\n \" , ans ); } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u8499\u665f\u7ef4","title":"\u70b9\u5206\u6cbb"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#k","text":"///\u6d1b\u8c37 P3806 \u7ed9\u5b9a\u4e00\u9897 n \u4e2a\u7ed3\u70b9\u7684\u65e0\u6839\u6811,\u6709 m \u6b21\u8be2\u95ee,\u6bcf\u6b21\u8be2\u95ee\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728. \u601d\u60f3: \u7528\u6876\u8bb0\u5f55\u8def\u5f84,\u5224\u65ad\u662f\u5426\u5b58\u5728\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9 \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle() \u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans[] \u6570\u7ec4 \u6a21\u5757\u8bf4\u660e:","title":"\u4f8b\u4e00\u3001\u6811\u4e0a\u8ddd\u79bb\u4e3a k \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728."},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#1-rootgetroot","text":"\u8f93\u5165 : \u4f7f\u7528 Root.getroot(u,fa,sum) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9, sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927\u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt","title":"1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570Root.getroot()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#2-caldiscaldis","text":"\u8f93\u5165\uff1a\u4f7f\u7528 CalDis.caldis(int u,int fa) , u \u4e3a\u5f53\u524d\u7ed3\u70b9, fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa : \u5f97\u5230 di[] \u6570\u7ec4, dis[] \u6570\u7ec4\u5927\u5c0f\u4e3a tp ,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[] \u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6","title":"2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#3-sovledissovle","text":"\u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans[] \u6570\u7ec4,,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f","title":"3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#4-dfzdfz","text":"\u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u) , u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9","title":"4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#5-dfzsolve","text":"\u8f93\u5165 : \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans[] \u6570\u7ec4,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K [ amn ]; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; 48 calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > ( int ) 1e7 ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 bool jg [( int ) 1e7 + 1 ]; int ans [ amn ]; class SovleDis { public : CalDis cd ; queue < int > bk ; void sovle ( int u ) { jg [ 0 ] = 1 ; bk . push ( 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; 49 if ( vis [ v ]) continue ; cd . init ( v , w ); cd . caldis ( v , u ); for ( int j = 1 ; j <= cd . tp ; j ++ ) { for ( int k = 1 ; k <= m ; k ++ ) { if ( K [ k ] >= cd . di [ j ]) ans [ k ] += jg [ K [ k ] - cd . di [ j ]]; } } for ( int j = 1 ; j <= cd . tp ; j ++ ) { jg [ cd . di [ j ]] = 1 ; bk . push ( cd . di [ j ]); } } while ( bk . size ()) { jg [ bk . front ()] = 0 ; bk . pop (); } } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; s . sovle ( u ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ]) continue ; rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d%d\" , & n , & m ); 50 for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d\" , & K [ i ]); } df . sovle (); for ( int i = 1 ; i <= m ; i ++ ) { if ( ans [ i ]) printf ( \"AYE \\n \" ); else printf ( \"NAY \\n \" ); } }","title":"5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#k_1","text":"///\u6d1b\u8c37 P4178 \u7ed9\u5b9a\u4e00\u68f5 n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u6761\u8fb9\u6709\u8fb9\u6743\uff0c\u6c42\u51fa\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6570\u91cf\u3002 \u601d\u60f3: \u7528\u5bb9\u65a5\u548c\u53cc\u6307\u9488\u8bb0\u5f55\u8def\u5f84,\u8ba1\u7b97\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e k \u7684\u70b9\u5bf9\u6709\u591a\u5c11\u4e2a. \u4f7f\u7528\u65b9\u6cd5: \u8c03\u7528 DFZ.sovle()\u51fd\u6570\u540e\u7b54\u6848\u5b58\u5165 ans \u6a21\u5757\u8bf4\u660e:","title":"\u4f8b\u4e8c\u3001\u6811\u4e0a\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e K \u7684\u70b9\u5bf9\u6570\u91cf"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#1-rootgetroot_1","text":"\u8f93\u5165: \u4f7f\u7528 Root.getroot(u,fa,sum),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3au\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,sum \u662f\u5f53\u524d\u8fde\u901a\u5757\u7684\u5927 \u5c0f \u8f93\u51fa: \u8fd4\u56de\u91cd\u5fc3\u7ed3\u70b9\u7f16\u53f7 rt","title":"1. \u6c42\u6811\u7684\u91cd\u5fc3\u51fd\u6570 Root.getroot()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#2-caldiscaldis_1","text":"\u8f93\u5165: \u4f7f\u7528 CalDis.caldis(int u,int fa),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \u8f93\u51fa: \u5f97\u5230 di[]\u6570\u7ec4,di[]\u6570\u7ec4\u5927\u5c0f\u4e3a tp,\u5b58\u6709\u6240\u6709\u57fa\u672c\u8def\u5f84\u7684\u957f\u5ea6,\u8fd8\u6709 dis[]\u6570\u7ec4,\u5b58\u7684\u662f\u7ed3\u70b9 u \u5230\u5f53\u524d\u6839\u8282\u70b9\u7684\u957f\u5ea6","title":"2. \u8ba1\u7b97\u6240\u6709\u7ed3\u70b9\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\u51fd\u6570 CalDis.caldis()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#3-sovledissovle_1","text":"\u8f93\u5165: \u4f7f\u7528 SovleDis.sovle(int u,int fa,int w),u \u4e3a\u5f53\u524d\u7ed3\u70b9,fa \u4e3a u \u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9,w \u4e3a fa \u5230 u \u7684 \u8fb9\u6743 \u8f93\u51fa: \u5f97\u5230\u5f53\u524d ans,\u5b58\u6709\u6bcf\u6b21\u66f4\u65b0\u7684\u7b54\u6848\u4fe1\u606f","title":"3. \u8ba1\u7b97\u5408\u6cd5\u8def\u5f84\u51fd\u6570 SovleDis.sovle()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#4-dfzdfz_1","text":"\u8f93\u5165: \u4f7f\u7528 DFZ.dfz(int u),u \u4e3a\u5f53\u524d\u7ed3\u70b9 \u8f93\u51fa: \u9012\u5f52\u5404\u7ed3\u70b9","title":"4. \u70b9\u5206\u6cbb\u51fd\u6570 DFZ.dfz()"},{"location":"Data_Structure/%E7%82%B9%E5%88%86%E6%B2%BB/#5-dfzsolve_1","text":"\u8f93\u5165: \u65e0 \u8f93\u51fa: \u5f97\u5230\u6700\u7ec8 ans,\u5b58\u6709\u7b54\u6848\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <bits/stdc++.h> using namespace std ; const int amn = 1e5 + 5 , inf = 1e9 ; int n , m , K ; ///\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe int head [ amn ], etot ; struct edge { int nxt , v , w ; } eg [ amn ]; void add ( int u , int v , int w ) { eg [ ++ etot ] = { head [ u ], v , w }; head [ u ] = etot ; } int vis [ amn ]; ///\u6c42\u6811\u7684\u91cd\u5fc3 class Root { public : int siz [ amn ], maxt [ amn ], rt ; void calsiz ( int u , int fa , int sum ) { siz [ u ] = 1 ; maxt [ u ] = 0 ; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v ; if ( vis [ v ] || v == fa ) continue ; calsiz ( v , u , sum ); siz [ u ] += siz [ v ]; maxt [ u ] = max ( maxt [ u ], siz [ v ]); } 52 maxt [ u ] = max ( maxt [ u ], sum - siz [ u ]); if ( maxt [ u ] < maxt [ rt ]) rt = u ; } void getroot ( int u , int fa , int sum ) { rt = 0 ; maxt [ rt ] = inf ; calsiz ( u , fa , sum ); } }; ///\u6c42\u57fa\u672c\u8def\u5f84 dis class CalDis { public : int dis [ amn ], di [ amn ], tp ; void caldis ( int u , int fa ) { if ( dis [ u ] > K ) return ; di [ ++ tp ] = dis [ u ]; for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ] || v == fa ) continue ; dis [ v ] = dis [ u ] + w ; caldis ( v , u ); } } void init ( int v , int w ) { tp = 0 ; dis [ v ] = w ; } }; ///\u5224\u65ad\u8def\u5f84 int ans ; class SovleDis { public : CalDis cd ; int sovle ( int u , int fa , int w ) { cd . init ( u , w ); cd . caldis ( u , fa ); sort ( cd . di + 1 , cd . di + 1 + cd . tp ); int l = 1 , r = cd . tp , ans = 0 ; while ( l < r ) { if ( cd . di [ l ] + cd . di [ r ] <= K ) { ans += r - l ; l ++ ; } else r -- ; 53 } return ans ; } }; ///\u70b9\u5206\u6cbb class DFZ { public : Root rt ; SovleDis s ; void dfz ( int u ) { vis [ u ] = 1 ; ans += s . sovle ( u , - 1 , 0 ); for ( int i = head [ u ]; i ; i = eg [ i ]. nxt ) { int v = eg [ i ]. v , w = eg [ i ]. w ; if ( vis [ v ]) continue ; ans -= s . sovle ( v , u , w ); rt . getroot ( v , u , rt . siz [ v ]); dfz ( rt . rt ); } } void sovle () { rt . getroot ( 1 , - 1 , n ); dfz ( rt . rt ); } }; int main () { DFZ df ; int a , b , c ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & a , & b , & c ); add ( a , b , c ); add ( b , a , c ); } ans = 0 ; scanf ( \"%d\" , & K ); df . sovle (); printf ( \"%d \\n \" , ans ); } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u8499\u665f\u7ef4","title":"5. \u70b9\u5206\u6cbb\u8c03\u7528 DFZ.solve()"},{"location":"Data_Structure/%E7%82%B9%E5%88%A8/","text":"1 2 3 4 5 6 ///\u6d1b\u8c37 P3384 \u9898\u610f\uff1a\u5bf9\u4e8e\u4e00\u9897\u6811\u6709\u5982\u4e0b\u64cd\u4f5c \u64cd\u4f5c 1: 1 x y z \u8868\u793a\u5c06\u6811\u4ece x \u5230 y \u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0a z\u3002 \u64cd\u4f5c 2: 2 x y \u8868\u793a\u6c42\u6811\u4ece x \u5230 y \u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\u3002 \u64cd\u4f5c 3: 3 x z \u8868\u793a\u5c06\u4ee5 x \u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0a z\u3002 \u64cd\u4f5c 4: 4 x \u8868\u793a\u6c42\u4ee5 x \u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 #include <bits/stdc++.h> #define ls rt << 1 #define rs rt << 1 | 1 using namespace std ; typedef long long ll ; const int N = 1e5 + 5 ; int n , m , mod ; struct Edge { int next , to ; } edge [ N << 1 ]; ///\u8fb9 int etot , head [ N ], Root ; int a [ N ]; inline void add ( int u , int v ) { edge [ etot ] = { head [ u ], v }; 34 head [ u ] = etot ++ ; } inline void init () { memset ( head , - 1 , sizeof ( head )); dfscnt = etot = 0 ; } class treeChainSubdivision { public : int son [ N ], tid [ N ], fa [ N ], dep [ N ], siz [ N ], top [ N ], rnk [ N ], dfscnt ; ///son \u91cd\u513f\u5b50\u7f16\u53f7,tid \u662f dfs \u5e8f,fa \u7236\u4eb2\u8282\u70b9,dep \u6df1\u5ea6\u4ece 1 \u5f00\u59cb\u7684 ///siz \u5b50\u6811\u5927\u5c0f,top \u5f53\u524d\u94fe\u9876\u7aef\u8282\u70b9,dfscnt \u662f dfs \u5e8f,rnk \u662f dfs \u5e8f\u4e3a i \u7684\u8282\u70b9 ///\u591a\u7ec4\u8f93\u5165\u65f6 son \u8981\u521d\u59cb\u5316\uff01\uff01\uff01 inline void dfs1 ( int x , int f , int deep ) { dep [ x ] = deep ; fa [ x ] = f ; siz [ x ] = 1 ; int maxson = - 1 ; for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == f ) continue ; dfs1 ( to , x , deep + 1 ); siz [ x ] += siz [ to ]; if ( siz [ to ] > maxson ) son [ x ] = to , maxson = siz [ to ]; } } inline void dfs2 ( int x , int topf ) { tid [ x ] = ++ dfscnt ; rnk [ dfscnt ] = x ; top [ x ] = topf ; if ( ! son [ x ]) return ; dfs2 ( son [ x ], topf ); for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa [ x ] || to == son [ x ]) continue ; dfs2 ( to , to ); } } inline void updpath ( int x , int y , int val ) { val %= mod ; while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); Tree . update ( 1 , 1 , n , tid [ top [ x ]], tid [ x ], val ); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); Tree . update ( 1 , 1 , n , tid [ x ], tid [ y ], val ); } inline int Qpath ( int x , int y ) { int ans = 0 ; while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); ans = ( ans + Tree . query ( 1 , 1 , n , tid [ top [ x ]], tid [ x ])) % mod ; x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); ans = ( ans + Tree . query ( 1 , 1 , n , tid [ x ], tid [ y ])) % mod ; return ans % mod ; } inline void updson ( int x , int val ) { Tree . update ( 1 , 1 , n , tid [ x ], tid [ x ] + siz [ x ] - 1 , val ); } inline int Qson ( int x ) { return Tree . query ( 1 , 1 , n , tid [ x ], tid [ x ] + siz [ x ] - 1 ); } } TCS ; class segmentTree { public : int tree [ N << 2 ], laz [ N << 2 ]; inline void build ( int rt , int l , int r ) { if ( l == r ) { tree [ rt ] = a [ TCS . rnk [ l ]] % mod ; return ; } int mid = ( l + r ) >> 1 ; build ( ls , l , mid ); build ( rs , mid + 1 , r ); tree [ rt ] = ( tree [ ls ] + tree [ rs ]) % mod ; } inline void pushdown ( int rt , int l , int r ) { if ( laz [ rt ]) { int mid = ( l + r ) >> 1 ; laz [ ls ] = ( laz [ ls ] + laz [ rt ]) % mod ; laz [ rs ] = ( laz [ rs ] + laz [ rt ]) % mod ; tree [ ls ] = ( tree [ ls ] + laz [ rt ] * ( mid - l + 1 ) % mod ) % mod ; tree [ rs ] = ( tree [ rs ] + laz [ rt ] * ( r - mid ) % mod ) % mod ; laz [ rt ] = 0 ; } } inline void update ( int rt , int l , int r , int ql , int qr , int val ) { if ( ql <= l && r <= qr ) { laz [ rt ] = ( laz [ rt ] + val ) % mod ; tree [ rt ] = ( tree [ rt ] + ( r - l + 1 ) * val % mod ) % mod ; return ; } pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) update ( ls , l , mid , ql , qr , val ); if ( qr > mid ) update ( rs , mid + 1 , r , ql , qr , val ); tree [ rt ] = ( tree [ ls ] + tree [ rs ]) % mod ; } inline int query ( int rt , int l , int r , int ql , int qr ) { if ( ql <= l && r <= qr ) return tree [ rt ]; pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; int res = 0 ; if ( ql <= mid ) res += query ( ls , l , mid , ql , qr ); if ( qr > mid ) res += query ( rs , mid + 1 , r , ql , qr ); return res % mod ; } } Tree ; int main () { scanf ( \"%d%d%d%d\" , & n , & m , & Root , & mod ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( int i = 1 ; i < n ; i ++ ) { int u , v ; scanf ( \"%d%d\" , & u , & v ); add ( u , v ); add ( v , u ); } TCS . dfs1 ( Root , 0 , 1 ); TCS . dfs2 ( Root , Root ); Tree . build ( 1 , 1 , n ); while ( m -- ) { int op , x , y , val ; scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d%d%d\" , & x , & y , & val ); Tree . updpath ( x , y , val ); } else if ( op == 2 ) { scanf ( \"%d%d\" , & x , & y ); printf ( \"%d \\n \" , TCS . Qpath ( x , y )); } else if ( op == 3 ) { scanf ( \"%d%d\" , & x , & y ); 37 TCS . updson ( x , y ); } else { scanf ( \"%d\" , & x ); printf ( \"%d \\n \" , TCS . Qson ( x )); } } return 0 ; } \u6574\u7406\u4eba\uff1a\u8ba1 18-7 \u725b\u4ed4\u8d85","title":"\u70b9\u5256"},{"location":"Data_Structure/%E7%BA%BF%E6%AE%B5%E6%A0%91lazy/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 ///poj3468 \u9898\u610f\uff1an \u4e2a\u6570\uff0cm \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u533a\u95f4\u52a0\u4e0a\u4e00\u4e2a\u6570\uff0c\u533a\u95f4\u67e5\u8be2\u548c #include <bits/stdc++.h> using namespace std ; #define rep(i, j, k) for (int i = j; i <= k; i++) #define debug puts(\"*\"); const int N = 220 ; int n , cnt , t = 1 ; struct node { int l , r , cnt ; double len ; } tree [ N << 2 ]; struct knode { double x1 , y1 , y2 ; int k ; friend bool operator < ( knode a , knode b ) { return a . x1 < b . x1 ; } } line [ N ]; double raw [ N ], b [ N ], val [ N ]; void discrete () { sort ( raw + 1 , raw + 2 * n + 1 ); // rep(i,1,2*n)cout<<raw[i]<<\" \";puts(\"\"); rep ( i , 1 , 2 * n ) if ( i == 1 || raw [ i ] != raw [ i - 1 ]) b [ ++ cnt ] = raw [ i ]; // rep(i,1,cnt)cout<<b[i]<<\" \"; } int findx ( double x ) { return lower_bound ( b + 1 , b + cnt + 1 , x ) - b ; } void pushup ( int rt , int l , int r ) { if ( tree [ rt ]. cnt ) { tree [ rt ]. len = b [ r + 1 ] - b [ l ]; } else if ( l != r ) { tree [ rt ]. len = tree [ rt << 1 ]. len + tree [ rt << 1 | 1 ]. len ; } else tree [ rt ]. len = 0 ; return ; } void build ( int rt , int l , int r ) { tree [ rt ]. l = l , tree [ rt ]. r = r ; 28 tree [ rt ]. len = 0.0 ; tree [ rt ]. cnt = 0 ; // cout<<l<<\" \"<<r<<endl; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( rt << 1 , l , mid ); build ( rt << 1 | 1 , mid + 1 , r ); } void update ( int rt , int l , int r , int x ) { if ( l <= tree [ rt ]. l && tree [ rt ]. r <= r ) { tree [ rt ]. cnt += x ; pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); return ; } int mid = ( tree [ rt ]. l + tree [ rt ]. r ) >> 1 ; ///2 if ( l <= mid ) update ( rt << 1 , l , r , x ); if ( r > mid ) update ( rt << 1 | 1 , l , r , x ); pushup ( rt , tree [ rt ]. l , tree [ rt ]. r ); } int main () { while ( ~ scanf ( \"%d\" , & n )) { if ( ! n ) break ; cnt = 0 ; /// 1 rep ( i , 1 , n ) { double x1 , y1 , x2 , y2 ; scanf ( \"%lf%lf%lf%lf\" , & x1 , & y1 , & x2 , & y2 ); raw [ i * 2 - 1 ] = y1 , raw [ i * 2 ] = y2 ; line [ i * 2 - 1 ]. x1 = x1 , line [ i * 2 - 1 ]. y1 = y1 , line [ i * 2 - 1 ]. y2 = y2 ; line [ i * 2 - 1 ]. k = 1 ; line [ i * 2 ]. x1 = x2 , line [ i * 2 ]. y1 = y1 , line [ i * 2 ]. y2 = y2 ; line [ i * 2 ]. k = - 1 ; } discrete (); sort ( line + 1 , line + 2 * n + 1 ); double ans = 0 ; build ( 1 , 1 , cnt ); rep ( i , 1 , 2 * n ) { ans += tree [ 1 ]. len * ( line [ i ]. x1 - line [ i - 1 ]. x1 ); update ( 1 , findx ( line [ i ]. y1 ), findx ( line [ i ]. y2 ) - 1 , line [ i ]. k ); } printf ( \"Test case #%d \\n Total explored area: %.2lf \\n\\n \" , t ++ , ans ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u6768\u777f","title":"\u7ebf\u6bb5\u6811lazy\u6807\u8bb0"},{"location":"Data_Structure/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 ///HDU 3911 \u9898\u610f\uff1a\u53cd\u8f6c\u64cd\u4f5c\uff1a\u6bcf\u6b21\u53cd\u8f6c\u4e00\u4e2a\u533a\u95f4\u5185 0 1 \u7684\u503c\uff0c\u67e5\u8be2\u64cd\u4f5c\uff1a\u67e5\u8be2\u6700\u957f\u7684 1 \u4ee3\u7801\uff1a #include <bits/stdc++.h> using namespace std ; #define lson rt << 1 #define rson rt << 1 | 1 const int N = 1e5 + 9 ; int a [ N ], n , m ; int tree0 [ N << 2 ], tree1 [ N << 2 ], lazy [ N << 2 ], lmax0 [ N << 2 ]; int lmax1 [ N << 2 ], rmax0 [ N << 2 ], rmax1 [ N << 2 ]; void swp ( int rt ) { swap ( tree0 [ rt ], tree1 [ rt ]); swap ( rmax0 [ rt ], rmax1 [ rt ]); swap ( lmax0 [ rt ], lmax1 [ rt ]); return ; } void pushup ( int rt ) { if ( ! tree0 [ lson ]) lmax1 [ rt ] = lmax1 [ lson ] + lmax1 [ rson ]; else lmax1 [ rt ] = lmax1 [ lson ]; if ( ! tree1 [ lson ]) lmax0 [ rt ] = lmax0 [ lson ] + lmax0 [ rson ]; else lmax0 [ rt ] = lmax0 [ lson ]; if ( ! tree0 [ rson ]) rmax1 [ rt ] = rmax1 [ rson ] + rmax1 [ lson ]; else rmax1 [ rt ] = rmax1 [ rson ]; if ( ! tree1 [ rson ]) rmax0 [ rt ] = rmax0 [ rson ] + rmax0 [ lson ]; else rmax0 [ rt ] = rmax0 [ rson ]; tree0 [ rt ] = max ( rmax0 [ lson ] + lmax0 [ rson ], max ( tree0 [ lson ], tree0 [ rson ])); tree0 [ rt ] = max ( tree0 [ rt ], max ( tree0 [ lson ], tree0 [ rson ])); tree0 [ rt ] = max ( tree0 [ rt ], max ( lmax0 [ rt ], rmax0 [ rt ])); tree1 [ rt ] = max ( rmax1 [ lson ] + lmax1 [ rson ], max ( tree1 [ lson ], tree1 [ rson ])); tree1 [ rt ] = max ( tree1 [ rt ], max ( tree1 [ lson ], tree1 [ rson ])); tree1 [ rt ] = max ( tree1 [ rt ], max ( lmax1 [ rt ], rmax1 [ rt ])); } void pushdown ( int rt ) { if ( lazy [ rt ]) { swp ( lson ); swp ( rson ); lazy [ lson ] ^= 1 ; lazy [ rson ] ^= 1 ; lazy [ rt ] = 0 ; } return ; 30 } void build ( int rt , int l , int r ) { lazy [ rt ] = 0 ; if ( l == r ) { scanf ( \"%d\" , & a [ l ]); if ( a [ l ] == 1 ) { tree0 [ rt ] = 0 ; tree1 [ rt ] = 1 ; lmax0 [ rt ] = 0 ; rmax0 [ rt ] = 0 ; lmax1 [ rt ] = 1 ; rmax1 [ rt ] = 1 ; } else { tree0 [ rt ] = 1 ; tree1 [ rt ] = 0 ; lmax0 [ rt ] = 1 ; rmax0 [ rt ] = 1 ; lmax1 [ rt ] = 0 ; rmax1 [ rt ] = 0 ; } // cout<<l<<endl; return ; } int mid = ( l + r ) >> 1 ; build ( lson , l , mid ); build ( rson , mid + 1 , r ); pushup ( rt ); } void change ( int rt , int l , int r , int x , int y ) { if ( l >= x && r <= y ) { lazy [ rt ] ^= 1 ; swp ( rt ); return ; } int mid = ( l + r ) >> 1 ; pushdown ( rt ); if ( x <= mid ) change ( lson , l , mid , x , y ); if ( y > mid ) change ( rson , mid + 1 , r , x , y ); pushup ( rt ); } int query ( int rt , int l , int r , int x , int y ) { if ( l >= x && r <= y ) { return tree1 [ rt ]; } int ans = 0 ; pushdown ( rt ); int mid = ( l + r ) >> 1 ; if ( x <= mid ) { ans = max ( query ( lson , l , mid , x , y ), ans ); } if ( y > mid ) { ans = max ( query ( rson , mid + 1 , r , x , y ), ans ); } ans = max ( ans , min ( mid - x + 1 , rmax1 [ lson ]) + min ( y - mid , lmax1 [ rson ])); return ans ; 31 } int main () { while ( ~ scanf ( \"%d\" , & n )) { build ( 1 , 1 , n ); scanf ( \"%d\" , & m ); while ( m -- ) { int op , l , r ; scanf ( \"%d%d%d\" , & op , & l , & r ); if ( op == 0 ) { printf ( \"%d \\n \" , query ( 1 , 1 , n , l , r )); } else { change ( 1 , 1 , n , l , r ); } // for(int i=1;i<=4*n;i++){ // printf(\"%d \",tree1[i]); // }puts(\"\"); } } } \u6574\u7406\u4eba\uff1a\u8ba1 18-8 \u6768\u777f","title":"\u7ebf\u6bb5\u6811\u533a\u95f4\u5408\u5e76"},{"location":"Data_Structure/%E8%8E%AB%E9%98%9F/","text":"1 2 3 BZOJ 2038 \u9898\u610f\uff1a\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 n \u548c m\uff0c\u4e4b\u540e\u7ed9\u51fa n \u4e2a\u6570\u4ee3\u8868 n \u4e2a\u889c\u5b50\u7684\u989c\u8272\uff0cm \u6b21\u8be2\u95ee\uff0c \u6bcf\u6b21\u7ed9\u51fa\u4e00\u4e2a[l, r]\uff0c\u95ee\u533a\u95f4\u5185\u7684\u968f\u673a\u62bd\u53d6\u4e24\u4e2a\u889c\u5b50\u989c\u8272\u76f8\u540c\u7684\u6982\u7387\u4e3a\u591a\u5c11\uff0c\u8f93\u51fa\u6700\u7b80\u5206\u6570 A/B \u7684\u5f62\u5f0f\uff0c\u82e5\u6982\u7387\u4e3a\u96f6\u5219\u8f93\u51fa 0/1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 1e5 + 7 ; const int M = 1e6 + 7 ; const int INF = 1e9 + 8 ; int block ; struct node { int l , r , id ; }; ll gcd ( ll x , ll y ) { return y == 0 ? x : gcd ( y , x % y ); } bool cmp ( node xx , node yy ) //\u5947\u5076\u6392\u5e8f\u4f18\u5316 { if ( xx . l / block == yy . l / block ) { if ( xx . l / block & 1 ) return xx . r < yy . r ; else return xx . r > yy . r ; } return xx . l / block < yy . l / block ; } class Moteam { 45 public : int a [ N ], sum [ N ], n , m ; ll ansx [ N ], ansy [ N ], ans ; node q [ N ]; void Add ( int i ) //\u6dfb\u52a0\u64cd\u4f5c { ans -= sum [ a [ i ]] * sum [ a [ i ]]; sum [ a [ i ]] ++ ; ans += sum [ a [ i ]] * sum [ a [ i ]]; } void Sub ( int i ) { ans -= sum [ a [ i ]] * sum [ a [ i ]]; sum [ a [ i ]] -- ; ans += sum [ a [ i ]] * sum [ a [ i ]]; } void solve () //\u4fee\u6539\u64cd\u4f5c { sort ( q + 1 , q + m + 1 , cmp ); int l = 1 ; int r = 1 ; sum [ a [ 1 ]] ++ ; ans = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( q [ i ]. l == q [ i ]. r ) //\u7279\u5224\u4e00\u4e0b ansx [ q [ i ]. id ] = 0 , ansy [ q [ i ]. id ] = 1 ; while ( l < q [ i ]. l ) Sub ( l ), l ++ ; while ( l > q [ i ]. l ) l -- , Add ( l ); while ( r < q [ i ]. r ) r ++ , Add ( r ); while ( r > q [ i ]. r ) Sub ( r ), r -- ; ll x = ( ans - ( q [ i ]. r - q [ i ]. l + 1 )); ll y = ( ll )( q [ i ]. r - q [ i ]. l + 1 ) * ( ll )( q [ i ]. r - q [ i ]. l ); ll d = gcd ( x , y ); ansx [ q [ i ]. id ] = x / d ; ansy [ q [ i ]. id ] = y / d ; } for ( int i = 1 ; i <= m ; i ++ ) printf ( \"%lld/%lld \\n \" , ansx [ i ], ansy [ i ]); } } mo ; int main () { memset ( mo . sum , 0 , sizeof mo . sum ); scanf ( \"%d %d\" , & mo . n , & mo . m ); for ( int i = 1 ; i <= mo . n ; i ++ ) scanf ( \"%d\" , & mo . a [ i ]); block = sqrt ( mo . n ); for ( int i = 1 ; i <= mo . m ; i ++ ) { scanf ( \"%d %d\" , & mo . q [ i ]. l , & mo . q [ i ]. r ); mo . q [ i ]. id = i ; } mo . solve (); return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u8463\u6587\u777f","title":"\u83ab\u961f\u7b97\u6cd5"},{"location":"Data_Structure/%E8%BE%B9%E5%89%96/","text":"1 2 3 4 5 6 ///\u6d1b\u8c37 P4315 \u9898\u610f\uff1a\u5bf9\u4e8e\u4e00\u9897\u6811\u6709\u5982\u4e0b\u64cd\u4f5c \u64cd\u4f5c 1: Change k w\uff1a\u5c06\u7b2c k \u6761\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u6539\u53d8\u4e3a w \u4e2a\u3002 \u64cd\u4f5c 2: Cover u v w\uff1a\u5c06\u8282\u70b9 u \u4e0e\u8282\u70b9 v \u4e4b\u95f4\u7684\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u90fd\u6539\u53d8\u4e3a w \u4e2a\u3002 \u64cd\u4f5c 3: Add u v w\uff1a\u5c06\u8282\u70b9 u \u4e0e\u8282\u70b9 v \u4e4b\u95f4\u7684\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u90fd\u589e\u52a0 w \u4e2a\u3002 \u64cd\u4f5c 4: Max u v\uff1a\u8be2\u95ee\u8282\u70b9 u \u4e0e\u8282\u70b9 v \u4e4b\u95f4\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u4e2a\u6570\u6700\u591a\u6709\u591a\u5c11\u4e2a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 #include <bits/stdc++.h> #define ls rt << 1 #define rs rt << 1 | 1 using namespace std ; typedef long long ll ; const int N = 1e5 + 5 ; int n , m , t , Root ; int a [ N ], rnk [ N ]; ///a \u7528\u6bcf\u6761\u8fb9\u7684\u4e24\u4e2a\u8282\u70b9\u4e2d\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e2a\u8282\u70b9\u4ee3\u8868\u8fd9\u6761\u8fb9\u7684\u6743\u503c\uff0crnk \u662f dfs \u5e8f\u4e3a i \u7684\u8282\u70b9 struct Edge { int next , to , val ; } edge [ N << 1 ]; ///\u8fb9 int head [ N ], etot ; void add ( int u , int v , int val ) { edge [ etot ] = { head [ u ], v , val }; head [ u ] = etot ++ ; } void init () { ///\u521d\u59cb\u5316 memset ( head , - 1 , sizeof ( head )); etot = 0 ; } class segmentTree { public : int tree [ N << 2 ], laz [ N << 2 ], laz2 [ N << 2 ]; ///laz \u662f\u8d4b\u503c laz\uff0claz2 \u662f\u52a0\u6cd5 laz void build ( int rt , int l , int r ) { laz [ rt ] = - 1 ; laz2 [ rt ] = 0 ; if ( l == r ) { tree [ rt ] = a [ rnk [ l ]]; return ; } int mid = ( l + r ) >> 1 ; build ( ls , l , mid ); build ( rs , mid + 1 , r ); tree [ rt ] = max ( tree [ ls ], tree [ rs ]); } void pushdown ( int rt , int l , int r ) { if ( laz [ rt ] != - 1 ) { laz2 [ ls ] = laz2 [ rs ] = 0 ; tree [ ls ] = laz [ ls ] = laz [ rt ]; tree [ rs ] = laz [ rs ] = laz [ rt ]; laz [ rt ] = - 1 ; } if ( laz2 [ rt ]) { tree [ ls ] += laz2 [ rt ]; tree [ rs ] += laz2 [ rt ]; laz2 [ ls ] += laz2 [ rt ]; laz2 [ rs ] += laz2 [ rt ]; laz2 [ rt ] = 0 ; } } void updateadd ( int rt , int l , int r , int ql , int qr , int val ) { if ( ql > qr ) return ; if ( ql <= l && r <= qr ) { tree [ rt ] += val ; laz2 [ rt ] += val ; return ; } pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) updateadd ( ls , l , mid , ql , qr , val ); if ( qr > mid ) updateadd ( rs , mid + 1 , r , ql , qr , val ); tree [ rt ] = max ( tree [ ls ], tree [ rs ]); } void updatefu ( int rt , int l , int r , int ql , int qr , int val ) { if ( ql > qr ) return ; if ( ql <= l && r <= qr ) { tree [ rt ] = val ; laz [ rt ] = val ; laz2 [ rt ] = 0 ; 39 return ; } pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) updatefu ( ls , l , mid , ql , qr , val ); if ( qr > mid ) updatefu ( rs , mid + 1 , r , ql , qr , val ); tree [ rt ] = max ( tree [ ls ], tree [ rs ]); } inline int query ( int rt , int l , int r , int ql , int qr ) { if ( ql > qr ) return 0 ; if ( ql <= l && r <= qr ) return tree [ rt ]; pushdown ( rt , l , r ); int mid = ( l + r ) >> 1 ; int res = 0 ; if ( ql <= mid ) res = max ( res , query ( ls , l , mid , ql , qr )); if ( qr > mid ) res = max ( res , query ( rs , mid + 1 , r , ql , qr )); return res ; } } Tree ; class TreeChainSubdivision { public : int son [ N ], tid [ N ], fa [ N ], dep [ N ], siz [ N ], top [ N ], dfscnt = 0 ; ///son \u91cd\u513f\u5b50\u7f16\u53f7,tid \u662f dfs \u5e8f,fa \u7236\u4eb2\u8282\u70b9,dep \u6df1\u5ea6\u4ece 1 \u5f00\u59cb\u7684 ///siz \u5b50\u6811\u5927\u5c0f,top \u5f53\u524d\u94fe\u9876\u7aef\u8282\u70b9,dfscnt \u662f dfs \u5e8f, ///\u591a\u7ec4\u8f93\u5165\u65f6 son \u8981\u521d\u59cb\u5316\uff01\uff01\uff01 void dfs1 ( int x , int f , int deep ) { dep [ x ] = deep ; siz [ x ] = 1 ; fa [ x ] = f ; int maxson = - 1 ; for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == f ) continue ; a [ to ] = edge [ i ]. val ; dfs1 ( to , x , deep + 1 ); siz [ x ] += siz [ to ]; if ( siz [ to ] > maxson ) son [ x ] = to , maxson = siz [ to ]; } } void dfs2 ( int x , int topf ) { tid [ x ] = ++ dfscnt ; rnk [ dfscnt ] = x ; top [ x ] = topf ; if ( ! son [ x ]) return ; dfs2 ( son [ x ], topf ); 40 for ( int i = head [ x ]; i != - 1 ; i = edge [ i ]. next ) { int to = edge [ i ]. to ; if ( to == fa [ x ] || to == son [ x ]) continue ; dfs2 ( to , to ); } } void updpathadd ( int x , int y , int val ) { while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); Tree . updateadd ( 1 , 1 , n , tid [ top [ x ]], tid [ x ], val ); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); Tree . updateadd ( 1 , 1 , n , tid [ x ] + 1 , tid [ y ], val ); } void updpathfu ( int x , int y , int val ) { while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); Tree . updatefu ( 1 , 1 , n , tid [ top [ x ]], tid [ x ], val ); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); Tree . updatefu ( 1 , 1 , n , tid [ x ] + 1 , tid [ y ], val ); } int Qpath ( int x , int y ) { int ans = 0 ; while ( top [ x ] != top [ y ]) { if ( dep [ top [ x ]] < dep [ top [ y ]]) swap ( x , y ); ans = max ( ans , Tree . query ( 1 , 1 , n , tid [ top [ x ]], tid [ x ])); x = fa [ top [ x ]]; } if ( dep [ x ] > dep [ y ]) swap ( x , y ); ans = max ( ans , Tree . query ( 1 , 1 , n , tid [ x ] + 1 , tid [ y ])); return ans ; } } TCS ; int main () { init (); scanf ( \"%d\" , & n ); int u , v , k , val ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { scanf ( \"%d%d%d\" , & u , & v , & val ); add ( u , v , val ); add ( v , u , val ); } 41 Root = 1 ; TCS . dfs1 ( Root , 0 , 1 ); TCS . dfs2 ( Root , Root ); Tree . build ( 1 , 1 , n ); char op [ 10 ]; while ( ~ scanf ( \"%s\" , op )) { if ( op [ 1 ] == 'h' ) { scanf ( \"%d%d\" , & k , & val ); k -- ; u = edge [ k << 1 ]. to ; v = edge [ k << 1 | 1 ]. to ; int now = TCS . dep [ u ] > TCS . dep [ v ] ? u : v ; Tree . updatefu ( 1 , 1 , n , TCS . tid [ now ], TCS . tid [ now ], val ); } else if ( op [ 1 ] == 'o' ) { scanf ( \"%d%d%d\" , & u , & v , & val ); TCS . updpathfu ( u , v , val ); } else if ( op [ 1 ] == 'd' ) { scanf ( \"%d%d%d\" , & u , & v , & val ); TCS . updpathadd ( u , v , val ); } else if ( op [ 1 ] == 'a' ) { scanf ( \"%d%d\" , & u , & v ); printf ( \"%d \\n \" , TCS . Qpath ( u , v )); } else break ; } return 0 ; } \u6574\u7406\u4eba\uff1a\u8ba1 18-7 \u725b\u4ed4\u8d85","title":"\u8fb9\u5256"},{"location":"Geometry/%E5%87%B8%E5%8C%85%E7%9A%84%E6%B1%82%E5%8F%96/","text":"poj 1912; \u9898\u610f\uff1a\u7ed9\u5b9a\u5e73\u9762\u4e0a n \u4e2a\u70b9\uff0c\u4e4b\u540e\u7ed9\u5b9a\u82e5\u5e72\u76f4\u7ebf\uff0c\u8be2\u95ee\u6240\u6709\u70b9\u65f6\u5019\u5728\u76f4\u7ebf\u7684\u4e00\u4fa7\uff1b \u601d\u8def\uff1a \u9996\u5148\u6c42\u53d6\u51f8\u5305\uff0c\u4e4b\u540e\u5c06\u51f8\u5305\u4e0a\u7684\u6bcf\u4e00\u6761\u8fb9\u7684\u503e\u659c\u89d2\u6c42\u51fa\uff0c\u5bf9\u503e\u659c\u89d2\u4e8c\u5206\uff0c\u627e\u51fa\u503e\u659c \u89d2\u6700\u63a5\u8fd1\u7ed9\u5b9a\u76f4\u7ebf\u503e\u659c\u89d2\u7684\u8fb9\u6240\u5bf9\u5e94\u7684\u70b9\uff0c\u5c06\u76f4\u7ebf\u65cb\u8f6c 180\u00b0\u540e\u5728\u6c42\u51fa\u5bf9\u5e94\u70b9\uff0c\u5224\u5b9a\u6240\u6c42\u4e24 \u70b9\u662f\u5426\u5728\u76f4\u7ebf\u4e24\u4fa7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 struct Line { Point p ; Vector v ; double ang ; Line () {} Line ( Point p , Vector v ) : p ( p ), v ( v ) { ang = atan2 ( v . y , v . x ); } Point point ( double t ) { return p + v * t ; } //\u6c42\u53d6\u76f4\u7ebf\u4e0a\u7684\u67d0\u4e00\u4e2a\u70b9 bool operator < ( Line & l ) { return ang < l . ang ; } //\u76f4\u7ebf\u9ed8\u8ba4\u4ee5\u503e\u659c\u89d2\u6392\u5e8f int Onleft ( Point P ) { return dcmp ( v ^ ( P - p )); } //\u5224\u65ad\u4e00\u4e2a\u70b9\u662f\u5426\u5728\u76f4\u7ebf\u7684\u5de6 \u4fa7 Point operator & ( Line & l ) //\u6c42\u53d6\u4e24\u76f4\u7ebf\u7684\u4ea4\u70b9 { Vector u = p - l . p ; double t = ( l . v ^ u ) / ( v ^ l . v ); return p + v * t ; } }; Point p [ N ], sta [ N ]; int n , top ; double af [ N ]; //\u7528\u4e8e\u8bb0\u5f55\u51f8\u5305\u6bcf\u4e00\u6761\u8fb9\u7684\u503e\u659c\u89d2 Line l ; bool cmp ( Point a , Point b ) //\u6781\u89d2\u6392\u5e8f { Vector v = a - p [ 0 ], w = b - p [ 0 ]; //\u4ee5\u67d0\u4e00\u70b9\u4e3a\u57fa\u51c6\u6c42\u51fa\u5176\u4ed6\u6240\u6709\u70b9\u76f8\u5bf9\u4e8e\u5b83\u7684\u6781\u89d2 83 if ( dcmp ( v ^ w ) < 0 ) return false ; else if ( ! dcmp ( v ^ w ) && dcmp ( sqr ( v ) - sqr ( w )) > 0 ) return false ; //\u6781\u89d2\u76f8\u540c\u4ee5\u5411\u91cf\u6a21\u957f \u6392\u5e8f return true ; } void graham () //\u51f8\u5305 { sort ( p + 1 , p + n , cmp ); n = unique ( p , p + n ) - p ; int t = n - 1 ; while ( t && ! (( p [ n - 1 ] - p [ 0 ]) ^ ( p [ t ] - p [ 0 ]))) t -- ; if ( ! t ) //\u5f53\u51f8\u5305\u9000\u5316\u4e3a\u4e00\u4e2a\u70b9\u6216\u8005\u4e00\u6761\u76f4\u7ebf\u65f6\u7684\u60c5\u51b5 { sta [ 0 ] = p [ 0 ]; top = 1 ; if ( n > 1 ) sta [ 1 ] = p [ n - 1 ], top = 2 ; return ; } reverse ( p + t + 1 , p + n ); //\u4e3a\u6c42\u53d6\u6240\u6709\u5728\u51f8\u5305\u8fb9\u754c\u4e0a\u7684\u70b9 sta [ top ++ ] = p [ 0 ]; sta [ top ++ ] = p [ 1 ]; p [ n ++ ] = p [ 0 ]; for ( int i = 2 ; i < n ; i ++ ) { while ( top > 1 && (( sta [ top - 1 ] - sta [ top - 2 ]) ^ ( p [ i ] - sta [ top - 2 ])) <= 0 ) top -- ; \u786e\u5b9a\u6bcf \u4e00\u4e2a\u89d2\u90fd\u4e0d\u4e3a\u4f18\u89d2 sta [ top ++ ] = p [ i ]; } top -- ; for ( int i = 0 ; i < top ; i ++ ) af [ i ] = atan2 ( sta [ i + 1 ]. y - sta [ i ]. y , sta [ i + 1 ]. x - sta [ i ]. x ); //\u6c42\u53d6\u6240\u6709\u8fb9\u7684\u503e\u659c\u89d2 } int main () { scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lf %lf\" , & p [ i ]. x , & p [ i ]. y ); if ( p [ i ] < p [ 0 ]) swap ( p [ i ], p [ 0 ]); } if ( n > 1 ) graham (); double a , b , c , d ; while ( ~ scanf ( \"%lf %lf %lf %lf\" , & a , & b , & c , & d )) { if ( n < 2 ) { puts ( \"GOOD\" ); 84 continue ; } l = Line ( Point ( a , b ), Vector ( c - a , d - b )); double l1 = atan2 ( l . v . y , l . v . x ), l2 = atan2 ( - l . v . y , - l . v . x ); int p1 = lower_bound ( af , af + top , l1 ) - af ; int p2 = lower_bound ( af , af + top , l2 ) - af ; if ( l . Onleft ( sta [ p1 ]) * l . Onleft ( sta [ p2 ]) < 0 ) puts ( \"BAD\" ); else puts ( \"GOOD\" ); } } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u51f8\u5305\u7684\u6c42\u53d6"},{"location":"Geometry/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/","text":"poj3525\uff1b \u9898\u610f\u7ed9\u51fa\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\uff0c\u6c42\u53d6\u5728\u8be5\u51f8\u591a\u8fb9\u5f62\u5185\u6700\u5927\u7684\u5706\u7684\u534a\u5f84\u4e3a\u591a\u5c11 \u601d\u8def\uff1a \u6bcf\u6b21\u5c06\u51f8\u591a\u8fb9\u7684\u6bcf\u4e00\u6761\u8fb9\u5411\u5185\u90e8\u79fb\u52a8\u4e00\u5b9a\u8ddd\u79bb\uff0c\u76f4\u5230\u51f8\u591a\u8fb9\u9762\u79ef\u6070\u597d\u4e3a\u96f6\u65f6\u8be5\u8ddd\u79bb\u8fb9 \u662f\u6240\u6c42\u5706\u7684\u534a\u5f84 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 int HAI ( Line * L , int n ) { sort ( L , L + n ); //\u76f4\u7ebf\u5411\u6309\u7167\u503e\u659c\u89d2\u6392\u5e8f int first , last ; Point * p = new Point [ n ]; //\u5229\u7528\u53cc\u7aef\u961f\u5217\u5b58\u53d6\u534a\u5e73\u9762\u4ea4\u7684\u4ea4\u70b9\uff0c\u4ee5\u53ca\u534a\u5e73\u9762 Line * l = new Line [ n ]; l [ first = last = 0 ] = L [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) { while ( first < last && ! L [ i ]. Onleft ( p [ last - 1 ])) last -- ; while ( first < last && ! L [ i ]. Onleft ( p [ first ])) first ++ ; l [ ++ last ] = L [ i ]; if ( ! dcmp ( l [ last ]. v ^ l [ last - 1 ]. v )) //\u82e5\u5b58\u5728\u4e24\u4e2a\u503e\u659c\u89d2\u76f8\u7b49\u7684\u534a\u5e73\u9762\uff0c\u9009\u62e9\u8ddd\u79bb\u76f8\u4ea4 \u533a\u57df\u66f4\u8fd1\u7684\u4e00\u4e2a { last -- ; if ( l [ last ]. Onleft ( L [ i ]. p )) l [ last ] = L [ i ]; } if ( first < last ) p [ last - 1 ] = l [ last - 1 ] & l [ last ]; } while ( first < last && ! l [ first ]. Onleft ( p [ last - 1 ])) last -- ; if ( last - first <= 1 ) return 0 ; p [ last ] = l [ last ] & l [ first ]; return last - first + 1 ; } 85 int n ; Point p [ N ]; Vector dir [ N ], nor [ N ]; Line line [ N ]; int main () { while ( scanf ( \"%d\" , & n ), n ) { for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lf %lf\" , & p [ i ]. x , & p [ i ]. y ); p [ n ] = p [ 0 ]; for ( int i = 0 ; i < n ; i ++ ) dir [ i ] = p [ i + 1 ] - p [ i ], nor [ i ] = normal ( dir [ i ]); double l = 0.0 , r = INF ; while ( dcmp ( r - l ) > 0 ) { double mid = ( l + r ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) line [ i ] = Line ( p [ i ] + nor [ i ] * mid , dir [ i ]); if ( HAI ( line , n )) l = mid ; else r = mid ; } printf ( \"%.6f \\n \" , l ); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u534a\u5e73\u9762\u4ea4"},{"location":"Geometry/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Aizu CGL_4_B; \u9898\u610f\uff1a\u7ed9\u5b9a\u5e73\u9762 n \u4e2a\u70b9\uff0c\u6c42\u53d6\u8ddd\u79bb\u6700\u5927\u7684\u70b9\u5bf9\uff1b double diame () { int i , j , k ; double res , t ; graham (); sta [ top ] = sta [ 0 ], res = 0.0 , j = 1 ; for ( i = 0 ; i < top ; i ++ ) { while ( dcmp ( fabs (( sta [ i ] - sta [ j ]) ^ ( sta [ i + 1 ] - sta [ j ])) - fabs (( sta [ i ] - sta [ j + 1 ]) ^ ( sta [ i + 1 ] - sta [ j + 1 ]))) < 0 ) //\u5bfb\u627e\u8ddd\u79bb\u56fa\u5b9a\u76f4\u7ebf\u8ddd\u79bb\u6700\u5927\u7684\u70b9 j = ( j + 1 ) % top ; t = sqr ( sta [ i ] - sta [ j ]); 86 if ( dcmp ( t - res ) > 0 ) res = t ; } return sqrt ( res ); } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u65cb\u8f6c\u5361\u58f3"},{"location":"Geometry/%E7%82%B9%E7%A7%AF%E5%8F%89%E7%A7%AF%E7%9A%84%E8%BF%90%E7%94%A8/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //poj2318 \u9898\u610f: \u5728\u4e00\u4e2a\u77e9\u5f62\u76d2\u5b50\u5185\u7528 n \u5757\u9694\u677f\u5c06\u77e9\u5f62\u5206\u6210\u82e5\u4e2a\u4e2a\u533a\u57df(\u9694\u677f\u4e0d\u76f8\u4ea4), \u7ed9\u5b9a m \u4e2a\u70b9\uff0c\u95ee\uff08 n + 1 \uff09\u4e2a\u533a\u57df\u5185\u5206\u522b\u6709\u591a\u5c11\u4e2a\u70b9\uff1b \u601d\u8def\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\u4e8c\u5206\u6c42\u51fa\u5b83\u6240\u5728\u7684\u533a\u57df #include <iostream> #include <cmath> #include <cstdio> #include <vector> #include <algorithm> #include <cstring> #define mem(a) memset(a, 0, sizeof a) using namespace std ; const int N = 1e5 + 7 ; const double eps = 1e-6 ; //\u63a7\u5236\u7cbe\u5ea6 int dcmp ( double x ) { if ( fabs ( x ) < eps ) return 0 ; else return x < 0 ? - 1 : 1 ; } struct Point { double x ; double y ; Point ( double x = 0 , double y = 0 ) : x ( x ), y ( y ) {} }; typedef Point Vector ; double operator * ( const Vector & v , const Vector & w ) { return v . x * w . x + v . y * w . y ; } //\u70b9\u79ef double operator ^ ( const Vector & v , const Vector & w ) { return v . x * w . y - v . y * w . x ; } //\u53c9\u79ef double sqr ( Vector v ) { return v * v ; } //\u5411\u91cf\u6a21\u7684\u5e73\u65b9 double length ( Vector v ) { return sqrt ( v * v ); } \u5411\u91cf\u7684\u6a21\u957f Vector operator - ( const Vector & v , const Vector & w ) { return Vector ( v . x - w . x , v . y - w . y ); } //\u5411\u91cf\u51cf\u6cd5 Vector operator + ( const Vector & v , const Vector & w ) { return Vector ( v . x + w . x , v . y + w . y ); } //\u5411\u91cf\u52a0\u6cd5 Vector operator * ( const Vector & v , double k ) { return Vector ( v . x * k , v . y * k ); } //\u5411\u91cf\u7684\u6570\u4e58 81 Vector rotate ( Vector v , double rad ) { return Vector ( v . x * cos ( rad ) - v . y * sin ( rad ), v . x * sin ( rad ) + v . y * cos ( rad )); } // \u5c06\u5411\u91cf\u9006\u65f6\u9488\u65cb\u8f6c rad Vector normal ( Vector v ) { return Vector ( - v . y / length ( v ), v . x / length ( v )); } //\u5411\u91cf\u7684\u5355\u4f4d\u6cd5\u5411\u91cf bool OnSeg ( Point O , Point A , Point B ) { return ! dcmp (( A - O ) ^ ( B - O )) && dcmp (( A - O ) * ( B - O )) <= 0 ; } //\u5224\u5b9a\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u4e0a bool operator == ( const Vector & A , const Vector & B ) { return ! dcmp ( A . x - B . x ) && ! dcmp ( A . y - B . y ); } //\u76f8\u91cf\u76f8\u7b49 bool operator < ( const Vector & v , const Vector & w ) { return v . x == w . x ? v . y < w . y : v . x < w . x ; } Point segs [ N ][ 2 ]; int n , m , res [ N ]; int find ( Point P ) { int l = 1 , r = n + 1 ; while ( l < r ) { int mid = l + r >> 1 ; Vector v = segs [ mid ][ 0 ] - segs [ mid ][ 1 ], w = P - segs [ mid ][ 1 ]; if (( v ^ w ) > 0 ) r = mid ; else l = mid + 1 ; } return l - 1 ; } int main () { bool flag = 0 ; while ( scanf ( \"%d\" , & n ), n ) { int x1 , x2 , y1 , y2 ; scanf ( \"%d%d%d%d%d\" , & m , & x1 , & y1 , & x2 , & y2 ); segs [ 0 ][ 0 ] = Point ( x1 , y1 ), segs [ 0 ][ 1 ] = Point ( x1 , y2 ); segs [ n + 1 ][ 0 ] = Point ( x2 , y1 ), segs [ n + 1 ][ 1 ] = Point ( x2 , y2 ); for ( int i = 1 ; i <= n ; i ++ ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); segs [ i ][ 0 ] = Point ( a , y1 ); segs [ i ][ 1 ] = Point ( b , y2 ); } mem ( res ); for ( int i = 0 ; i < m ; i ++ ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); 82 res [ find ( Point ( a , b ))] ++ ; } if ( ! flag ) flag = 1 ; else puts ( \"\" ); for ( int i = 0 ; i <= n ; i ++ ) printf ( \"%d: %d \\n \" , i , res [ i ]); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18 \u2013 3 \u51af\u7d2b\u541b","title":"\u70b9\u79ef\u53c9\u79ef\u7684\u8fd0\u7528"},{"location":"Graph/Dinic/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 ///\u6d1b\u8c37 P3376 typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; 60 const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; const int base = 100 ; struct edge { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; class Dinic { public : int S , T , n , m , cnt ; int head [ N ], d [ N ], cur [ N ]; edge e [ M ]; void addedge ( int u , int v , int cap ) { e [ ++ cnt ] = edge ( v , head [ u ], cap ); head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 , u , v , cap ; i <= m ; i ++ ) { read ( u ); read ( v ); read ( cap ); addedge ( u , v , cap ); addedge ( v , u , 0 ); } } // \u627e\u589e\u5e7f\u8def bool bfs () { mem ( d ); queue < int > q ; 61 q . push ( S ); d [ S ] = 1 ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] || e [ i ]. cap <= 0 ) continue ; d [ v ] = d [ u ] + 1 ; q . push ( v ); } } for ( int i = 0 ; i <= n ; i ++ ) cur [ i ] = head [ i ]; return d [ T ]; } int dfs ( int u , int flow ) { if ( u == T ) return flow ; for ( int & i = cur [ u ], v ; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] != d [ u ] + 1 || e [ i ]. cap <= 0 ) continue ; int delta = dfs ( v , min ( flow , e [ i ]. cap )); if ( delta <= 0 ) continue ; e [ i ]. cap -= delta ; e [ i ^ 1 ]. cap += delta ; return delta ; } return 0 ; } int get_maxFlow () { int maxFlow = 0 , tmp ; while ( bfs ()) while ( tmp = dfs ( S , INF )) maxFlow += tmp ; return maxFlow ; 62 } }; Dinic ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); printf ( \"%d \\n \" , ways . get_maxFlow ()); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"Dinic+\u5f53\u524d\u5f27\u4f18\u5316"},{"location":"Graph/EK/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 ///\u6d1b\u8c37 P3376 typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; struct edge { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; class EK { public : int S , T , n , m , cnt ; int head [ N ], vis [ N ]; int pre [ N ], flow [ N ]; edge e [ M ]; void addedge ( int u , int v , int cap ) 58 { e [ ++ cnt ] = edge ( v , head [ u ], cap ); head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); mem ( vis ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 , u , v , cap ; i <= m ; i ++ ) { read ( u ); read ( v ); read ( cap ); addedge ( u , v , cap ); addedge ( v , u , 0 ); } } // \u627e\u589e\u5e7f\u8def bool bfs () { mem ( vis ); queue < int > q ; q . push ( S ); vis [ S ] = 1 ; flow [ S ] = INF ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( vis [ v ] || e [ i ]. cap <= 0 ) continue ; flow [ v ] = min ( flow [ u ], e [ i ]. cap ); pre [ v ] = i ; q . push ( v ); vis [ v ] = 1 ; if ( v == T ) return 1 ; } } return 0 ; 59 } int update () { int u = T ; while ( u != S ) { int i = pre [ u ]; e [ i ]. cap -= flow [ T ]; e [ i ^ 1 ]. cap += flow [ T ]; u = e [ i ^ 1 ]. to ; } return flow [ T ]; } int get_maxFlow () { int maxFlow = 0 ; while ( bfs ()) maxFlow += update (); return maxFlow ; } }; EK ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); printf ( \"%d \\n \" , ways . get_maxFlow ()); } return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"EK \u7b97\u6cd5"},{"location":"Graph/ISAP/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 //\u6d1b\u8c37 P3376 typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; const int base = 100 ; int n , m , S , T ; struct edge { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; class ISAP { public : int S , T , n , m , cnt ; int head [ N ], d [ N ], cur [ N ], gap [ N ]; edge e [ M ]; void addedge ( int u , int v , int cap ) { e [ ++ cnt ] = edge ( v , head [ u ], cap ); 63 head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 , u , v , cap ; i <= m ; i ++ ) { read ( u ); read ( v ); read ( cap ); addedge ( u , v , cap ); addedge ( v , u , 0 ); } } // \u627e\u589e\u5e7f\u8def void bfs () { queue < int > q ; for ( int i = 1 ; i <= n ; i ++ ) { cur [ i ] = head [ i ]; d [ i ] = gap [ i ] = 0 ; } q . push ( T ); d [ T ] = gap [ 1 ] = 1 ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ]) continue ; d [ v ] = d [ u ] + 1 ; ++ gap [ d [ v ]]; q . push ( v ); } 64 } } int dfs ( int u , int flow ) { if ( u == T ) return flow ; int delta = 0 , v , temp ; for ( int & i = cur [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] + 1 != d [ u ]) continue ; temp = dfs ( v , min ( flow - delta , e [ i ]. cap )); if ( temp ) { e [ i ]. cap -= temp ; e [ i ^ 1 ]. cap += temp ; delta += temp ; } if ( flow == delta ) return flow ; } if ( ! ( -- gap [ d [ u ]])) d [ S ] = n + 1 ; ++ gap [ ++ d [ u ]]; cur [ u ] = head [ u ]; return delta ; } int get_maxFlow () { bfs (); int maxFlow = 0 ; while ( d [ S ] <= n ) maxFlow += dfs ( S , INF ); return maxFlow ; } }; ISAP ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); 65 printf ( \"%d \\n \" , ways . get_maxFlow ()); } return 0 ; } \u4f8b\u9898\uff1a \u7f51\u7edc\u6d41 24 \u9898 \u661f\u9645\u8f6c\u79fb Loj 6015 \u9898\u610f\uff1a \u73b0\u6709 n \u4e2a\u592a\u7a7a\u7ad9\u4f4d\u4e8e\u5730\u7403\u4e0e\u6708\u7403\u4e4b\u95f4\uff0c\u4e14\u6709 m \u8258\u516c\u5171\u4ea4\u901a\u592a\u7a7a\u8239\u5728\u5176\u95f4\u6765\u56de \u7a7f\u68ad\u3002\u6bcf\u4e2a\u592a\u7a7a\u7ad9\u53ef\u5bb9\u7eb3\u65e0\u9650\u591a\u7684\u4eba\uff0c\u800c\u6bcf\u8258\u592a\u7a7a\u8239 i \u53ea\u53ef\u5bb9\u7eb3 Hi \u4e2a\u4eba\u3002\u6bcf\u8258\u592a\u7a7a\u8239\u5c06 \u5468\u671f\u6027\u5730\u505c\u9760\u4e00\u7cfb\u5217\u7684\u592a\u7a7a\u7ad9\uff0c\u4f8b\u5982\uff1a1,3,4 \u8868\u793a\u8be5\u592a\u7a7a\u8239\u5c06\u5468\u671f\u6027\u5730\u505c\u9760\u592a\u7a7a\u7ad9 134134134\u22ef \u6bcf\u4e00\u8258\u592a\u7a7a\u8239\u4ece\u4e00\u4e2a\u592a\u7a7a\u7ad9\u9a76\u5f80\u4efb\u4e00\u592a\u7a7a\u7ad9\u8017\u65f6\u5747\u4e3a 1\u3002\u4eba\u4eec\u53ea\u80fd\u5728\u592a\u7a7a\u8239\u505c \u9760\u592a\u7a7a\u7ad9\uff08\u6216\u6708\u7403\u3001\u5730\u7403\uff09\u65f6\u4e0a\u3001\u4e0b\u8239\u3002 \u521d\u59cb\u65f6\u6240\u6709\u4eba\u5168\u5728\u5730\u7403\u4e0a\uff0c\u592a\u7a7a\u8239\u5168\u5728\u521d\u59cb\u7ad9\u3002 \u8bd5\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\uff0c\u627e\u51fa\u8ba9\u6240\u6709\u4eba\u5c3d\u5feb\u5730\u5168\u90e8\u8f6c\u79fb\u5230\u6708\u7403\u4e0a\u7684\u8fd0\u8f93\u65b9\u6848\u3002 \u5206\u6790\uff1a \u8fd9\u4e2a\u9898\u5176\u5b9e\u548c\u201c\u9b54\u672f\u7403\u201d\u8fd9\u4e2a\u9898\u7c7b\u4f3c\u3002\u9898\u610f\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e9b\u4eba\u8981\u4ece A ---> B \uff0c\u7a7a\u95f4 \u7ad9\u4e3a\u4e2d\u8f6c\u70b9\uff0c\u901a\u8fc7\u98de\u8239\u8f6c\u79fb\uff0c\u8fd9\u4e9b\u98de\u8239\u6bcf\u4e00\u5929\u51fa\u73b0\u5728\u56fa\u5b9a\u7a7a\u95f4\u7ad9\uff0c\u4e5f\u5373\u662f\u8bf4\u5929\u6570\u4e0d\u4e00\u5b9a\u7684\u65f6 \u5019\uff0c\u6574\u4e2a\u8fd0\u8f93\u56fe\u5c31\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u800c\u6bcf\u4e00\u5929\u4e4b\u95f4\u53c8\u662f\u6709\u5173\u7cfb\u7684\u3002 \u5c31\u597d\u50cf\uff0c\u6bcf\u4e00\u5929\u7684\u7a7a\u95f4\u7ad9\u662f\u4e0d \u4e00\u6837\u7684\uff08\u56e0\u4e3a\u98de\u8239\u98de\u884c\u7ebf\u8def\u4e0d\u4e00\u6837\u4e86\uff09\uff0c\u6240\u4ee5\u8003\u8651\u5230 \u5730\u7403\uff080 \u53f7\u70b9\uff09\u3001n \u4e2a\u7a7a\u95f4\u7ad9\u548c\u6708\u4eae\uff08n + 1 \u53f7\u70b9\uff09\u5171 n + 2 \u4e2a\u70b9\uff0c\u6bcf\u4e00\u5929\u5206\u88c2\u4e00\u6b21\uff08\u5373\u62e5\u6709\u4e00\u4e2a\u65b0\u7684\u72b6\u6001\uff09\uff0c\u6709\u56e0\u4e3a\u5171\u7ecf\u5386 t \u5929\uff0c \u5b8c\u6210\u8fd0\u8f93\uff0c\u6545 \u5c06\u8981\u5206\u88c2\u51fa t * (n + 2) \u4e2a\u70b9\u3010\u5373\u662f\u8bf4\u5c06\u6bcf\u4e00\u5929\u7684\u8fd9 n + 2 \u4e2a\u70b9\u770b\u6210\u4e00\u4e2a\u65b0\u7684 \u70b9\u3011\uff0c\u679a\u4e3e\u6bcf\u4e00\u5929 day\uff0c\u4ee4 yesterday = (n + 2) * (day \u2013 1)\uff0ctoday = (n + 2) * day\uff1b \u5219\u6bcf\u4e00\u4e2a \u70b9 i\u2019 = yesterday + i \uff08\u4ee3\u8868\u6628\u5929\u5bf9\u5e94\u7684\u70b9\uff09, i = today + i \uff08\u4ee3\u8868\u4eca\u5929\u7684\u70b9\uff09\uff1b\u6545 i\u2019--->i \uff0c\u5bb9 \u91cf\u4e3a INF\uff0c (n + 1) + today ---> T \uff0c\u5bb9\u91cf\u4e3a INF; \u5728\u4ece\u6bcf\u4e00\u4e2a\u98de\u8239\u524d\u4e00\u5929\u6240\u5728\u7684\u592a\u7a7a\u7ad9\u8fde\u5411\u540e\u4e00\u5929\u7684\u592a\u7a7a\u7ad9\uff0c\u6d41\u91cf\u4e3a\u98de\u8239\u53ef\u5bb9\u7eb3\u4eba \u6570\uff1b \u5728\u6700\u5f00\u59cb\u7684\u65f6\u5019 \u94fe\u63a5\u4e00\u6761\uff0c S ----> 0 \uff0c\u5bb9\u91cf\u4e3a INF \u7684\u8fb9 \u8dd1\u6700\u5927\u6d41\u76f4\u5230\u4e0d\u5c0f\u4e8e\u603b\u4eba\u6570\u5373\u53ef\u3002\uff08\u6bcf\u4e00\u5929\u7684\u6700\u5927\u6d41\u5e94\u7d2f\u52a0\u8d77\u6765\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 #pragma GCC optimize(2) #include <bits/stdc++.h> #define read(a) scanf(\"%d\", &a) #define readl(a) scanf(\"%lld\", &a) #define reads(a) scanf(\"%s\", a) #define readc(a) scanf(\"%c\", &a) #define pb push_back #define mem(a) memset(a, 0, sizeof(a)) #define Buff ios::sync_with_stdio(false) typedef long long ll ; using namespace std ; const int INF = 2e9 + 7 ; const int N = 1e5 + 7 ; const int M = 1e6 + 7 ; const int _N = 102 ; const int base = 100 ; int n , m , S , T ; struct edge 66 { int to , nex , cap ; edge ( int to = 0 , int nex = 0 , int cap = 0 ) : to ( to ), nex ( nex ), cap ( cap ) {} }; int pre [ _N ], station [ _N ][ _N ], r [ _N ], H [ _N ]; int head [ N ], d [ N ], cur [ N ], gap [ N ]; edge e [ M ]; class ISAP { public : int S , T , n , m , cnt , K ; void addedge ( int u , int v , int cap ) { e [ ++ cnt ] = edge ( v , head [ u ], cap ); head [ u ] = cnt ; e [ ++ cnt ] = edge ( u , head [ v ], 0 ); head [ v ] = cnt ; // printf(\"%d --- %d, %d\\n\", u, v, cap); } // \u5efa\u56fe void buildGraph () { // \u521d\u59cb\u5316\u90e8\u5206 read ( n ); read ( m ); read ( K ); mem ( head ); cnt = 1 ; S = N - 2 ; T = N - 1 ; for ( int i = 1 ; i <= m ; i ++ ) { read ( H [ i ]); read ( r [ i ]); for ( int j = 1 ; j <= r [ i ]; j ++ ) read ( station [ i ][ j ]); pre [ i ] = 1 ; } n += 2 ; addedge ( S , 0 , INF ); int ans = 0 ; for ( int day = 1 ; day <= 30 ; day ++ ) 67 { int today = n * day , yesterday = n * ( day - 1 ), now ; for ( int i = 0 ; i < n ; i ++ ) addedge ( yesterday + i , today + i , INF ); addedge ( today + n - 1 , T , INF ); for ( int i = 1 ; i <= m ; i ++ ) { now = pre [ i ] + 1 ; if ( now > r [ i ]) now = 1 ; addedge ( station [ i ][ pre [ i ]] + yesterday , station [ i ][ now ] + today , H [ i ]); pre [ i ] = now ; } ans += get_maxFlow (); if ( ans >= K ) { printf ( \"%d \\n \" , day ); return ; } } printf ( \"%d \\n \" , 0 ); } // \u627e\u589e\u5e7f\u8def void bfs () { queue < int > q ; for ( int i = 0 ; i <= T ; i ++ ) { cur [ i ] = head [ i ]; d [ i ] = gap [ i ] = 0 ; } q . push ( T ); d [ T ] = gap [ 1 ] = 1 ; int u , v ; while ( q . size ()) { u = q . front (); q . pop (); for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ]) continue ; 68 d [ v ] = d [ u ] + 1 ; ++ gap [ d [ v ]]; q . push ( v ); } } } int dfs ( int u , int flow ) { if ( u == T ) return flow ; int delta = 0 , v , temp ; for ( int & i = cur [ u ]; i ; i = e [ i ]. nex ) { v = e [ i ]. to ; if ( d [ v ] + 1 != d [ u ]) continue ; temp = dfs ( v , min ( flow - delta , e [ i ]. cap )); if ( temp ) { e [ i ]. cap -= temp ; e [ i ^ 1 ]. cap += temp ; delta += temp ; } if ( flow == delta ) return flow ; } if ( ! ( -- gap [ d [ u ]])) d [ S ] = T + 1 ; ++ gap [ ++ d [ u ]]; cur [ u ] = head [ u ]; return delta ; } int get_maxFlow () { bfs (); int maxFlow = 0 ; while ( d [ S ] <= T ) maxFlow += dfs ( S , INF ); return maxFlow ; } }; 69 ISAP ways ; signed main () { ways . buildGraph (); return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"ISAP\u7b97\u6cd5"},{"location":"Graph/KM%E7%AE%97%E6%B3%95/","text":"///HDU2255 \u6c42\u6700\u4f18\u5339\u914d \u9898\u610f\uff1a\u6709 N \u5bb6\u8001\u767e\u59d3\u548c N \u95f4\u623f\u5b50\uff0c\u8981\u7ed9\u6bcf\u5bb6\u5206\u914d\u4e00\u95f4\u623f\uff0c\u6bcf\u4e2a\u6751 \u6c11\u5bf9\u4e0d\u540c\u7684\u623f\u5b50\u51fa\u4ef7\u4e0d\u540c\uff0c\u73b0\u5728\u6751\u957f\u8981\u8ba9\u5229\u76ca\u6700\u5927\u5316\uff0c\u95ee\u5e94\u600e\u4e48\u5206\u914d\u624d\u80fd\u8ba9\u6751\u6c11\u51fa\u7684\u94b1\u6570\u603b \u548c\u6700\u5927\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <cstdio> #include <cstring> #include <algorithm> using namespace std ; int mp [ 303 ][ 303 ]; //\u8bb0\u5f55\u6751\u6c11\u5bf9\u5404\u4e2a\u623f\u5b50\u51fa\u4ef7\u60c5\u51b5 int lin [ 303 ]; //\u6807\u8bb0\u623f\u5b50\u6240\u5339\u914d\u5230\u7684\u6751\u6c11 int viy [ 303 ]; //\u6807\u8bb0\u623f\u5b50\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7 int vix [ 303 ]; //\u6807\u8bb0\u6751\u6c11\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7 int x [ 303 ]; //\u8bb0\u5f55\u6751\u6c11\u7684\u70b9\u6743 int y [ 303 ]; //\u8bb0\u5f55\u623f\u5b50\u7684\u70b9\u6743 int n ; int lack , t ; //lack \u8bb0\u5f55\u5355\u6b21\u8981\u6539\u53d8\u7684\u70b9\u6743\u5927\u5c0f int dfs ( int u ) { vix [ u ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! viy [ i ]) { 56 t = x [ u ] + y [ i ] - mp [ u ][ i ]; if ( t == 0 ) //t \u4e3a\u96f6\u4ee3\u8868 u \u6751\u6c11\u53ef\u4ee5\u548c i \u623f\u5b50\u5339\u914d { viy [ i ] = 1 ; if ( dfs ( lin [ i ]) || ! lin [ i ]) //i\u623f\u5b50\u6ca1\u5339\u914d\u8fc7\u6216i\u623f\u5b50\u5339\u914d\u5230\u7684\u6751\u6c11\u53ef\u4ee5\u4e0e\u5176\u5b83\u623f \u5b50\u5339\u914d { lin [ i ] = u ; return 1 ; } } else if ( lack > t ) lack = t ; } } return 0 ; } void KM () { memset ( y , 0 , sizeof ( y )); memset ( x , 0 , sizeof ( x )); memset ( lin , 0 , sizeof ( lin )); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) x [ i ] = max ( x [ i ], mp [ i ][ j ]); //x[i]\u8bb0\u5f55 i \u6751\u6c11\u6240\u6709\u51fa\u4ef7\u4e2d\u6700\u5927\u7684\u503c for ( int i = 1 ; i <= n ; i ++ ) { while ( 1 ) { memset ( vix , 0 , sizeof ( vix )); memset ( viy , 0 , sizeof ( viy )); lack = 1e9 + 7 ; if ( dfs ( i )) //i \u6751\u6c11\u5339\u914d\u6210\u529f break ; for ( int i = 1 ; i <= n ; i ++ ) { if ( vix [ i ]) x [ i ] -= lack ; //\u6751\u6c11\u70b9\u6743\u51cf\u5c0f if ( viy [ i ]) y [ i ] += lack ; //\u623f\u5b50\u70b9\u6743\u589e\u5927 } } } } int main () { 57 while ( ~ scanf ( \"%d\" , & n )) { memset ( mp , 0 , sizeof ( mp )); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) { scanf ( \"%d\" , & mp [ i ][ j ]); } KM (); int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += mp [ lin [ i ]][ i ]; //\u6c42\u548c } printf ( \"%d \\n \" , ans ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4f73\u59ae","title":"KM \u7b97\u6cd5"},{"location":"Graph/SPFA%E8%B4%B9%E7%94%A8%E6%B5%81/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 //\u6d1b\u8c37 P3381 typedef long long ll ; using namespace std ; const int INF = 1e18 + 7 ; const int N = 2e4 + 7 ; const int M = 2e5 + 7 ; const int base = 100 ; ll dis [ N ]; struct edge { int to , nex ; ll cap , cost ; edge ( int to = 0 , int nex = 0 , ll cap = 0 , ll cost = 0 ) : to ( to ), nex ( nex ), cap ( cap ), cost ( cost ) {} }; struct cmp { bool operator ()( int a , int b ) { return dis [ a ] > dis [ b ]; } }; class MCMF // MinCostMaxFlow { public : int S , T , n , m , cnt ; int head [ N ], Inq [ N ], pre [ N ]; ll flow [ N ]; edge e [ M ]; void addedge ( int u , int v , ll cap , ll cost ) { 70 e [ ++ cnt ] = edge ( v , head [ u ], cap , cost ); head [ u ] = cnt ; } // \u5efa\u56fe void buildGraph ( int _n , int _m , int _S , int _T ) { // \u521d\u59cb\u5316\u90e8\u5206 n = _n ; m = _m ; S = _S ; T = _T ; mem ( head ); cnt = 1 ; // \u6784\u56fe\u90e8\u5206 for ( int i = 1 ; i <= m ; i ++ ) { int u , v ; ll cap , cost ; read ( u ); read ( v ); readl ( cap ); readl ( cost ); addedge ( u , v , cap , cost ); addedge ( v , u , 0ll , - cost ); } } // \u627e\u589e\u5e7f\u8def bool SPFA () { priority_queue < int , vector < int > , cmp > q ; for ( int i = 0 ; i <= n ; i ++ ) { dis [ i ] = INF ; Inq [ i ] = 0 ; } dis [ S ] = 0 ; Inq [ S ] = 1 ; flow [ S ] = INF ; // q.push(make_pair(-dis[S], S)); q . push ( S ); int u , v ; ll cost ; // pair<ll, int> tmp; while ( q . size ()) { u = q . top (); q . pop (); Inq [ u ] = 0 ; // u = tmp.second; cost = -tmp.first; for ( int i = head [ u ]; i ; i = e [ i ]. nex ) 71 { v = e [ i ]. to ; // cout << \"u = \" << u << \" , v = \" << v << \"\\n\"; if ( ! e [ i ]. cap ) continue ; cost = dis [ u ] + e [ i ]. cost ; if ( dis [ v ] > cost ) { dis [ v ] = cost ; flow [ v ] = min ( flow [ u ], e [ i ]. cap ); pre [ v ] = i ; if ( ! Inq [ v ]) { q . push ( v ); Inq [ v ] = 1 ; } } } } return dis [ T ] != INF ; } void update () { int u = T ; while ( u != S ) { int i = pre [ u ]; e [ i ]. cap -= flow [ T ]; e [ i ^ 1 ]. cap += flow [ T ]; u = e [ i ^ 1 ]. to ; } } void get_MCMF () { ll maxFlow = 0 ; ll minCost = 0ll ; while ( SPFA ()) { update (); maxFlow += flow [ T ]; minCost += flow [ T ] * dis [ T ]; } printf ( \"%lld %lld \\n \" , maxFlow , minCost ); } 72 }; MCMF ways ; signed main () { int n , m , S , T ; while ( ~ scanf ( \"%d%d%d%d\" , & n , & m , & S , & T )) { ways . buildGraph ( n , m , S , T ); ways . get_MCMF (); // printf(\"%lld %lld\\n\", tmp.second, tmp.first); } return 0 ; } \u4f8b\u9898\uff1a \u7f51\u7edc\u6d41 24 \u9898 \u9910\u5dfe\u8ba1\u5212 LOJ 6008 \u9898\u610f\uff1a \u4e00\u4e2a\u9910\u5385\u5728\u76f8\u7ee7\u7684 N \u5929\u91cc,\u6bcf\u5929\u9700\u7528\u7684\u9910\u5dfe\u6570\u4e0d\u5c3d\u76f8\u540c\u3002\u5047\u8bbe\u7b2c i \u5929\u9700\u8981 ri \u5757\u9910\u5dfe ( i=1,2,...,N)\u3002\u9910\u5385\u53ef\u4ee5\u8d2d\u4e70\u65b0\u7684\u9910\u5dfe,\u6bcf\u5757\u9910\u5dfe\u7684\u8d39\u7528\u4e3a p \u5206;\u6216\u8005\u628a\u65e7\u9910\u5dfe\u9001\u5230\u5feb\u6d17\u90e8,\u6d17\u4e00 \u5757\u9700 m \u5929,\u5176\u8d39\u7528\u4e3a f \u5206;\u6216\u8005\u9001\u5230\u6162\u6d17\u90e8,\u6d17\u4e00\u5757\u9700 n(n>m),\u5176\u8d39\u7528\u4e3a s \u5206(s < f). \u6bcf\u5929\u7ed3\u675f \u65f6,\u9910\u5385\u5fc5\u987b\u51b3\u5b9a\u5c06\u591a\u5c11\u5757\u810f\u7684\u9910\u5dfe\u9001\u5230\u5feb\u6d17\u90e8,\u591a\u5c11\u5757\u9910\u5dfe\u9001\u5230\u6162\u6d17\u90e8,\u4ee5\u53ca\u591a\u5c11\u5757\u4fdd\u5b58\u8d77 \u6765\u5ef6\u671f\u9001\u6d17\u3002\u4f46\u662f\u6bcf\u5929\u6d17\u597d\u7684\u9910\u5dfe\u548c\u8d2d\u4e70\u7684\u65b0\u9910\u5dfe\u6570\u4e4b\u548c,\u8981\u6ee1\u8db3\u5f53\u5929\u7684\u9700\u6c42\u91cf\u3002\u8bd5\u8bbe\u8ba1\u4e00 \u4e2a\u7b97\u6cd5\u4e3a\u9910\u5385\u5408\u7406\u5730\u5b89\u6392\u597d N \u5929\u4e2d\u9910\u5dfe\u4f7f\u7528\u8ba1\u5212,\u4f7f\u603b\u7684\u82b1\u8d39\u6700\u5c0f\u3002\u7f16\u7a0b\u627e\u51fa\u4e00\u4e2a\u6700\u4f73\u9910\u5dfe \u4f7f\u7528\u8ba1\u5212\u3002 \u5206\u6790\uff1a \u6211\u4eec\u4e0d\u59a8\u5148\u8ba9\u6bcf\u5929\u5f00\u59cb\u65f6\u5f97\u5230\u7684 r[i]\u6761\u5e72\u51c0\u7684\u9910\u5dfe\uff08\u5de6\u8fb9\u4e00\u5217\u7684\u8282\u70b9\uff09\u6d41\u5411 t\uff0c\u7136\u540e\u518d \u5728\u6bcf\u5929\u7ed3\u675f\u65f6\u4ece s \u8865\u56de r[i]\u6761\u810f\u7684\u9910\u5dfe\uff08\u4ece s \u5411\u53f3\u8fb9\u4e00\u5217\u7684\u8282\u70b9\u8fde r[i],0 \u7684\u8fb9\uff09\uff0c\u5f97\u5230\u65b0\u56fe\u7684 \u94fe\u63a5\u65b9\u5f0f\uff1a 1 2 3 4 5 6 7 s -> i (r,p) \u6bcf\u5929\u65e9\u6668\u53ef\u4ee5\u4e70\u6700\u591a r \u6761\u65b0\u9910\u5dfe \u4e00\u6761 p \u5206 s -> i' (r,0) \u6bcf\u5929\u7528\u5269\u4e0b r \u6761\u810f\u9910\u5dfe \u6ca1\u6709\u4ee3\u4ef7 i -> t (r,0) \u6bcf\u5929\u8981\u7528 r \u6761\u5e72\u51c0\u9910\u5dfe \u6ca1\u6709\u4ee3\u4ef7 i' -> i+m (inf,f)\u810f\u6bdb\u5dfe\u9001\u5230\u5feb\u6d17\u5e97 \u6d17\u5e72\u51c0\u9001\u56de\u6765\u662f\u7b2c i+m \u5929\u6bcf\u6761\u82b1\u8d39\u4ee3\u4ef7 f \u5206 i' ->i+n (inf,s)\u810f\u6bdb\u5dfe\u9001\u5230\u6162\u6d17\u5e97 \u6d17\u5e72\u51c0\u9001\u56de\u6765\u662f\u7b2c i+n \u5929 \u6bcf\u6761\u82b1\u8d39\u4ee3\u4ef7 s \u5206 i' -> (i+1)' (inf,s) \u6bcf\u6761\u810f\u6bdb\u5dfe\u7559\u5230\u7b2c\u4e8c\u5929\u518d\u5904\u7406 \u6ca1\u6709\u4ee3\u4ef7 \u6700\u540e\u8dd1\u4e00\u6b21\u6700\u5c0f\u8d39\u7528\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #pragma GCC optimize(2) #include <bits/stdc++.h> #define read(a) scanf(\"%d\", &a) #define readl(a) scanf(\"%lld\", &a) #define reads(a) scanf(\"%s\", a) #define readc(a) scanf(\"%c\", &a) #define pb push_back #define mem(a) memset(a, 0, sizeof(a)) #define Buff ios::sync_with_stdio(false) 73 typedef long long ll ; using namespace std ; const ll INF = 1e16 + 7 ; const int N = 2e5 + 7 ; const int M = 1e6 + 7 ; ll dis [ N ], flow [ N ]; int head [ N ], cnt , Inq [ N ], pre [ N ]; int S , T , n , d1 , d2 ; ll p , f , s ; struct edge { int to , nex ; ll w , cost ; edge ( int _to = 0 , ll _w = 0 , ll _cost = 0 , int _nex = 0 ) { to = _to ; nex = _nex ; w = _w ; cost = _cost ; } } e [ M ]; void addedge ( int u , int v , ll w , ll cost ) { e [ ++ cnt ] = edge ( v , w , cost , head [ u ]); head [ u ] = cnt ; e [ ++ cnt ] = edge ( u , 0ll , - cost , head [ v ]); head [ v ] = cnt ; } queue < int > q ; bool SPAF () { while ( q . size ()) q . pop (); for ( int i = 0 ; i < N ; i ++ ) { dis [ i ] = INF ; Inq [ i ] = 0 ; } q . push ( S ); dis [ S ] = 0 ; Inq [ S ] = 1 ; flow [ S ] = INF ; int u , v ; ll cost ; while ( q . size ()) { u = q . front (); q . pop (); Inq [ u ] = 0 ; for ( int i = head [ u ]; i ; i = e [ i ]. nex ) { if ( ! e [ i ]. w ) continue ; v = e [ i ]. to ; cost = dis [ u ] + e [ i ]. cost ; if ( dis [ v ] > cost ) 74 { dis [ v ] = cost ; flow [ v ] = min ( flow [ u ], e [ i ]. w ); pre [ v ] = i ; if ( ! Inq [ v ]) { q . push ( v ); Inq [ v ] = 1 ; } } } } return dis [ T ] != INF ; } ll maxFlow , minCost ; void update () { int u = T , i ; while ( u != S ) { i = pre [ u ]; e [ i ]. w -= flow [ T ]; e [ i ^ 1 ]. w += flow [ T ]; u = e [ i ^ 1 ]. to ; } maxFlow += flow [ T ]; minCost += flow [ T ] * dis [ T ]; } void EK () { maxFlow = minCost = 0ll ; while ( SPAF ()) update (); printf ( \"%lld \\n \" , minCost ); } void buildGraph () { read ( n ); readl ( p ); read ( d1 ); readl ( f ); read ( d2 ); readl ( s ); mem ( head ); cnt = 1 ; S = 0 ; T = n << 1 | 1 ; for ( int i = 1 ; i <= n ; i ++ ) 75 { ll r ; readl ( r ); addedge ( S , i , r , p ); addedge ( S , i + n , r , 0ll ); addedge ( i , T , r , 0ll ); if ( i + 1 <= n ) addedge ( i + n , i + 1 + n , INF , 0ll ); if ( i + d1 <= n ) addedge ( i + n , i + d1 , INF , f ); if ( i + d2 <= n ) addedge ( i + n , i + d2 , INF , s ); } } signed main () { buildGraph (); EK (); return 0 ; } \u6574\u7406\u4eba\uff1a\u7f51\u7edc 18-3 \u9ad8\u4e91\u6cfd","title":"SPFA \u8d39\u7528\u6d41"},{"location":"Graph/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/","text":"///POJ1274 \u6c42\u6700\u5927\u5339\u914d \u9898\u610f\uff1a\u6709 N \u6761\u725b\u548c M \u4e2a\u725b\u68da\uff0c\u6bcf\u6761\u725b\u90fd\u6709\u81ea\u5df1\u559c\u6b22\u7684\u51e0\u4e2a\u725b\u68da\uff0c\u95ee \u6700\u591a\u53ef\u4ee5\u8ba9\u591a\u5c11\u6761\u725b\u5446\u5728\u81ea\u5df1\u559c\u6b22\u7684\u725b\u68da\uff08\u725b\u68da\u548c\u725b\u4e00\u5bf9\u4e00\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <cstdio> #include <cstring> using namespace std ; typedef long long ll ; const int N = 1e5 + 10 ; const int mod = 1e9 + 7 ; int d [ 205 ][ 205 ]; //d \u6570\u7ec4\u6807\u8bb0\u6709\u54ea\u4e9b\u8fb9 int lin [ 205 ]; //lin \u6570\u7ec4\u6807\u8bb0\u725b\u68da\u5339\u914d\u5230\u4e86\u54ea\u5934\u725b int vi [ 205 ]; //vi \u6570\u7ec4\u6807\u8bb0\u725b\u68da\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7 int n , m ; int fin ( int x ) { for ( int i = 1 ; i <= m ; i ++ ) { if ( d [ i ][ x ] && vi [ i ] == 0 ) { vi [ i ] = 1 ; if ( lin [ i ] == 0 || fin ( lin [ i ]) == 1 ) //i \u53f7\u725b\u68da\u8fd8\u6ca1\u6709\u5339\u914d\u725b\u6216\u53ef\u4ee5\u4e3a\u5b83\u6240\u5339\u914d\u7684\u725b\u627e\u4e00 \u4e2a\u65b0\u7684\u6ee1\u610f\u7684\u725b\u68da { lin [ i ] = x ; return 1 ; } } } return 0 ; } int main () { while ( ~ scanf ( \"%d%d\" , & n , & m )) { memset ( d , 0 , sizeof ( d )); memset ( lin , 0 , sizeof ( lin )); int c , u ; 55 for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & c ); while ( c -- ) { scanf ( \"%d\" , & u ); d [ i ][ u ] = 1 ; //\u8fde\u8fb9 } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { memset ( vi , 0 , sizeof ( vi )); //vi \u6570\u7ec4\u6bcf\u6b21\u90fd\u8981\u6e05 if ( fin ( i ) == 1 ) //i \u53f7\u725b\u627e\u5230\u53ef\u4ee5\u4e0e\u5b83\u5339\u914d\u7684\u725b\u68da cnt ++ ; } printf ( \"%d \\n \" , cnt ); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4f73\u59ae","title":"\u5308\u7259\u5229\u7b97\u6cd5"},{"location":"Others/","text":"","title":"Index"},{"location":"Others/Time/","text":"1. \u641c\u7d22 \u00b6 n\u4e2a\u70b9/\u72b6\u6001,m\u6761\u8fb9 DFS BFS \u53cc\u5411\u641c\u7d22 \u8bb0\u5fc6\u5316\u641c\u7d22 \u6781\u5927\u6781\u5c0f\u641c\u7d22 \u542f\u53d1\u5f0f\u641c\u7d22 \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u5907\u6ce8 \u4e0d\u7a33\u5b9a \u4e0e\u542f\u53d1\u51fd\u6570\u6709\u5173 2. \u52a8\u6001\u89c4\u5212 \u00b6 \u72b6\u538bDP \u6811\u5f62DP \u533a\u95f4DP \u6570\u4f4dDP \u6982\u7387DP \u65f6\u95f4\u590d\u6742\u5ea6 O(N^2*2^n) O(N^2*2^n) O(N) O(N) O(N^3) O(N^3) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u7a7a\u95f4\u590d\u6742\u5ea6 O(2^n) O(2^n) O(N) O(N) O(N^2) O(N^2) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u5907\u6ce8 \u90fd\u662f\u6570\u7ec4\u5927\u5c0f \u90fd\u662f\u6570\u7ec4\u5927\u5c0f 3. \u6570\u636e\u7ed3\u6784 \u00b6 \u4e00\u7ef4\u6811\u72b6\u6570\u7ec4 \u6811\u5f62DP ST\u8868 RMQ \u7ebf\u6bb5\u6811 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) O(\\log N * \\log M) O(\\log N * \\log M) O(1) O(1) O(N\\log N) O(N\\log N) O(\\log N) O(\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) O(N\\log N) O(N\\log N) O(N) O(N) O(N) O(N) \u5907\u6ce8 N*M\u7684\u77e9\u9635 \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u7a7a\u95f44N\uff0c\u9884\u5904\u7406\u4e3a\u7a7a\u95f4\u5927\u5c0f \u6811\u94fe\u5256\u5206-\u70b9\u5256 \u6811\u94fe\u5256\u5206-\u8fb9\u5256 \u5206\u5757\u7b97\u6cd5 \u83ab\u961f\u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(10*N) O(10*N) O(10*N) O(10*N) O(n) O(n) O(n) O(n) \u5907\u6ce8 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u70b9\u5206\u6cbb caldis() \u6c42\u91cd\u5fc3 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84 4. \u56fe\u8bba \u00b6 \u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u77e9\u9635\uff09 \u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u8868\uff09 KM \u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N^{3}) O(N^{3}) O(N*M) O(N*M) O(N^{3}) O(N^{3}) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N^{2}) O(N^{2}) O(M+N) O(M+N) O(N^{2}) O(N^{2}) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84 \u7f51\u7edc\u6d41-EK \u7f51\u7edc\u6d41-Dinic \u7f51\u7edc\u6d41-ISAP \u8d39\u7528\u6d41-SPFA \u65f6\u95f4\u590d\u6742\u5ea6 O(N*M*M) O(N*M*M) O(N*N*M) O(N*N*M) O(N*N*M) O(N*N*M) O(V+E+\\log V) O(V+E+\\log V) \u7a7a\u95f4\u590d\u6742\u5ea6 O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) \u5907\u6ce8 N \u4e3a\u8282\u70b9\u6570\uff0c M \u4e3a\u8fb9\u6570 \u6700\u5927\u6d41\u8dd1\u6700\u5927\u5339 \u914d \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n*sqrt(m)) \u6240\u6709\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f \u6700\u5927\u4e0a\u754c\uff0c\u5e73\u5e38\u90fd\u8fbe\u4e0d \u5230 5. \u5b57\u7b26\u4e32 \u00b6 \u5b57\u5178\u6811 AC \u81ea\u52a8\u673a \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N*K) O(N*K) O(N*K) O(N*K) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6 6. \u8ba1\u7b97\u51e0\u4f55 \u00b6 Graham \u534a\u5e73\u9762\u4ea4 \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\log N) O(N \\log N) O(N \\log N) O(N \\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6","title":"\u65f6\u95f4/\u7a7a\u95f4\u590d\u6742\u5ea6"},{"location":"Others/Time/#1","text":"n\u4e2a\u70b9/\u72b6\u6001,m\u6761\u8fb9 DFS BFS \u53cc\u5411\u641c\u7d22 \u8bb0\u5fc6\u5316\u641c\u7d22 \u6781\u5927\u6781\u5c0f\u641c\u7d22 \u542f\u53d1\u5f0f\u641c\u7d22 \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) O(N^{\\frac{1}{2}}-N^2) O(N^{\\frac{1}{2}}-N^2) O(N) O(N) <<O(N) <<O(N) <<O(N) <<O(N) \u5907\u6ce8 \u4e0d\u7a33\u5b9a \u4e0e\u542f\u53d1\u51fd\u6570\u6709\u5173","title":"1. \u641c\u7d22"},{"location":"Others/Time/#2","text":"\u72b6\u538bDP \u6811\u5f62DP \u533a\u95f4DP \u6570\u4f4dDP \u6982\u7387DP \u65f6\u95f4\u590d\u6742\u5ea6 O(N^2*2^n) O(N^2*2^n) O(N) O(N) O(N^3) O(N^3) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u7a7a\u95f4\u590d\u6742\u5ea6 O(2^n) O(2^n) O(N) O(N) O(N^2) O(N^2) O(size[dp]) O(size[dp]) O(size[dp]) O(size[dp]) \u5907\u6ce8 \u90fd\u662f\u6570\u7ec4\u5927\u5c0f \u90fd\u662f\u6570\u7ec4\u5927\u5c0f","title":"2. \u52a8\u6001\u89c4\u5212"},{"location":"Others/Time/#3","text":"\u4e00\u7ef4\u6811\u72b6\u6570\u7ec4 \u6811\u5f62DP ST\u8868 RMQ \u7ebf\u6bb5\u6811 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) O(\\log N * \\log M) O(\\log N * \\log M) O(1) O(1) O(N\\log N) O(N\\log N) O(\\log N) O(\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) O(N\\log N) O(N\\log N) O(N) O(N) O(N) O(N) \u5907\u6ce8 N*M\u7684\u77e9\u9635 \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u9884\u5904\u7406 O(N\\log N) O(N\\log N) \u7a7a\u95f44N\uff0c\u9884\u5904\u7406\u4e3a\u7a7a\u95f4\u5927\u5c0f \u6811\u94fe\u5256\u5206-\u70b9\u5256 \u6811\u94fe\u5256\u5206-\u8fb9\u5256 \u5206\u5757\u7b97\u6cd5 \u83ab\u961f\u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N\\log N \\log N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) O(N \\sqrt N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(10*N) O(10*N) O(10*N) O(10*N) O(n) O(n) O(n) O(n) \u5907\u6ce8 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u7531\u4e8e\u6570\u7ec4\u8fc7\u591a\u7ed9 \u4e86\u4e00\u4e2a 10 \u7684\u5e38\u6570 \u70b9\u5206\u6cbb caldis() \u6c42\u91cd\u5fc3 \u65f6\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N\\log N) O(N\\log N) O(N) O(N) O(N\\log N) O(N\\log N) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84","title":"3. \u6570\u636e\u7ed3\u6784"},{"location":"Others/Time/#4","text":"\u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u77e9\u9635\uff09 \u5308\u7259\u5229\u7b97\u6cd5\uff08\u90bb\u63a5\u8868\uff09 KM \u7b97\u6cd5 \u65f6\u95f4\u590d\u6742\u5ea6 O(N^{3}) O(N^{3}) O(N*M) O(N*M) O(N^{3}) O(N^{3}) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N^{2}) O(N^{2}) O(M+N) O(M+N) O(N^{2}) O(N^{2}) \u5907\u6ce8 \u70b9\u5206\u6cbb\u5185\u90e8\uff1a\u6c42\u57fa\u672c\u8def\u5f84 \u7f51\u7edc\u6d41-EK \u7f51\u7edc\u6d41-Dinic \u7f51\u7edc\u6d41-ISAP \u8d39\u7528\u6d41-SPFA \u65f6\u95f4\u590d\u6742\u5ea6 O(N*M*M) O(N*M*M) O(N*N*M) O(N*N*M) O(N*N*M) O(N*N*M) O(V+E+\\log V) O(V+E+\\log V) \u7a7a\u95f4\u590d\u6742\u5ea6 O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) O(M+N) \u5907\u6ce8 N \u4e3a\u8282\u70b9\u6570\uff0c M \u4e3a\u8fb9\u6570 \u6700\u5927\u6d41\u8dd1\u6700\u5927\u5339 \u914d \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n*sqrt(m)) \u6240\u6709\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f \u6700\u5927\u4e0a\u754c\uff0c\u5e73\u5e38\u90fd\u8fbe\u4e0d \u5230","title":"4. \u56fe\u8bba"},{"location":"Others/Time/#5","text":"\u5b57\u5178\u6811 AC \u81ea\u52a8\u673a \u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N*M) O(N*M) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N*K) O(N*K) O(N*K) O(N*K) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6","title":"5. \u5b57\u7b26\u4e32"},{"location":"Others/Time/#6","text":"Graham \u534a\u5e73\u9762\u4ea4 \u65f6\u95f4\u590d\u6742\u5ea6 O(N \\log N) O(N \\log N) O(N \\log N) O(N \\log N) \u7a7a\u95f4\u590d\u6742\u5ea6 O(N) O(N) O(N) O(N) \u5907\u6ce8 K \u4e3a\u6a21\u5f0f\u4e32\u6570\u91cf M \u4e3a\u6587\u672c\u4e32\u957f\u5ea6","title":"6. \u8ba1\u7b97\u51e0\u4f55"},{"location":"Others/exem/","text":"\u4e00\u3001\u641c\u7d22 \u00b6 1.1 \u6df1\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahrbust 1743 1.2 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahdu 2612 1.3 \u53cc\u5411\u641c\u7d22\uff1a 1.4 \u8bb0\u5fc6\u5316\u641c\u7d22\uff1ahdoj1078 1.5 \u6781\u5927\u6781\u5c0f\u641c\u7d22\uff1apoj1568 1.6 \u542f\u53d1\u5f0f\u641c\u7d22\uff1apoj1077 \u4e8c\u3001\u52a8\u6001\u89c4\u5212 \u00b6 2.1 \u72b6\u538b Dp\uff1ahdu 5418 2.2 \u6811\u5f62 Dp\uff1aP1352 2.3 \u533a\u95f4 Dp\uff1anoi1995 2.4 \u6570\u4f4d Dp\uff1ahttps: // loj.ac/problems/tag/104 2.5 \u6982\u7387&\u671f\u671b Dp\uff1ahttps: // vjudge.net/contest/76505 \u4e09\u3001\u6570\u636e\u7ed3\u6784 \u00b6 3.1 \u4e00\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj3468 3.2 \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj2155 3.3 ST \u8868\uff1a\u6d1b\u8c37 p3865 3.4 Rmq\uff1apoj3264 3.5 \u7ebf\u6bb5\u6811\uff1aPoj3468, HDU3911, HDU1542 3.6.1 \u6811\u94fe\u5256\u5206-\u70b9\u5256\uff1a\u6d1b\u8c37 P3384\uff0cHYSBZ 4196\uff0cHYSBZ 3531\uff0cHYSBZ 2243 3.6.2 \u6811\u94fe\u5256\u5206-\u8fb9\u5256\uff1a\u6d1b\u8c37 P4315\uff0cHYSBZ 2157 3.7 \u5206\u5757\u7b97\u6cd5\uff1aPOJ 3468 3.8 \u83ab\u961f\u7b97\u6cd5\uff1aZOJ 2038 3.9 \u70b9\u5206\u6cbb\uff1aPOJ 1655\uff0cPOJ 2114\uff0cPOJ 1741\uff0cHDU 4812\uff0cHYSBZ 2152\uff0cHDU 5977\uff0c POJ 1987 \u56db\u3001\u56fe\u8bba \u00b6 4.1.1 \u5308\u7259\u5229\u7b97\u6cd5\uff1aPOJ1274\u3001POJ1469\u3001POJ3041\u3001POJ1325\u3001POJ1466\u3001POJ2226\u3001 HDU1281 4.1.2 KM \u7b97\u6cd5\uff1aHDU2255 4.2 \u6700\u5927\u6d41\uff1a\u6d1b\u8c37 P3376\u3001LOJ 6015 4.3 \u8d39\u7528\u6d41\uff1a\u6d1b\u8c37 P3381\u3001LOJ 6008 \u4e94\u3001\u5b57\u7b26\u4e32 \u00b6 5.1 \u5b57\u5178\u6811\uff1ahdu1251 5.2 AC \u81ea\u52a8\u673a\uff1ahdu2222 \u516d\u3001\u8ba1\u7b97\u51e0\u4f55 \u00b6 6.1 \u70b9\u79ef\u53c9\u79ef\u7684\u5e94\u7528\uff1apoj2318 6.2 Graham\uff1apoj 1912 6.3 \u534a\u5e73\u9762\u4ea4\uff1apoj3525 6.4 \u65cb\u8f6c\u5361\u58f3\uff1aAizu CGL_4_B","title":"\u4e60\u9898"},{"location":"Others/exem/#_1","text":"1.1 \u6df1\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahrbust 1743 1.2 \u5e7f\u5ea6\u4f18\u5148\u641c\u7d20\uff1ahdu 2612 1.3 \u53cc\u5411\u641c\u7d22\uff1a 1.4 \u8bb0\u5fc6\u5316\u641c\u7d22\uff1ahdoj1078 1.5 \u6781\u5927\u6781\u5c0f\u641c\u7d22\uff1apoj1568 1.6 \u542f\u53d1\u5f0f\u641c\u7d22\uff1apoj1077","title":"\u4e00\u3001\u641c\u7d22"},{"location":"Others/exem/#_2","text":"2.1 \u72b6\u538b Dp\uff1ahdu 5418 2.2 \u6811\u5f62 Dp\uff1aP1352 2.3 \u533a\u95f4 Dp\uff1anoi1995 2.4 \u6570\u4f4d Dp\uff1ahttps: // loj.ac/problems/tag/104 2.5 \u6982\u7387&\u671f\u671b Dp\uff1ahttps: // vjudge.net/contest/76505","title":"\u4e8c\u3001\u52a8\u6001\u89c4\u5212"},{"location":"Others/exem/#_3","text":"3.1 \u4e00\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj3468 3.2 \u4e8c\u7ef4\u6811\u72b6\u6570\u7ec4\uff1apoj2155 3.3 ST \u8868\uff1a\u6d1b\u8c37 p3865 3.4 Rmq\uff1apoj3264 3.5 \u7ebf\u6bb5\u6811\uff1aPoj3468, HDU3911, HDU1542 3.6.1 \u6811\u94fe\u5256\u5206-\u70b9\u5256\uff1a\u6d1b\u8c37 P3384\uff0cHYSBZ 4196\uff0cHYSBZ 3531\uff0cHYSBZ 2243 3.6.2 \u6811\u94fe\u5256\u5206-\u8fb9\u5256\uff1a\u6d1b\u8c37 P4315\uff0cHYSBZ 2157 3.7 \u5206\u5757\u7b97\u6cd5\uff1aPOJ 3468 3.8 \u83ab\u961f\u7b97\u6cd5\uff1aZOJ 2038 3.9 \u70b9\u5206\u6cbb\uff1aPOJ 1655\uff0cPOJ 2114\uff0cPOJ 1741\uff0cHDU 4812\uff0cHYSBZ 2152\uff0cHDU 5977\uff0c POJ 1987","title":"\u4e09\u3001\u6570\u636e\u7ed3\u6784"},{"location":"Others/exem/#_4","text":"4.1.1 \u5308\u7259\u5229\u7b97\u6cd5\uff1aPOJ1274\u3001POJ1469\u3001POJ3041\u3001POJ1325\u3001POJ1466\u3001POJ2226\u3001 HDU1281 4.1.2 KM \u7b97\u6cd5\uff1aHDU2255 4.2 \u6700\u5927\u6d41\uff1a\u6d1b\u8c37 P3376\u3001LOJ 6015 4.3 \u8d39\u7528\u6d41\uff1a\u6d1b\u8c37 P3381\u3001LOJ 6008","title":"\u56db\u3001\u56fe\u8bba"},{"location":"Others/exem/#_5","text":"5.1 \u5b57\u5178\u6811\uff1ahdu1251 5.2 AC \u81ea\u52a8\u673a\uff1ahdu2222","title":"\u4e94\u3001\u5b57\u7b26\u4e32"},{"location":"Others/exem/#_6","text":"6.1 \u70b9\u79ef\u53c9\u79ef\u7684\u5e94\u7528\uff1apoj2318 6.2 Graham\uff1apoj 1912 6.3 \u534a\u5e73\u9762\u4ea4\uff1apoj3525 6.4 \u65cb\u8f6c\u5361\u58f3\uff1aAizu CGL_4_B","title":"\u516d\u3001\u8ba1\u7b97\u51e0\u4f55"},{"location":"Search/","text":"","title":"Index"},{"location":"Search/BFS/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // bfs \u67e5\u627e \u4ece s \u70b9 \u80fd\u5426\u5230\u8fbe t \u70b9 class Bfs { public : bool vis [ N ]; queue < int > q ; void bfs ( int s , int t ) 3 { while ( ! q . emtpy ()) q . pop (); memset ( vis , true , sizeof ( vis )); vis [ s ] = false ; q . push ( s ); while ( ! q . empty ()) { int z = q . front (); q . pop (); if ( z == t ) return true ; // \u641c\u7d22 z \u70b9\u80fd\u591f\u5230\u8fbe\u7684\u6240\u6709\u70b9\uff0c\u5165\u961f\uff0c\u5e76\u4e14\u6807\u8bb0 } return false ; } }; \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22"},{"location":"Search/DFS/","text":"\u9898\u76ee\u94fe\u63a5\uff1a hrbust 1743 Word Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // hrbust 1743 \u9898\u610f: n*m \u5b57\u7b26\u77e9\u9635\uff0cq \u6b21\u67e5\u8be2\u67d0\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u662f\u77e9\u9635\u7684\u4e00\u6761\u8def\u5f84 #include <stdio.h> #include <string.h> #define N 55 char a [ N ][ N ]; char str [ N ]; int len ; // \u5b58 str \u5b57\u7b26\u4e32\u957f\u5ea6 bool vis [ N ][ N ]; //\u6bcf\u4e2a\u70b9\u53ea\u80fd\u8d70\u4e00\u6b21 int n , m ; class Dfs { public : int dx [ 10 ] = { 0 , 0 , - 1 , 1 }; // dx,dy \u7ec4\u6210\u4e0a\u4e0b\u5de6\u53f3 int dy [ 10 ] = { 1 , - 1 , 0 , 0 }; bool dfs ( int x , int y , int z ) { if ( z == len ) return true ; for ( int i = 0 ; i < 4 ; i ++ ) { int xx = x + dx [ i ]; int yy = y + dy [ i ]; if ( xx > 0 && yy > 0 && xx <= n && yy <= m && a [ xx ][ yy ] == str [ z ] && vis [ xx ][ yy ]) { vis [ xx ][ yy ] = false ; if ( dfs ( xx , yy , z + 1 )) return true ; vis [ xx ][ yy ] = true ; } } return false ; } } dfs ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { 2 int q ; scanf ( \"%d %d %d\" , & n , & m , & q ); for ( int i = 1 ; i <= n ; i ++ ) scanf ( \"%s\" , a [ i ] + 1 ); for ( int qq = 0 ; qq < q ; qq ++ ) { scanf ( \"%s\" , str ); len = strlen ( str ); memset ( vis , true , sizeof ( vis )); int zt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { vis [ i ][ j ] = false ; if ( a [ i ][ j ] == str [ 0 ] && dfs . dfs ( i , j , 1 )) { zt = 1 ; break ; } vis [ i ][ j ] = true ; } if ( zt ) break ; } if ( zt ) printf ( \"Yes \\n \" ); else printf ( \"No \\n \" ); } printf ( \" \\n \" ); } } \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22"},{"location":"Search/DeSearch/","text":"// \u5bf9\u4e8e\u5355\u5411\u641c\u7d22\u6709 2^n 2^n \u53ef\u80fd\u7684\u60c5\u51b5\uff0c\u82e5\u4ece\u8d77\u59cb\u70b9\u548c\u7ec8\u70b9\u540c\u65f6\u641c\uff0c\u53ef\u4ee5\u53d8\u6210 2 \u4e2a 2^{(n/2)} 2^{(n/2)} \u79cd\u53ef\u80fd\uff0c\u7136\u540e\u8fdb\u884c\u5408\u5e76\u3002\u4f8b\u5982\uff1a\u6bcf\u6b21\u64cd\u4f5c\u53ef\u4ee5\u9009\u62e9*a \u6216\u8005+b\uff0c\u95ee\u6570\u5b57\u4ece n \u5f00\u59cb\u64cd\u4f5c 40 \u6b21 \u53d8\u6210 m \u7684\u53ef\u80fd\u6027\u6709\u591a\u5c11\u79cd\u3002\u53ef\u4ee5\u9009\u62e9\u6b63\u5411\u53cd\u5411\u540c\u65f6\u6c42\u51fa 2^{20} 2^{20} \u4e2a\u7b54\u6848\uff0c\u7136\u540e\u8fdb\u884c\u5408\u5e76\u3002 \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u53cc\u5411\u641c\u7d22"},{"location":"Search/Memory_Search/","text":"// \u4e00\u822c\u6765\u8bf4\u641c\u7d22\u7684\u7ed3\u679c\u6570\u91cf\u6709\u9650\uff0c\u56e0\u6b64\u5728\u641c\u7d22\u65f6\uff0c\u4f1a\u628a\u641c\u5230\u7684\u7ed3\u679c\u4e5f\u8bb0\u5f55\u5230\u4e00\u4e2a\u6570\u7ec4\uff0c \u4e0b\u6b21\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u3002 \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u8bb0\u5fc6\u5316\u641c\u7d22"},{"location":"Search/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 //poj 1077 A* \u89e3\u51b3\u516b\u6570\u7801\u95ee\u9898\uff083*3 \u7684\u68cb\u76d8\uff0c\u6709 8 \u4e2a\u6807\u53f7\u662f 1-8 \u7684\u68cb\u5b50\uff0c\u4e00\u4e2a\u7a7a\u683c\u3002\u6bcf 7 \u6b21\u53ef\u4ee5\u628a\u4e00\u4e2a\u4e0e\u7a7a\u683c\u76f8\u90bb\u7684\u68cb\u5b50\u79fb\u52a8\u5230\u7a7a\u683c\u4e0a\uff0c\u7ed9\u51fa\u4e00\u4e2a\u76ee\u6807\u68cb\u76d8\uff0c\u95ee\u6700\u5c11\u79fb\u52a8\u6b21\u6570\uff09 #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <iostream> #include <string> #include <queue> using namespace std ; const int maxn = 15 , maxs = 362885 ; class AStar { public : const int nxt [ 4 ][ 2 ] = {{ - 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 }}; const char dir [ 4 ] = { 'u' , 'd' , 'l' , 'r' }; int bit [ maxn ], fact [ maxn ]; AStar () { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 9 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; } inline int ask ( int x ) { int ret = 0 ; while ( x ) ret += bit [ x ], x -= x & - x ; return ret ; } inline void add ( int x , int d ) { while ( x <= 9 ) bit [ x ] += d , x += x & - x ; } struct Node { int i , x , y ; string s , ans ; bool operator < ( const Node & rhs ) const { return x + y > rhs . x + rhs . y ; 8 } } st ; int vis [ maxs ]; priority_queue < Node > q ; inline int cantor ( string s ) { memset ( bit , 0 , sizeof ( bit )); for ( int i = 0 ; i < 9 ; ++ i ) if ( s [ i ] == 'x' ) s [ i ] = '0' ; int ans = 1 ; for ( int i = 8 ; i >= 0 ; -- i ) { ans += ask ( s [ i ] - '0' ) * fact [ 8 - i ]; add ( s [ i ] - '0' + 1 , 1 ); } return ans ; } inline int diff ( string s ) { int ans = 0 ; for ( int i = 0 ; i < 9 ; ++ i ) { int x = i / 3 , y = i % 3 ; if ( s [ i ] == 'x' ) ans += abs ( x - 2 ) + abs ( y - 2 ); else { int j = s [ i ] - '1' ; ans += abs ( x - j / 3 ) + abs ( y - j % 3 ); } } return ans ; } inline string bfs ( string s ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( s [ i ] == 'x' ) st . i = i ; st . x = 0 , st . y = diff ( s ); st . s = s , st . ans = \"\" ; vis [ cantor ( st . s )] = 1 ; 9 q . push ( st ); while ( ! q . empty ()) { Node u = q . top (), v ; q . pop (); if ( u . s == \"12345678x\" ) return u . ans ; int x = u . i / 3 , y = u . i % 3 ; for ( int i = 0 ; i < 4 ; ++ i ) { int nx = x + nxt [ i ][ 0 ], ny = y + nxt [ i ][ 1 ]; if ( nx < 0 || nx > 2 || ny < 0 || ny > 2 ) continue ; v . i = 3 * nx + ny ; v . s = u . s ; swap ( v . s [ u . i ], v . s [ v . i ]); if ( vis [ cantor ( v . s )]) continue ; vis [ cantor ( v . s )] = 1 ; v . x = u . x + 1 , v . y = diff ( v . s ); v . ans = u . ans + dir [ i ]; q . push ( v ); } } return \"unsolvable\" ; } } a_star ; int main () { char in [ 2 ]; string s = \"\" ; for ( int i = 1 ; i <= 9 ; ++ i ) { scanf ( \"%s\" , in ); s += in [ 0 ]; } int cnt = 0 ; for ( int i = 8 ; i >= 0 ; -- i ) if ( s [ i ] != 'x' ) cnt += a_star . ask ( s [ i ] - '0' ), a_star . add ( s [ i ] - '0' , 1 ); if ( cnt & 1 ) printf ( \"unsolvable\" ); else cout << a_star . bfs ( s ); return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // IDA* \u89e3\u51b3\u516b\u6570\u7801\u95ee\u9898 #include <stdio.h> #include <math.h> #include <string.h> #include <algorithm> #define INF 40000 using namespace std ; int f [ 10 ]; class IDAStar { public : int dx [ 10 ] = { 0 , 0 , 1 , - 1 }; int dy [ 10 ] = { 1 , - 1 , 0 , 0 }; char dxy [ 10 ] = \"rldu\" ; char ans [ 1005 ]; int hh () //\u4f30\u503c\u51fd\u6570=\u6bcf\u4e00\u4e2a\u90fd\u76f4\u63a5\u8d70\u5230\u81ea\u5df1\u4f4d\u7f6e\u7684\u6b65\u6570 { int i , j , sum = 0 ; for ( i = 0 ; i < 9 ; i ++ ) { if ( f [ i ]) sum += abs ( i / 3 - ( f [ i ] - 1 ) / 3 ) + abs ( i % 3 - ( f [ i ] - 1 ) % 3 ); } return sum ; } int minn ; bool dfs ( int x , int g , int depth ) //x \u4ee3\u8868'x'\u7684\u4f4d\u7f6e g \u4ee3\u8868\u73b0\u5728\u8d70\u4e86\u591a\u5c11 depth \u4ee3\u8868\u672c\u6b21\u6700 \u591a\u8d70\u591a\u5c11 { int h = hh (); minn = min ( minn , h ); //\u627e\u5230\u8fd9\u6b21\u79bb\u7ec8\u70b9\u6700\u8fd1\u7684\u8ddd\u79bb\u662f\u591a\u5c11\uff0c\u4f46\u5b9e\u9645\u8ddd\u79bb\u4e00\u5b9a\u662f>=\u4f30\u8ba1 \u8ddd\u79bb if ( h == 0 ) { ans [ g ] = '\\0' ; printf ( \"%s \\n \" , ans ); return true ; } if ( g + h > depth ) return false ; int xx , yy ; int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { xx = x / 3 + dx [ i ]; 11 yy = x % 3 + dy [ i ]; if ( xx >= 0 && yy >= 0 && xx < 3 && yy < 3 ) { if ( g ) { if ( i == 0 && ans [ g - 1 ] == 'l' ) continue ; //\u8fd9\u6b21\u5f80\u4e0a\uff0c\u4e0a\u6b21\u5f80\u4e0b\u80af\u5b9a\u662f\u4e0d\u53ef\u4ee5\u7684 if ( i == 1 && ans [ g - 1 ] == 'r' ) continue ; if ( i == 2 && ans [ g - 1 ] == 'u' ) continue ; if ( i == 3 && ans [ g - 1 ] == 'd' ) continue ; } ans [ g ] = dxy [ i ]; f [ x ] = f [ xx * 3 + yy ]; f [ xx * 3 + yy ] = 0 ; if ( dfs ( xx * 3 + yy , g + 1 , depth )) return true ; f [ xx * 3 + yy ] = f [ x ]; f [ x ] = 0 ; } } return false ; } void IDA_star ( int x ) { int depth = hh (); while ( 1 ) { minn = INF ; if ( dfs ( x , 0 , depth )) { break ; } depth += minn ; } } bool pan () { int i , j , k = 0 ; for ( i = 0 ; i < 9 ; i ++ ) { if ( f [ i ] == 0 ) continue ; for ( j = 0 ; j < i ; j ++ ) 12 { if ( f [ j ] > f [ i ]) k ++ ; } } if ( k % 2 ) return true ; return false ; } } ida_star ; char a [ 105 ]; int main () { while ( gets ( a )) { int i , j , a1 = strlen ( a ), k = 0 , x , y ; for ( i = 0 ; i < a1 ; i ++ ) { if ( a [ i ] != ' ' ) { if ( a [ i ] == 'x' ) { x = k / 3 ; y = k % 3 ; f [ k ] = 0 ; k ++ ; } else f [ k ++ ] = a [ i ] - '0' ; } } if ( ida_star . pan ()) printf ( \"unsolvable \\n \" ); else ida_star . IDA_star ( x * 3 + y ); } } // 1 2 3 4 5 6 7 8 x \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u542f\u53d1\u5f0f\u641c\u7d22"},{"location":"Search/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E6%90%9C%E7%B4%A2-alpha-beta%E5%89%AA%E6%9E%9D/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 // \u66b4\u529b\u641c\u7d22\uff0c\u4f46\u5bf9\u4e8e\u67d0\u4e9b\u7279\u5b9a\u60c5\u51b5\u53ef\u4ee5\u901a\u8fc7 alphat-beta \u503c\u76f4\u63a5\u4f18\u5316\u6389 #include <stdio.h> #include <math.h> #include <algorithm> using namespace std ; char a [ 10 ][ 10 ]; 4 class MinimaxSearch { public : int xx , yy ; int Evaluate () //\u5224\u65ad 1 \u662f x \u80dc\u5229 -1 \u662f o \u80dc\u5229 0 \u662f\u6ca1\u6709\u80dc\u5229 { int i , j , z , zz , zt , zzt ; for ( i = 0 ; i < 4 ; i ++ ) { z = 0 , zz = 0 , zt = 0 , zzt = 0 ; for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == 'x' ) z ++ ; else if ( a [ i ][ j ] == 'o' ) zz ++ ; if ( a [ j ][ i ] == 'x' ) zt ++ ; else if ( a [ j ][ i ] == 'o' ) zzt ++ ; } if ( z == 4 || zt == 4 ) return 1 ; if ( zz == 4 || zzt == 4 ) return - 1 ; } zt = 0 , zzt = 0 , z = 0 , zz = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { if ( a [ i ][ i ] == 'x' ) z ++ ; if ( a [ i ][ i ] == 'o' ) zz ++ ; if ( a [ i ][ 3 - i ] == 'x' ) zt ++ ; if ( a [ i ][ 3 - i ] == 'o' ) zzt ++ ; } if ( z == 4 || zt == 4 ) return 1 ; if ( zz == 4 || zzt == 4 ) return - 1 ; return 0 ; } int Max ( int depth , int upalpha , int upbeta ) { 5 int alpha = upalpha , beta = upbeta ; int val ; int flag = Evaluate (); if ( flag || depth == 0 ) //\u5df2\u7ecf\u6709\u4e00\u65b9\u80dc\u5229\uff0c\u6216\u8005\u5168\u4e0b\u5b8c return flag ; int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == '.' ) { a [ i ][ j ] = 'x' ; val = Min ( depth - 1 , alpha , beta ); a [ i ][ j ] = '.' ; alpha = max ( alpha , val ); if ( alpha >= beta ) { xx = i , yy = j ; return alpha ; } } } } return alpha ; } int Min ( int depth , int upalpha , int upbeta ) { int alpha = upalpha , beta = upbeta ; int val ; int flag = Evaluate (); if ( flag || depth == 0 ) //\u5df2\u7ecf\u6709\u4e00\u65b9\u80dc\u5229\uff0c\u6216\u8005\u5168\u4e0b\u5b8c return flag ; int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == '.' ) { a [ i ][ j ] = 'o' ; val = Max ( depth - 1 , alpha , beta ); a [ i ][ j ] = '.' ; beta = min ( beta , val ); if ( beta <= alpha ) return beta ; 6 } } } return beta ; } } miniMax ; int main () { char c ; while ( scanf ( \"%c\" , & c ) != EOF ) { if ( c == '$' ) break ; int i , j ; int sum = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { scanf ( \"%s\" , a [ i ]); for ( j = 0 ; j < 4 ; j ++ ) { if ( a [ i ][ j ] == '.' ) sum ++ ; } } if ( sum > 11 ) //\u521a\u4e0b\u56db\u4e2a\u5b50\u65f6\u4e0d\u53ef\u80fd\u6709\u51b3\u80dc\u70b9\uff0c\u6ca1\u6709\u8fd9\u4e2a\u4e00\u76f4 TLE { printf ( \"##### \\n \" ); getchar (); continue ; } int z = miniMax . Max ( sum , - 1 , 1 ); if ( z == 1 ) printf ( \"(%d,%d) \\n \" , miniMax . xx , miniMax . yy ); else printf ( \"##### \\n \" ); getchar (); } } \u6574\u7406\u4eba \u8ba1 16-1 \u5218\u660e\u8f89","title":"\u6781\u5927\u6781\u5c0f\u5316\u641c\u7d22"},{"location":"String/","text":"","title":"Index"},{"location":"String/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 /* hdu2222 \u9898\u610f\uff1a\u6bcf\u7ec4\u6570\u636e\u6709 n \u4e2a\u6a21\u5f0f\u4e32\uff0c\u8be2\u95ee\u5728\u6587\u672c\u4e32\u4e2d\u51fa\u73b0\u4e86\u591a\u5c11\u6a21\u5f0f\u4e32 */ #include <bits/stdc++.h> using namespace std ; const int maxn = 1e6 ; // \u8bf7\u5f00\u6210 \u6a21\u5f0f\u4e32\u957f\u5ea6*\u6a21\u5f0f\u4e32\u6570\u91cf const int ch_size = 26 ; // \u8bf7\u5f00\u6210\u5b57\u7b26\u96c6\u5927\u5c0f class Ac_automaton { public : int trie [ maxn ][ ch_size ]; int vis [ maxn ], fail [ maxn ]; int tot ; void init () { memset ( vis , 0 , sizeof vis ); memset ( trie , 0 , sizeof trie ); tot = 0 ; } void insert ( char * str ) { int len = strlen ( str ); int pos = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; if ( ! trie [ pos ][ c ]) trie [ pos ][ c ] = ++ tot ; pos = trie [ pos ][ c ]; } vis [ pos ] ++ ; } void build () { queue < int > q ; for ( int i = 0 ; i < ch_size ; i ++ ) { 78 if ( trie [ 0 ][ i ]) { fail [ trie [ 0 ][ i ]] = 0 ; q . push ( trie [ 0 ][ i ]); } } while ( ! q . empty ()) { int pos = q . front (); q . pop (); for ( int i = 0 ; i < ch_size ; i ++ ) { if ( trie [ pos ][ i ]) { fail [ trie [ pos ][ i ]] = trie [ fail [ pos ]][ i ]; q . push ( trie [ pos ][ i ]); } else { trie [ pos ][ i ] = trie [ fail [ pos ]][ i ]; } } } } int query ( char * str ) { int len = strlen ( str ); int pos = 0 , ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; pos = trie [ pos ][ c ]; for ( int j = pos ; j && vis [ j ] != - 1 ; j = fail [ j ]) { ans += vis [ j ]; vis [ j ] = - 1 ; } } return ans ; } }; Ac_automaton ac ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ac . init (); char str [ maxn ]; int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%s\" , str ); 79 ac . insert ( str ); } ac . build (); scanf ( \"%s\" , str ); printf ( \"%d \\n \" , ac . query ( str )); } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4e1c\u741b","title":"AC\u81ea\u52a8\u673a"},{"location":"String/%E5%AD%97%E5%85%B8%E6%A0%91/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* hdu1251 \u9898\u610f\uff1a\u7ed9\u51fa\u4e00\u4e9b\u6a21\u5f0f\u4e32\uff0c\u7136\u540e\u6709\u4e00\u4e9b\u63d0\u95ee\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u63d0\u95ee\uff0c\u7ed9\u51fa\u4ee5\u8be5\u5b57\u7b26\u4e32\u4e3a\u524d\u7f00\u7684\u6a21\u5f0f\u4e32 \u7684\u6570\u91cf. */ #include <bits/stdc++.h> using namespace std ; const int maxn = 1e6 + 7 ; //\u8bf7\u5f00\u5230\u6a21\u5f0f\u4e32\u957f\u5ea6*\u6a21\u5f0f\u4e32\u6570\u91cf const int ch_size = 26 ; //\u8bf7\u5f00\u6210\u5b57\u7b26\u96c6\u5927\u5c0f class Trie { public : int trie [ maxn ][ ch_size ]; int vis [ maxn ], tot ; void init () { memset ( trie , 0 , sizeof trie ); memset ( vis , 0 , sizeof vis ); tot = 0 ; } void insert ( char * str ) { int len = strlen ( str ); int pos = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; if ( ! trie [ pos ][ c ]) trie [ pos ][ c ] = ++ tot ; pos = trie [ pos ][ c ]; vis [ pos ] ++ ; } //vis[pos]++; } int query ( char * str ) { int len = strlen ( str ); int pos = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int c = str [ i ] - 'a' ; if ( ! trie [ pos ][ c ]) return 0 ; pos = trie [ pos ][ c ]; } return vis [ pos ]; } }; 77 Trie tr ; int main () { char str [ maxn ]; while ( cin . getline ( str , maxn ) && strlen ( str )) { tr . insert ( str ); } while ( ~ scanf ( \"%s\" , str )) { cout << tr . query ( str ) << endl ; } } \u6574\u7406\u4eba\uff1a\u8ba1 18-5 \u738b\u4e1c\u741b","title":"\u5b57\u5178\u6811"}]}