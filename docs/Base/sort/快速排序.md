### 1. 任务

!!! question "将一个乱序数组按升序排序"

### 2. 接口

!!! danger "void quick_sort(int q[], int l, int r)"
    - **时间复杂度：** $O( N \log N)$ 
    - **q[]**....要排序的数组
    - **l**......排序的左区间端点
    - **r**......排序的右区间端点

### 3. 代码

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int x = q[l+r >> 1], i = l - 1, j = r + 1;
    while(i < j){
        while(q[++i] < x); while(q[--j] > x);
        if(i < j) swap(q[i],q[j]);
    }
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
}
```
### 4. 使用范例

??? note "[AcWing 785. 快速排序](https://www.acwing.com/problem/content/description/787/)"
    ```c++
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 100000;

    int q[N];
    void quick_sort(int q[], int l, int r)
    {
        if (l >= r) return;
        int x = q[l+r >> 1], i = l - 1, j = r + 1;
        while(i < j){
            while(q[++i] < x); while(q[--j] > x);
            if(i < j) swap(q[i],q[j]);
        }
        quick_sort(q,l,j);
        quick_sort(q,j+1,r);
    }


    int main()
    {
        int n;
        scanf("%d",&n);
        for (int i = 0; i < n ; i ++) scanf("%d",&q[i]);
        quick_sort(q,0,n-1);
        for (int i = 0; i < n ; i ++) printf("%d ",q[i]);
        return 0;
    }
    ```


!!! check "编辑信息"
    **本页贡献者：**鲁明翰 
    

    **页面最后更新时间**: **2019/12/21**
